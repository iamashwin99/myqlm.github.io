Executing / Compiling quantum jobs
==================================

QPUs & Plugins on the QLM
-------------------------

A **QPU**, or *Quantum Processor Unit* is the abstraction used on the QLM for designating either the workflow of a
quantum computer, or an emulator of such a workflow.
QLM provides several classical emulators of QPUs.

    See :ref:`simulating` for more information on QPUs.

A **Plugin** is an object from the QLM API that can be used to process quantum circuits (or jobs) on their way to or
on their way back from a QPU. A plugin can also be used independently from any QPU, they are in this case used
only for *compiling* a circuit without executing it on a QPU.

    See :ref:`manipulating` for more information on plugins.

Getting a remote object
-----------------------

QPUs and plugins can respectively be "imported" from the QLM as *remote QPUs* and *remote plugins*.

A *remote QPU* can then be instanciated, creating a :class:`~qat.qlmaas.qpus.QLMaaSQPU`.
Similarly, a *remote plugin* can be instanciated, creating a :class:`~qat.qlmaas.plugins.QLMaaSPlugin`.
These instanciated objects can then be used to process jobs.

.. toggle-header::
   :header: **Getting remote objects with the qlmaas module (requires a configuration file)**

   If a configuration file is set, myQLM is able to automatically connect
   to the QLMaaS server. The modules :mod:`qlmaas.qpus` and :mod:`qlmaas.plugins`
   allow for easily creating remote QPUs and plugins.

   .. toggle-header::
       :header: *Toggle to see the equivalent code on the QLM*

       .. code-block:: python

           from qat.qpus import LinAlg
           from qat.plugins import Nnizer

           qpu = LinAlg()
           plugin = Nnizer()

   .. code-block:: python

      from qlmaas.qpus import LinAlg
      from qlmaas.plugins import Nnizer

      qpu = LinAlg()
      plugin = Nnizer()


.. toggle-header::
   :header: **Getting remote objects with the QLMaaSConnection object**

   This "import" is done with the QLMaaSConnection :func:`~qat.qlmaas.QLMaaSConnection.get_qpu` and
   :func:`~qat.qlmaas.QLMaaSConnection.get_plugin` methods.
   As an example, the following code would create a remote QPU for LinAlg and a remote plugin for Nnizer:

   .. toggle-header::
       :header: *Toggle to see the equivalent code on the QLM*

       .. code-block:: python

           from qat.qpus import LinAlg
           from qat.plugins import Nnizer

           qpu = LinAlg()
           plugin = Nnizer()

   .. code-block:: python

       from qat.qlmaas.connection import QLMaaSConnection

       # importing a remote QPU and a remote plugin
       connection = QLMaaSConnection()
       LinAlg = connection.get_qpu("qat.qpus:LinAlg")
       Nnizer = connection.get_plugin("qat.plugins:Nnizer")

       # the remote QPU and plugin can then be instanciated in the usual way
       qpu = LinAlg()
       plugin = Nnizer()


|  


Submitting a job to a remote QPU
--------------------------------

A job can be submitted to a remote QPU by using a remote QPU's :func:`~qat.qlmaas.qpus.QLMaaSQPU.submit` method.
This method is asynchronous, meaning that its use is different from the submit method used directly on the QLM.
See :ref:`next section <getting_a_result>` for retrieving the result of a simulation.
Here is an example of job submission to a remote LinAlg QPU:


.. toggle-header::
    :header: *Toggle to see the equivalent code on the QLM*

    .. code-block:: python

        from qat.lang.AQASM import Program, H, CNOT

        qprog = Program()
        qbits = qprog.qalloc(2)
        H(qbits[0])
        CNOT(qbits[0], qbits[1])
        circuit = qprog.to_circ()

        job = circuit.to_job()

        from qat.qpus import LinAlg

        qpu = LinAlg()

        # this is not strictly equivalent, since the QLM's QPU submit method is synchronous
        # while the QLMaaSQPU submit method is asynchronous
        qpu.submit(job)


.. code-block:: python

    # creating a circuit and its corresponding job by using qat.lang
    from qat.lang.AQASM import Program, H, CNOT

    qprog = Program()
    qbits = qprog.qalloc(2)
    H(qbits[0])
    CNOT(qbits[0], qbits[1])
    circuit = qprog.to_circ()

    job = circuit.to_job()

    # creating a remote QPU - use of module 'qlmaas'
    from qlmaas.qpus import LinAlg

    # submitting the job
    asynchronous_result = qpu.submit(job)


.. _getting_a_result:

Getting the result of a job
---------------------------

There are a number of ways of obtaining the result of a job previously submited to a remote QLM.
Using one method or another depends on your workflow.

.. toggle-header::
   :header: **Getting the result of a job with its AsyncResult object**

   As seen above, the :func:`~qat.qlmaas.qpus.QLMaaSQPU.submit` method returns a :class:`~qat.qlmaas.result.AsyncResult`
   object (and so does the :func:`~qat.qlmaas.plugins.QLMaaSPlugin.compile` method).

   This object can then be used to check the status of the corresponding job with its
   :func:`~qat.qlmaas.result.AsyncResult.get_status` method, and get its result when it is available by using either
   :func:`~qat.qlmaas.result.AsyncResult.get_result` or :func:`~qat.qlmaas.result.AsyncResult.join`.

   .. code-block:: python

       # check the status of a job
       status = asynchronous_result.get_status()

       # returns its result if the job is finished
       result = asynchronous_result.get_result()

       # for waiting until the job is finished and then get the result
       result = asynchronous_result.join()

.. toggle-header::
   :header: **Getting the result with the qlmaas module (requires a configuration file)**

   If a configuration file is set, myQLM is able to automatically connect
   to the QLMaaS server. The module :mod:`qlmaas.jobs` will contains all
   the job submitted by a user (except the job having a status `DELETED`).

   .. code-block:: python

       from qlmaas.jobs import Job17

       # Check the status of the job
       status = Job17.get_status()

       # Get the result
       result = Job17.get_result()

.. toggle-header::
   :header: **Getting the result of a job with its job_id**

   Another way to interact with a submitted job is by using its *job_id*.
   This *job_id* can be obtained in various way; it is printed to the standard output when using the submit method, but it
   also is a field from :class:`~qat.qlmaas.result.AsyncResult`.

   The *job_id* can be used to get the result of your job later, as long as you have a QLMaaSConnection object to the same
   QLMaaS server:

   .. code-block:: python

       from qat.qlmaas.connection import QLMaaSConnection

       # recreating a connection to the server
       connection = QLMaaSConnection()

       # let us say that our job_id was Job17
       JOB_ID = "Job17"

       # check the status of the job
       status = connection.get_status(JOB_ID)

       # get the result of the job
       result = connection.get_result(JOB_ID)

|  

Building a custom execution stack
---------------------------------

The QLM syntax of using plugins and QPUs to build execution stacks is reproduced on QLMaaS.
Building a remote stack by using QLMaaS would therefore look like that:

.. toggle-header::
    :header: *Toggle to see the equivalent code on the QLM*

    .. code-block:: python

        from qat.plugins import Plugin1, Plugin2, ..., PluginN
        from qat.qpus import QPU

        stack = Plugin1() | Plugin2() | ... | PluginN() | QPU()

.. code-block:: python

    # simple syntax using a configuration file
    from qlmaas.plugins import Plugin1, Plugin2, ..., PluginN
    from qlmaas.qpus import QPU

    # the remote qpu and plugins are stacked and instanciated
    stack = Plugin1() | Plugin2() | ... | PluginN() | QPU()


Such remote stack can then be used to submit jobs as with a remote qpu.
This time, let us retrieve the result by using the job_id.

.. toggle-header::
    :header: *Toggle to see the equivalent code on the QLM*

    .. code-block:: python

        result = stack.submit(batch)

.. code-block:: python

    # submit the stack
    asynchronous_result = stack.submit(batch)

    # get the result
    result = asynchronous_result.get_result()


Compiling a quantum circuit
---------------------------

As on the QLM, a quantum circuit can be compiled with a plugin.
This can be done with a remote plugin's :func:`~qat.qlmaas.plugins.QLMaaSPlugin.compile` method.
Let us take the example of an Nnizer.

.. toggle-header::
    :header: *Toggle to see the equivalent code on the QLM*

    .. code-block:: python

        from qat.plugins import Nnizer
        nnizer = Nnizer()

        from qat.core import HardwareSpecs, Topology, TopologyType
        specs = HardwareSpecs(topology=Topology(type=TopologyType.LNN))

        new_batch = nnizer.compile(batch, specs)

.. code-block:: python

    # get the remote Nnizer (simple syntax using a configuration file)
    from qlmaas.plugins import Nnizer
    nnizer = Nnizer()

    # define a limited LNN connectivity by using the qat.core library
    from qat.core import HardwareSpecs, Topology, TopologyType
    specs = HardwareSpecs(topology=Topology(type=TopologyType.LNN))

    # a batch of jobs can then be compiled remotely
    asynchronous_batch = nnizer.compile(batch, specs)
    new_batch = asynchronous_batch.join()

    # bonus: the QLMaaS syntax allows for compiling Job objects as well as Batch objects
    asynchronous_job = nnizer.compile(job, specs)
    new_job = asynchronous_job.join()
