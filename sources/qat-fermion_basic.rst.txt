.. _qat-fermion_basic_usage:

Basic usage
###########

We will describe here the basic usage of the :mod:`qat.fermion` module.

.. contents:: Table of Contents
   :depth: 2
   :local:
   :backlinks: none

.. _qat-fermion_hamiltonian:

Defining a Hamiltonian
**********************

Many problems in physics are defined by their Hamiltonian. The basic object we will manipulate is the :class:`~qat.fermion.hamiltonians.Hamiltonian`.
The :class:`~qat.fermion.hamiltonians.Hamiltonian` class can be seen as an :class:`~qat.core.Observable` constructor, of which it inherits,
while containing additional methods.
It can be defined using spin or fermionic operators.

Spin Hamiltonians
=================

For example, the **spin Hamiltonian** acting on 2 qubits :math:`0` and :math:`1` defined by :math:`H = 0.3 X_{0} - 0.4 Z_{1}Y_{1}` can be written:

.. run-block:: python

    from qat.core import Term
    from qat.fermion.hamiltonians import Hamiltonian

    # Define the number of qubits
    nqbits = 2

    # Define the Hamiltonian
    H = Hamiltonian(nqbits, [Term(0.3, "X", [0]), Term(-0.4, "ZY", [0, 1])])

>>> print(f"H is in {H.htype.name} representation.")
H is in SPIN representation.

Fermionic Hamiltonians
======================

If we consider now a **fermionic Hamiltonian** :math:`H = 0.3 (C^{\dagger}_{0}C_{1} + C^{\dagger}_{1}C_{0}) + 1.4 C^{\dagger}_{0}C_{1}C^{\dagger}_{1}C_{0}`, we
should write:

.. run-block:: python

    from qat.core import Term
    from qat.fermion.hamiltonians import Hamiltonian

    # Define the number of qubits
    nqbits = 2

    # Define the Hamiltonian
    H = Hamiltonian(nqbits, [Term(0.3, "Cc", [0, 1]), Term(0.3, "Cc", [1, 0]), Term(1.4, "CcCc", [0, 1, 1, 0])])

>>> print(f"H is in {H.htype.name} representation.")
H is in FERMION representation.

.. _qat-fermion_electronicstructurehamiltonian:

Fermionic Hamiltonian using one and two-electrons integrals
===========================================================

In chemistry, problems are often more easily described using interaction terms instead of fermionic operators.

The electronic-structure Hamiltonian is defined by:

.. math::

    H = \sum_{pq} h_{pq}a_p^\dagger a_q + \frac{1}{2} \sum_{pqrs} h_{pqrs}a_p^\dagger a_q^\dagger a_r a_s + r \mathbb{I}

The definition of this Hamiltonian is done via the :class:`~qat.fermion.hamiltonians.ElectronicStructureHamiltonian` class, which
accepts the one and two-body terms :math:`h_{pq}` and :math:`h_{pqrs}` as inputs.

.. run-block:: python

    import numpy as np
    from qat.fermion import ElectronicStructureHamiltonian

    # Define the interaction integrals
    h_pq = 0.2 * np.array([[0, 1], [1, 0]])

    h_pqrs = np.zeros((2, 2, 2, 2))
    h_pqrs[0, 1, 1, 0] = 0.7
    h_pqrs[1, 0, 0, 1] = 0.7

    # Define the ElectronicStructureHamiltonian
    H_elec = ElectronicStructureHamiltonian(h_pq, h_pqrs, -6)

>>> print(f"H_elec is in {H_elec.htype.name} representation.")
H_elec is in FERMION representation.

The :class:`~qat.fermion.hamiltonians.ElectronicStructureHamiltonian` inherits from the
:class:`~qat.fermion.hamiltonians.Hamiltonian` class, and thus contains every method implemented in :class:`~qat.fermion.hamiltonians.Hamiltonian`.

.. note::

    An alternative definition for the electronic-structure Hamiltonian is :

    .. math::

        H = \sum_{uv\sigma} I_{uv}c^{\dagger}_{u\sigma}c_{v\sigma} + \frac{1}{2}\sum_{uvwx}\sum_{\sigma \sigma'} I_{uvwx}c^{\dagger}_{u\sigma}c^{\dagger}_{v\sigma'}c_{k\sigma'}c_{l\sigma} + r\mathbb{I}

    Should you need to define an :class:`~qat.fermion.hamiltonians.ElectronicStructureHamiltonian` using the one- and two-body integrals :math:`I_{uv}` and :math:`I_{uvwx}`, you have two options:

        * convert the :math:`I_{uv},I_{uvwx}` to :math:`h_{pq},h_{pqrs}` using the :func:`qat.fermion.chemistry.ucc.convert_to_h_integrals` and define the :class:`~qat.fermion.hamiltonians.ElectronicStructureHamiltonian` using :math:`h_{pq},h_{pqrs}`;
        * define a :class:`~qat.fermion.chemistry.wrapper.MolecularHamiltonian` using :math:`I_{uv},I_{uvwx}` and extract the :class:`~qat.fermion.hamiltonians.ElectronicStructureHamiltonian` using its :meth:`~qat.fermion.chemistry.wrapper.MolecularHamiltonian.get_electronic_hamiltonian` method.
    
    For more information on this type of body integrals, see :class:`~qat.fermion.chemistry.wrapper.MolecularHamiltonian` documentation.

You can also consult the Jupyter notebook on :notebook:`(spin-fermion transforms)[qat_fermion_spin_fermion_transforms.ipynb]`.

.. _qat-fermion_get_matrix:

The :meth:`~qat.fermion.hamiltonians.Hamiltonian.get_matrix` method
===================================================================

The :class:`~qat.fermion.hamiltonians.Hamiltonian` class allows for the direct usage of the underlying Hamiltonian matrix. Bare in
mind that this method should not be used for big Hamiltonians, as the memory cost might be too much to handle on your machine.
You can access the Hamiltonian matrix by using the :meth:`~qat.fermion.hamiltonians.Hamiltonian.get_matrix` method.

.. run-block:: python

    from qat.core import Term
    from qat.fermion import Hamiltonian

    H = Hamiltonian(2, [Term(0.5, "Y", [0]), Term(0.5, "Y", [1])])

>>> print(H.get_matrix())
array([[0.+0.j , 0.-0.5j, 0.-0.5j, 0.+0.j ],
       [0.+0.5j, 0.+0.j , 0.+0.j , 0.-0.5j],
       [0.+0.5j, 0.+0.j , 0.+0.j , 0.-0.5j],
       [0.+0.j , 0.+0.5j, 0.+0.5j, 0.+0.j ]])

.. _qat-fermion_transforms:

Fermionic to spin representation
********************************

A problem formulated in fermionic representation often needs to be converted to a spin representation, so that it can be handled by
a quantum computer. To do so, one can use the :meth:`~qat.fermion.hamiltonians.Hamiltonian.to_spin` method.

Three transforms are available:

     * the Jordan-Wigner transform (default),
     * the Bravyi-Kitaev transform,
     * the parity method.

Example:
--------

Let us transform the previous :class:`~qat.fermion.hamiltonians.ElectronicStructureHamiltonian` to a spin Hamiltonian:

.. run-block:: python

    import numpy as np
    from qat.fermion import ElectronicStructureHamiltonian

    # Define the fermionic Hamiltonian
    h_pq = 0.2 * np.array([[0, 1], [1, 0]])
    h_pqrs = np.zeros((2, 2, 2, 2))
    h_pqrs[0, 1, 1, 0] = 0.7
    h_pqrs[1, 0, 0, 1] = 0.7

    # Define the Hamiltonian
    H_fermion = ElectronicStructureHamiltonian(h_pq, h_pqrs, -6)

    # Transform it to a spin Hamiltonian using Bravyi-Kitaev transform
    H_spin = H_fermion.to_spin(method="bravyi-kitaev")

    # Similarly, we could have used "jordan-wigner" or "parity"

>>> print(f"H_spin is in {H_spin.htype.name} representation.")
H_spin is in SPIN representation.

More information about the transforms is available below:

    * :ref:`Jordan-Wigner transform <qat-fermion_source_transforms_jw>`
    * :ref:`Bravyi-Kitaev transform <qat-fermion_source_transforms_bk>`
    * :ref:`Parity basis transform <qat-fermion_source_transforms_parity>`

.. _qat-fermion_hamiltonian_constructors:

Some Hamiltonian constructors
*****************************

The Hubbard model or the Anderson model are very widely used. For that reason, we included several :class:`~qat.fermion.hamiltonians.Hamiltonian`
constructors to help you define the system you are interested in more easily.

Here is a list of the different models currently implemented:

* :ref:`Hubbard Hamiltonian: the toy-model of strong correlations <qat-fermion_source_hamiltonians_constructors_hubbard>`
* :ref:`Single-impurity Anderson Model: describes one correlated site embedded in a fermionic bath <qat-fermion_source_hamiltonians_constructors_anderson>`
* :ref:`Embedded Hamiltonian: describes a cell of N correlated sites embedded in a N-level fermionic bath <qat-fermion_source_hamiltonians_constructors_embedded>`


