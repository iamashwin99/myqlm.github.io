.. _combinatorial_optimization:

Combinatorial optimization
==========================

Many real life problems are combinatorial and solving them has actual practical applications. An intrinsic feature of these problems is that they can be formulated as minimization or maximization problems, i.e. with a cost function. At the same time finding the lowest energy of a physical system, represented by a cost Hamiltonian, is also a minimization problem. Due to this intimate relation, problems described with a cost function (:ref:`QUBO <formulating_comb>`) or a cost Hamiltonian (:ref:`Ising <formulating_comb>`) could be solved by simulating the process of finding their minimum energy. This lowest energy should encode the solution to our problem.

.. only:: qlm

    The QLM provides :ref:`helper classes <qubo_and_ising_code>` for both of these formulations, and also the more generic :ref:`Combinatorial Problem <formulating_comb>`, in which one can describe problems with clauses and variables.

    Once the problems are encoded, one can solve them by either a Quantum Approximate Optimization Algorithm (QAOA) or Simulated Quantum Annealing (SQA) as described in the :ref:`Solving combinatorial problems <solving_comb>` section.
    
    Among the many different combinatorial problems, some of the most interesting and challenging ones are the NP-hard problems. A lot of effort has been put over the last 10-15 years into formulating such optimization problems as QUBO/Ising instances. See :cite:`lucas2014ising` for an extensive reference. A direct encoding of some of these problems, described in the :ref:`NP-hard problems <np_problems_formulation>` section, has also been :ref:`implemented <np_hard_problems_code>` on the QLM, along with example :notebook:`(notebooks)[overview_combinatorial_optimization.ipynb]`.

.. only:: myqlm

    myQLM provides :ref:`helper classes <qubo_and_ising_code>` for both of these formulations, and also the more generic :ref:`Combinatorial Problem <formulating_comb>`, in which one can describe problems with clauses and variables.
    
    Once the problems are encoded, one could solve them using a Quantum Approximate Optimization Algorithm (:ref:`QAOA  <solving_comb>`) or Simulated Annealing (:ref:`SA  <solving_comb>`). There are also tools to solve the problems via Simulated Quantum Annealing (:ref:`SQA <solving_comb>`), but they come in the full QLM version.

    Among the many different combinatorial problems, some of the most interesting and challenging ones are the NP-hard problems. A lot of effort has been put over the last 10-15 years into formulating such optimization problems as QUBO/Ising instances. See :cite:`lucas2014ising`  for an extensive reference. A direct encoding of some of these problems, described in the :ref:`NP-hard problems <np_problems_formulation>` section, has also been :ref:`implemented <np_hard_problems_code>` on myQLM, along with example :notebook:`(notebooks)[overview_combinatorial_optimization_myqlm.ipynb]`.

.. _formulating_comb:

Formulating combinatorial problems
----------------------------------

.. only:: qlm

    This section presents definitions of Ising Hamiltonians and QUBO cost functions, along with our conventions regarding their precise formulation (see also this :notebook:`(introductory notebook)[introduction_combinatorial_optimization.ipynb]`).

.. only:: myqlm

    This section presents definitions of Ising Hamiltonians and QUBO cost functions, along with our conventions regarding their precise formulation (see also this :notebook:`(introductory notebook)[introduction_combinatorial_optimization_myqlm.ipynb]`).

.. tab-set::

    .. tab-item:: Ising Hamiltonians

        **Ising Hamiltonians**

        Given :math:`n` qubits, a **2-local Ising Hamiltonian** is an operator of the
        form:

        .. math::

            H = - \sum_{i=1}^{n} h_{i}\sigma_{z}^{i} - \sum_{i,j=1}^{n} J_{ij}\sigma_{z}^{i}\sigma_{z}^{j}

        where :math:`\sigma_{z}^{i} = \begin{pmatrix}1 & 0 \\ 0 & -1 \end{pmatrix}`, 
        :math:`h` is a vector of real coefficients usually referred to as the **local magnetic field**,
        and :math:`J` is a **real symmetric matrix with a zero diagonal**, usually referred to as the **coupling matrix**.

        This Hamiltonian is the direct **quantization** of the following **classical Ising cost
        function**:

        .. math::

            H(s_{1},...,s_{n}) = - \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j}

        where :math:`s_{i}\in \{-1,1\}`.

        .. note::
            In the **interaction term**, we do **not** restrict the sum to, e.g.,
            :math:`i < j`. This is to make the computation of the Ising cost function
            more straightforward to write
            using, for instance, standard numpy functions.

        .. note::
           For clarity and readability, we do not include any **offset constant term**
           in the definitions above. A definition including this term would be: 
           :math:`- \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j} + o`,
           with :math:`o` the offset. Such a term does not change the **optimization landscape**,
           but might be needed if one wants to **match values** when **converting Ising cost functions into
           QUBO instances and vice versa**.

        .. note::
           In the context of Ising Hamiltonians, qubits are also called **spins**.

        Quantum annealing machines are typically designed to try and reach the **minimum energy state
        of Ising Hamiltonians**, also called **ground state**, relying on the **Adiabatic Theorem**.
        See for instance :cite:`albash2018adiabatic` for a general reference on adiabatic quantum computation.

        .. only:: qlm

            Our **classical annealing codes** (see :ref:`Simulated Quantum Annealing (SQA) <solving_comb>`) try and do the same thing: Given :math:`h` and :math:`J` as input, they will, starting from a random configuration,  try to apply **updates**, as part of **Markov chain over the configuration space**, in order to look for **low energy states**, where "energy" is defined by the formulas above.

        .. only:: myqlm

            **Classical annealing codes** like Simulated Quantum Annealing (:ref:`SQA <solving_comb>`) try and do the same thing: Given :math:`h` and :math:`J` as input, they will, starting from a random configuration, try to apply **updates**, as part of **Markov chain over the configuration space**, in order to look for **low energy states**, where "energy" is defined by the formulas above.

        .. note::
           A coupling value :math:`J > 0` between two spins :math:`\sigma_{i}` and 
           :math:`\sigma_{j}` can sometimes be called, in our convention, a **ferromagnetic coupling**,
           as the alignment of the two spins onto a same value will tend to **lower the energy** of the system
           making it closer to its **ground state**.

        .. only:: qlm

            In other words, **quantum annealing machines** and, consequently, **classical annealing codes**, :ref:`SQA <solving_comb>`, aim at tackling the following optimization problem:

        .. only:: myqlm

            In other words, **quantum annealing machines** and, consequently, **classical annealing codes**, :ref:`SA <solving_comb>`, aim at tackling the following optimization problem:

        .. math::

            \min_{s_{1}...s_{n}\in \{-1,1\}} \left(- \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j}\right)

        given :math:`h` and :math:`J` as input.

        To produce such Ising-formulated problems, one can use the :class:`qat.opt.Ising` class. It is also possible to translate it to :class:`qat.opt.QUBO` via :meth:`~qat.opt.Ising.to_qubo` or to :class:`~qat.opt.CombinatorialProblem` via :meth:`~qat.opt.Ising.to_combinatorial_problem`.

    .. tab-item:: QUBO

        **Quadratic Unconstrained Binary Optimization (QUBO)** consists in, given a **real symmetric matrix**
        :math:`Q`, **minimizing** the following cost function :math:`q`:

        .. math::

            q(x_{1},...,x_{n}) = \sum_{i,j=1}^{n} - Q_{ij}x_{i}x_{j}

        where :math:`x_{1},...,x_{n}\in \{0,1\}` are **binary variables**.

        Written differently, by **solving a QUBO problem**, we mean solving, 
        given :math:`Q`:

        .. math::

            \min_{x_{1}...x_{n}\in \{0,1\}} \sum_{i,j=1}^{n} - Q_{ij}x_{i}x_{j}

        .. note::
           The **diagonal** of :math:`Q` is allowed to contain **non-zero elements**.
           Because :math:`\forall i \quad x_{i}\in\{0,1\}`, :math:`x_{i}^{2} = x_{i}`,
           and the diagonal terms in the sum above effectively correspond to a **linear part**
           of the cost function, which can be seen as similar to the **magnetic field terms**
           in **Ising Hamiltonians**.



        **QUBO instances** are in one-to-one correspondance with **Ising Hamiltonians and cost functions**.

        Indeed, starting from the expression above for :math:`q`, the **QUBO cost function**,
        and defining :math:`s_{i}=2x_{i}-1` (:math:`\in \{-1,1\}` as :math:`x_{i}\in\{0,1\}`),
        i.e :math:`x_{i}=\frac{s_{i}+1}{2}`,
        one can indeed write:

        .. math:: 

            q(x_{1},...x_{n}) &= \sum_{i,j=1}^{n} - Q_{i,j} x_{i}x_{j} \\~\\
                              &= - \sum_{i,j=1}^{n} Q_{i,j} \left(\frac{s_{i}+1}{2}\right)\left(\frac{s_{j}+1}{2}\right) \\~\\
                              &= - \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4}\left(1+s_{i}+s_{j}+s_{i}s_{j}\right) \\~\\ 
                              &= - \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} - \sum_{i}\left(\sum_{j}\frac{Q_{i,j}}{4}\right) s_{i} - \sum_{j}\left(\sum_{i}\frac{Q_{i,j}}{4}\right) s_{j} - \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} s_{i}s_{j} \\~\\
                              &= - \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} - \sum_{i=1}^{n} \frac{Q_{i,i}}{4} - \sum_{i}\left(\sum_{j}\frac{Q_{i,j}}{2}\right) s_{i}  - \sum_{i,j | i\neq j}^{n} \frac{Q_{i,j}}{4} s_{i}s_{j} \\~\\
                              &= - \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j} + o

        with :math:`h_{i}=\sum_{j}\frac{Q_{i,j}}{2}`, :math:`J_{ij}=\frac{Q_{i,j}}{4}` 
        and an **offset term** :math:`o=- \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} - \sum_{i=1}^{n} \frac{Q_{i,i}}{4}`.

        In this case, :class:`~qat.opt.QUBO` is the representative class and it can be translated to :class:`~qat.opt.Ising` and :class:`~qat.opt.CombinatorialProblem` via the :meth:`~qat.opt.QUBO.to_ising` and :meth:`~qat.opt.QUBO.to_combinatorial_problem`, respectively.

    .. tab-item:: General Combinatorial Problems

        **General Combinatorial Problems**

        The most general way to specify a combinatorial problem is by explicitly declaring boolean variables (:class:`~qat.opt.boolexpr.Var`) and  clauses (:class:`~qat.opt.boolexpr.Clause`) combining these variables. This is achieved via the :class:`qat.opt.CombinatorialProblem` class. 

        While Ising and QUBO only accept up to two-variable terms, one can define clauses in :class:`~qat.opt.CombinatorialProblem` with as many variables as desired. However, for the case of no more than two variables, a translation to the Ising and QUBO formulations is available using the :meth:`~qat.opt.CombinatorialProblem.to_ising` and :meth:`~qat.opt.CombinatorialProblem.to_qubo` methods.

        The cost Hamiltonian extraction is handled by the :class:`~qat.opt.boolexpr.Clause` class such that the final cost Hamiltonian consists of the weighted sum of the cost Hamiltonian of its clauses.

.. _solving_comb:

Solving combinatorial problems
------------------------------

This section describes how to define and solve combinatorial problems using QLM tools.

.. only:: qlm

    .. tab-set::

        .. tab-item:: Quantum Approximate Optimization Algorithm (QAOA)
        
            .. include:: combinatorial_optimization_intro_qaoa.rst

        .. tab-item:: Simulated Quantum Annealing (SQA)

            .. include:: combinatorial_optimization_intro_sqa.rst

        .. tab-item:: Quantum Annealing (QA)

            .. include:: combinatorial_optimization_intro_qa.rst

.. only:: myqlm

    .. tab-set::

        .. tab-item:: Quantum Approximate Optimization Algorithm (QAOA)
        
            .. include:: combinatorial_optimization_intro_qaoa.rst

        .. tab-item:: Simulated Annealing (SA)

            .. include:: combinatorial_optimization_intro_sa.rst

        .. tab-item:: Simulated Quantum Annealing (SQA)

            .. include:: combinatorial_optimization_intro_sqa.rst

        .. tab-item:: Quantum Annealing (QA)

            .. include:: combinatorial_optimization_intro_qa.rst

Bibliography
------------

.. bibliography:: biblio.bib
