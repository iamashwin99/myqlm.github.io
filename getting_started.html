<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Getting started &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="static/contentui.css" type="text/css" />
      <link rel="stylesheet" href="static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
    <link rel="shortcut icon" href="static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="static/doctools.js"></script>
        <script src="static/sphinx_highlight.js"></script>
        <script src="static/contentui.js"></script>
        <script src="static/design-tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Writing quantum circuits" href="programming.html" />
    <link rel="prev" title="myQLM license" href="myqlm_specific/license.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> myQLM documentation
            <img src="static/myqlm.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                myQLM-1.7.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/install.html">Installing myQLM</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorial_optimization_intro.html">Combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">List of notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Main objects: Jobs, Observables, Circuits…</a></li>
<li class="toctree-l1"><a class="reference internal" href="manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch_generators.html">Building advanced computation stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="qat-fermion.html">Digital quantum simulation for spin and fermionic systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Command-line tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source code documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="source_doc.html">Source code documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/contrib.html">Contributing to myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/release-note.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Getting started</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="getting-started">
<span id="id1"></span><h1>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this heading"></a></h1>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-0" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-0">
QLM Hello world</label><div class="sd-tab-content docutils">
<p>The following code snippet creates and simulates a simple Bell pair circuit:</p>
<figure class="align-default">
<a class="reference internal image-reference" href="images/bell_pair.png"><img alt="images/bell_pair.png" src="images/bell_pair.png" style="width: 153.0px; height: 76.0px;" /></a>
</figure>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">CNOT</span>

<span class="c1"># Create a Program</span>
<span class="n">qprog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="c1"># Number of qbits</span>
<span class="n">nbqbits</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># Allocate some qbits</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="n">nbqbits</span><span class="p">)</span>

<span class="c1"># Apply some quantum Gates</span>
<span class="n">H</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qbits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Export this program into a quantum circuit</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Import a Quantum Processor Unit Factory (the default one)</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>

<span class="c1"># Create a Quantum Processor Unit</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>

<span class="c1"># Create a job</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">to_job</span><span class="p">()</span>

<span class="c1"># Submit the job to the QPU</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">qpu</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

<span class="c1"># Iterate over the final state vector to get all final components</span>
<span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;State </span><span class="si">%s</span><span class="s2"> amplitude </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">amplitude</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">State</span> <span class="o">|</span><span class="mi">00</span><span class="o">&gt;</span> <span class="n">amplitude</span> <span class="p">(</span><span class="mf">0.7071067811865475</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
<span class="n">State</span> <span class="o">|</span><span class="mi">11</span><span class="o">&gt;</span> <span class="n">amplitude</span> <span class="p">(</span><span class="mf">0.7071067811865475</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>The first few lines of code are dedicated to the generation of a quantum circuit and a job, an atomic computation task in the QLM language. A detailed description of the quantum circuit generation tools can be found in the <a class="reference internal" href="programming.html#programming"><span class="std std-ref">programming section</span></a>.</p>
<p>Then the remaining lines instantiate a simulator, submit the job, and print the simulation results. More information about this process can be found in the <a class="reference internal" href="simulating.html#simulating"><span class="std std-ref">simulating section</span></a>.</p>
<p>QLM also comes with a collection of powerful tools, called Plugins, to manipulate quantum circuits and execution results. Information about these tools can be found in the <a class="reference internal" href="manipulating.html#manipulating"><span class="std std-ref">manipulating section</span></a>.</p>
<p>Finally, the QLM provides powerful simulators, called Quantum Processing Units (QPUs). The example above used the default one. You will find more information about QPUs <a class="reference internal" href="source_doc.html#qpus"><span class="std std-ref">here</span></a>.</p>
<p>The rest of this section is dedicated to some basic examples of quantum algorithms from the standard literature (such as Grover and a variational algorithm).</p>
</div>
<input id="sd-tab-item-1" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-1">
A simple Grover</label><div class="sd-tab-content docutils">
<p>Let’s write a simple Grover algorithm. Grover is a quantum search algorithm that can find an element in an unstructured search space quadratically faster than a randomized classical algorithm. In this search model, the problem is specified by an <strong>oracle</strong>, i.e a function <span class="math notranslate nohighlight">\(\mathcal{X}\rightarrow \{0, 1\}\)</span>, and we are looking for an element <span class="math notranslate nohighlight">\(x \in \mathcal{X}\)</span> such that <span class="math notranslate nohighlight">\(f(x) = 1\)</span>.</p>
<p>The algorithm consists in alternating two operations <span class="math notranslate nohighlight">\(\pi \sqrt{\frac{1}{a}}/4\)</span> times where <span class="math notranslate nohighlight">\(a = \frac{|f^{-1}(\{1\})|}{|\mathcal{X}|}\)</span> is the probability of finding the searched element in the uniform distribution.</p>
<p>These operations are:</p>
<blockquote>
<div><ul class="simple">
<li><p>an oracle <span class="math notranslate nohighlight">\(U_f: |x \rangle \mapsto (-1)^{f(x)}|x\rangle\)</span></p></li>
<li><p>a diffusion <span class="math notranslate nohighlight">\(U_D = I - 2|s\rangle\langle s|\)</span> where <span class="math notranslate nohighlight">\(|s\rangle = \frac{1}{\sqrt{|\mathcal{X}|}} \sum_{x\in\mathcal{X}} |x\rangle\)</span></p></li>
</ul>
</div></blockquote>
<p>Let’s dive in the details of their implementation for a simple search!</p>
<p><strong>The diffusion</strong></p>
<p>To keep things simple we will consider the following search space: <span class="math notranslate nohighlight">\(\mathcal{X} = \{0, 1\}^{2k}\)</span>.
In this setting, a diffusion can be implemented as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>First, we will put all qubits in the diagonal basis by applying a wall of H gates.</p></li>
<li><p>We can then flip the amplitude of the <span class="math notranslate nohighlight">\(|0..0\rangle\)</span> state by flipping all qubits using a wall of <span class="math notranslate nohighlight">\(X\)</span> gates and applying a controlled <span class="math notranslate nohighlight">\(Z\)</span> gate on all qubits.</p></li>
<li><p>Finally, we can undo our basis changes by applying a wall of <span class="math notranslate nohighlight">\(X\)</span> followed by a wall of <span class="math notranslate nohighlight">\(H\)</span></p></li>
</ul>
<p>We will write a python function that given a number <span class="math notranslate nohighlight">\(k\)</span> returns a diffusion routine over <span class="math notranslate nohighlight">\(2k\)</span> qubits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># everything we need to write a quantum circuit</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c1"># a default qpu (here a simulator)</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>

<span class="c1"># This is a standard implementation of Grover&#39;s diffusion</span>
<span class="k">def</span> <span class="nf">diffusion</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
     <span class="n">routine</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
     <span class="n">wires</span> <span class="o">=</span> <span class="n">routine</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
     <span class="k">for</span> <span class="n">wire</span> <span class="ow">in</span> <span class="n">wires</span><span class="p">:</span>
         <span class="n">H</span><span class="p">(</span><span class="n">wire</span><span class="p">)</span>
         <span class="n">X</span><span class="p">(</span><span class="n">wire</span><span class="p">)</span>
     <span class="n">Z</span><span class="o">.</span><span class="n">ctrl</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)(</span><span class="n">wires</span><span class="p">)</span>
     <span class="k">for</span> <span class="n">wire</span> <span class="ow">in</span> <span class="n">wires</span><span class="p">:</span>
         <span class="n">X</span><span class="p">(</span><span class="n">wire</span><span class="p">)</span>
         <span class="n">H</span><span class="p">(</span><span class="n">wire</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">routine</span>
</pre></div>
</div>
</div></blockquote>
<p>As you can see, we repeat a lot of code to do basis change and revert them. We can simplify a bit the code by using a compute/uncompute:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">diffusion</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
     <span class="n">routine</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
     <span class="n">wires</span> <span class="o">=</span> <span class="n">routine</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
     <span class="k">with</span> <span class="n">routine</span><span class="o">.</span><span class="n">compute</span><span class="p">():</span>
         <span class="k">for</span> <span class="n">wire</span> <span class="ow">in</span> <span class="n">wires</span><span class="p">:</span>
             <span class="n">H</span><span class="p">(</span><span class="n">wire</span><span class="p">)</span>
             <span class="n">X</span><span class="p">(</span><span class="n">wire</span><span class="p">)</span>
     <span class="n">Z</span><span class="o">.</span><span class="n">ctrl</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)(</span><span class="n">wires</span><span class="p">)</span>
     <span class="n">routine</span><span class="o">.</span><span class="n">uncompute</span><span class="p">()</span>
     <span class="k">return</span> <span class="n">routine</span>
</pre></div>
</div>
</div></blockquote>
<p>This is a bit clearer now: We have our walls of <span class="math notranslate nohighlight">\(H\)</span> and <span class="math notranslate nohighlight">\(X\)</span> gates, our controlled <span class="math notranslate nohighlight">\(Z\)</span> gate, and we undo our walls using the uncomputation.</p>
<p><strong>The oracle</strong></p>
<p>In this space, we will look for palindromes: bit strings that are their own mirrors.
We will implement our oracle as follows (remember that we need to flip the sign of the amplitude of all palindromes):</p>
<blockquote>
<div><ul class="simple">
<li><p>First we will compute the xor of <span class="math notranslate nohighlight">\(b_1\)</span> and <span class="math notranslate nohighlight">\(b_{2k}\)</span>, <span class="math notranslate nohighlight">\(b_2\)</span> and <span class="math notranslate nohighlight">\(b_{2k-1}\)</span>, etc. We will do these operations in place in the second half of the bit string.</p></li>
<li><p>Then we will flip the amplitude of our state if and only if its second half is <span class="math notranslate nohighlight">\(0...0\)</span>. To do so, we will flip all bits in the second half (using <span class="math notranslate nohighlight">\(X\)</span> gates) and perform a controlled <span class="math notranslate nohighlight">\(Z\)</span> gate on the second half, thus flipping the amplitude if and only if all qubits are set to <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p>Finally, we can revert to the original state by uncomputing the bit flips and xors (once again we will use a compute/uncompute block)</p></li>
</ul>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="n">routine</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
    <span class="n">first_half</span> <span class="o">=</span> <span class="n">routine</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">second_half</span> <span class="o">=</span> <span class="n">routine</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">routine</span><span class="o">.</span><span class="n">compute</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">first_half</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">second_half</span><span class="p">)):</span>
            <span class="n">CNOT</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w2</span> <span class="ow">in</span> <span class="n">second_half</span><span class="p">:</span>
            <span class="n">X</span><span class="p">(</span><span class="n">w2</span><span class="p">)</span>
    <span class="n">Z</span><span class="o">.</span><span class="n">ctrl</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)(</span><span class="n">second_half</span><span class="p">)</span>
    <span class="n">routine</span><span class="o">.</span><span class="n">uncompute</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">routine</span>
</pre></div>
</div>
<p>And this is it. We can now run a Grover algorithm to find palindromes!
There are exactly <span class="math notranslate nohighlight">\(2^k\)</span> palindromes over <span class="math notranslate nohighlight">\(2k\)</span> bits, hence we will need to perform <span class="math notranslate nohighlight">\(\approx \pi\sqrt{2^k}/4\)</span> iterations to find a palindrome with good probability.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">grover</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">grover</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">diffusion</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">oracle</span> <span class="o">=</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

<span class="c1"># We start by a uniform superposition of bit strings:</span>
<span class="k">for</span> <span class="n">qbit</span> <span class="ow">in</span> <span class="n">qbits</span><span class="p">:</span>
    <span class="n">H</span><span class="p">(</span><span class="n">qbit</span><span class="p">)</span>

<span class="n">nsteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsteps</span><span class="p">):</span>
    <span class="n">oracle</span><span class="p">(</span><span class="n">qbits</span><span class="p">)</span>
    <span class="n">diff</span><span class="p">(</span><span class="n">qbits</span><span class="p">)</span>

<span class="c1"># Build a circuit</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">grover</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Build a job</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">to_job</span><span class="p">()</span>

<span class="c1"># Evaluate the job and print the output probabilities</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
<span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">probability</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="mi">0000</span><span class="o">&gt;</span> <span class="mf">0.24999999999999956</span>
<span class="o">|</span><span class="mi">0110</span><span class="o">&gt;</span> <span class="mf">0.24999999999999956</span>
<span class="o">|</span><span class="mi">1001</span><span class="o">&gt;</span> <span class="mf">0.24999999999999956</span>
<span class="o">|</span><span class="mi">1111</span><span class="o">&gt;</span> <span class="mf">0.24999999999999956</span>
</pre></div>
</div>
<p>As you can see, all the bit strings we can sample (with decently high  probability) are palindromes!</p>
<p>Of course, this example is not particularly helpful to solve practical problems, but the QLM comes with high
level constructs that can help you write more advanced oracles.
If you are curious, you can have a look at <span class="xref std std-ref">this section</span> of the documentation to see how to write complicated oracles relying on custom data structures.</p>
</div>
<input id="sd-tab-item-2" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-2">
A simple variational algorithm</label><div class="sd-tab-content docutils">
<p>Variational algorithms are believed to be well suited to Noisy, Intermediate-Scale Quantum (NISQ) processors as they do not necessarily require long circuits to nevertheless
prepare powerful ansatz states.</p>
<p>In the code snippet below, we illustrate how the QLM can be used to write such variational algorithms in a few lines of code: we first define the Hamiltonian
<span class="math notranslate nohighlight">\(H\)</span> (here the antiferromagnetic Heisenberg Hamiltonian) whose ground-state energy we want to approximate. We then define the ansatz circuit,
i.e a parametric circuit with parameters <span class="math notranslate nohighlight">\(\theta_i\)</span> to be optimized. Finally, our quantum stack is composed of a QPU (here a simulator) and a
so-called “plugin” that is going to perform the iterative optimization of the parameters given the ansatz circuit and the observable to be minimized.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">RY</span><span class="p">,</span> <span class="n">CNOT</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>
<span class="kn">from</span> <span class="nn">qat.plugins</span> <span class="kn">import</span> <span class="n">ScipyMinimizePlugin</span>

<span class="c1"># we instantiate the Hamiltonian we want to approximate the ground state energy of</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">Observable</span><span class="p">(</span><span class="n">nqbits</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pauli_terms</span><span class="o">=</span><span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">,</span> <span class="s2">&quot;ZZ&quot;</span><span class="p">]])</span>

<span class="c1"># we construct the variational circuit (ansatz)</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">reg</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">theta_</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">RY</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">RY</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">])(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># construct a (variational) job with the variational circuit and the observable</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">observable</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">)</span>

<span class="c1"># we now build a stack that can handle variational jobs</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>
<span class="n">optimizer_scipy</span> <span class="o">=</span> <span class="n">ScipyMinimizePlugin</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;COBYLA&quot;</span><span class="p">,</span>
                                      <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                                      <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">200</span><span class="p">},</span>
                                      <span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">optimizer_scipy</span> <span class="o">|</span> <span class="n">qpu</span>

<span class="c1"># we submit the job and print the optimized variational energy (the exact GS energy is -3)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minimum VQE energy =</span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Minimum</span> <span class="n">VQE</span> <span class="n">energy</span> <span class="o">=-</span><span class="mf">2.9999999999985336</span>
</pre></div>
</div>
<p>You can learn more about QLM jobs, observables, circuits <a class="reference internal" href="simulating.html#simulating"><span class="std std-ref">here</span></a> and <a class="reference internal" href="introduction.html#introduction"><span class="std std-ref">there</span></a>.
You can learn more about parametric circuits and variational plugins <a class="reference internal" href="running_variational.html#variational"><span class="std std-ref">here</span></a>.</p>
</div>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="myqlm_specific/license.html" class="btn btn-neutral float-left" title="myQLM license" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="programming.html" class="btn btn-neutral float-right" title="Writing quantum circuits" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Atos 2016-2022.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>