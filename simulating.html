<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Executing quantum circuits &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="static/contentui.css" type="text/css" />
      <link rel="stylesheet" href="static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
    <link rel="shortcut icon" href="static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="static/doctools.js"></script>
        <script src="static/sphinx_highlight.js"></script>
        <script src="static/contentui.js"></script>
        <script src="static/design-tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Running variational algorithms" href="running_variational.html" />
    <link rel="prev" title="Writing quantum circuits" href="programming.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> myQLM documentation
            <img src="static/myqlm.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                myQLM-1.7.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Executing quantum circuits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#describing-a-quantum-job">Describing a quantum job</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-full-example-on-the-bell-state-circuit">A full example on the Bell state circuit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sample-mode">SAMPLE mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#infinite-number-of-shots-all-qubits">Infinite number of shots, all qubits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#finite-number-of-shots-all-qubits">Finite number of shots, all qubits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#infinite-number-of-shots-only-one-qubit">Infinite number of shots, only one qubit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#observable-mode">OBSERVABLE mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#infinite-number-of-shots">Infinite number of shots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#finite-number-of-shots">Finite number of shots</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#further-information">Further information</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorial_optimization_intro.html">Combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">List of notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Main objects: Jobs, Observables, Circuits…</a></li>
<li class="toctree-l1"><a class="reference internal" href="manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch_generators.html">Building advanced computation stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="qat-fermion.html">Digital quantum simulation for spin and fermionic systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Command-line tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source code documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="source_doc.html">Source code documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/contrib.html">Contributing to myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/release-note.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Executing quantum circuits</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="executing-quantum-circuits">
<span id="simulating"></span><h1>Executing quantum circuits<a class="headerlink" href="#executing-quantum-circuits" title="Permalink to this heading"></a></h1>
<p>The workflow of a quantum computer, henceforth called a <strong>“Quantum Processing Unit” (QPU)</strong>, is the following:
its state (register of qubits) is initialized,
a series of quantum gates (a quantum circuit <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>) is operated on the register,
and a measurement is made on the final state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> of the QPU.</p>
<p>QLM provides classical emulators of QPUs that allow to simulate the execution of this workflow.</p>
<p>In this page, you will learn how to use the various objects required to describe this workflow and to
run a QLM QPU.</p>
<section id="describing-a-quantum-job">
<h2>Describing a quantum job<a class="headerlink" href="#describing-a-quantum-job" title="Permalink to this heading"></a></h2>
<p>The computational jobs that are fed to a QPU primarily consist of two main components:</p>
<ul class="simple">
<li><p>the <strong>quantum circuit</strong> to be executed on the qubit register. You have learned how to create such a circuit <a class="reference internal" href="programming.html#programming"><span class="std std-ref">here</span></a>.</p></li>
<li><p>the <strong>final measurement</strong> to be carried out on the final state of the register, i.e on the wavefunction <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> that has been prepared by the quantum circuit.</p></li>
</ul>
<p><strong>Two types</strong> of final measurements are commonly used in quantum algorithms:</p>
<ul class="simple">
<li><p>“<strong>Sample</strong>”: Measuring the projection of the wavefunction on the computational basis (formally speaking, this means measuring qubits “along the Z axis”). For instance, if the final state is <span class="math notranslate nohighlight">\(|\psi\rangle=(|00\rangle+|11\rangle)/\sqrt{2}\)</span>, measuring “in the computational basis” will yield the bitstring “00” in 50% (<span class="math notranslate nohighlight">\(1/\sqrt{2}^2\)</span>) of cases, and “11” the rest of the time. Because of the statistical nature of the measurement, many repeated measurements on the computational basis, yielding many different bitstrings or “<strong>samples</strong>”, are necessary to get an accurate estimate of the frequencies of each computational basis state (“00”: 50%, “01”: 0%, “10”: 0%, “11”: 50% in our case). We will call “<strong>nbshots</strong>” the number of such repetitions (with a classical emulator, one can in general emulate an infinite number of shots since one has access to the exact frequencies). Of course, one may decide to measure only a subset of qubits.</p></li>
<li><p>“<strong>Observable</strong>”: Measuring the value of a quantum mechanical <strong>observable</strong> <span class="math notranslate nohighlight">\(O\)</span> in the final state. On average, such a value is given by the formula <span class="math notranslate nohighlight">\(\langle O \rangle = \langle \psi | O |\psi \rangle\)</span>. While this average value can directly be computed using a classical computer, on an actual QPU, only a limited set of observables can be measured. In practice, most QPUs provide only “Z-axis” measurements, i.e, as described above, the possibility to measure the projection of the wavefunction on computational basis states. In order to perform the estimation of the average value of an observable, one thus needs to convert the computation of <span class="math notranslate nohighlight">\(\langle O \rangle\)</span> into a series of Z axis measurements (with possible modifications of the circuit), estimate bitstrings frequencies as described above (with a given number of shots or repetitions), and combine those subresults back into an estimate of <span class="math notranslate nohighlight">\(\langle O \rangle\)</span>.</p></li>
</ul>
<p>Let us emphasize the fact that while the first final processing type is native to most actual QPUs, the same does not necessarily holds
for the “OBSERVABLE” processing type. In the absence of a native support, the <a class="reference internal" href="observable-splitter.html#obs-splitter"><span class="std std-ref">ObservableSplitter</span></a> plugin of the QLM can enhance the QPU with an observable-processing capacity.</p>
<p>In QLM, quantum jobs describing these tasks are implemented by a <a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Job</span></code></a> object, that contains</p>
<ul class="simple">
<li><p>the circuit <span class="math notranslate nohighlight">\(\mathcal{C}\)</span> to be executed</p></li>
<li><p>the type of the final processing (<code class="docutils literal notranslate"><span class="pre">SAMPLE</span></code> or <code class="docutils literal notranslate"><span class="pre">OBS</span></code>), with the necessary parameters (which qubits to be measured or which observable to evaluate, respectively)</p></li>
<li><p>the number of allowed repetitions (shots)</p></li>
</ul>
<p>Note that by default, the processing type is <code class="docutils literal notranslate"><span class="pre">SAMPLE</span></code>, with all qubits being measured, and an infinite number of shots (i.e no statistical uncertainty).</p>
</section>
<section id="a-full-example-on-the-bell-state-circuit">
<h2>A full example on the Bell state circuit<a class="headerlink" href="#a-full-example-on-the-bell-state-circuit" title="Permalink to this heading"></a></h2>
<p>Here, we exemplify the execution of a simple Bell circuit with the different modes described above.</p>
<section id="sample-mode">
<h3>SAMPLE mode<a class="headerlink" href="#sample-mode" title="Permalink to this heading"></a></h3>
<section id="infinite-number-of-shots-all-qubits">
<h4>Infinite number of shots, all qubits<a class="headerlink" href="#infinite-number-of-shots-all-qubits" title="Permalink to this heading"></a></h4>
<p>We take the same example as the one we examined in <a class="reference internal" href="getting_started.html#getting-started"><span class="std std-ref">the Getting Started page</span></a> for an illustration of this case:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">CNOT</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>

<span class="c1"># Create a circuit</span>
<span class="n">qprog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qbits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Create a job</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">to_job</span><span class="p">()</span> <span class="c1"># no parameters, equivalent to &quot;nbshots=0&quot;</span>

<span class="c1"># Instantiate a QPU (simulator)</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>

<span class="c1"># Execute</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">qpu</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
<span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;State </span><span class="si">%s</span><span class="s2">: probability </span><span class="si">%s</span><span class="s2">, amplitude </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">probability</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">amplitude</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">State</span> <span class="o">|</span><span class="mi">00</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">probability</span> <span class="mf">0.4999999999999999</span><span class="p">,</span> <span class="n">amplitude</span> <span class="p">(</span><span class="mf">0.7071067811865475</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
<span class="n">State</span> <span class="o">|</span><span class="mi">11</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">probability</span> <span class="mf">0.4999999999999999</span><span class="p">,</span> <span class="n">amplitude</span> <span class="p">(</span><span class="mf">0.7071067811865475</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>You can notice that a <code class="docutils literal notranslate"><span class="pre">Job</span></code> is created from a circuit using the circuit’s <code class="docutils literal notranslate"><span class="pre">to_job()</span></code> method.
This job is then fed to the QPU’s <code class="docutils literal notranslate"><span class="pre">submit</span></code> method, which returns a <code class="docutils literal notranslate"><span class="pre">result</span></code> object.
In SAMPLE mode, this result can be iterated on, yielding the various “samples”, with each sample
corresponding to a given bitstring (<code class="docutils literal notranslate"><span class="pre">state</span></code>) and its frequency of appearance (<code class="docutils literal notranslate"><span class="pre">probability</span></code>) upon
conducting a Z measurement over the final state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>. States with zero probability
are not listed (one can set a threshold <code class="docutils literal notranslate"><span class="pre">amp_threshold</span></code> to filter out states below a certain probability amplitude).
Here, we also print the probability <em>amplitude</em> (<code class="docutils literal notranslate"><span class="pre">amplitude</span></code>) corresponding to each computational basis state.
Let us stress that this piece of information is in general not available from an actual QPU, but merely
from some classical simulators.</p>
</section>
<section id="finite-number-of-shots-all-qubits">
<h4>Finite number of shots, all qubits<a class="headerlink" href="#finite-number-of-shots-all-qubits" title="Permalink to this heading"></a></h4>
<p>Let us switch to a finite <code class="docutils literal notranslate"><span class="pre">nbshots</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">CNOT</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>

<span class="c1"># Create a circuit</span>
<span class="n">qprog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qbits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Create a job</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">nbshots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="c1"># Execute</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
<span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;State </span><span class="si">%s</span><span class="s2">: probability </span><span class="si">%s</span><span class="s2"> +/- </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">probability</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">err</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">State</span> <span class="o">|</span><span class="mi">00</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">probability</span> <span class="mf">0.49</span> <span class="o">+/-</span> <span class="mf">0.05024183937956914</span>
<span class="n">State</span> <span class="o">|</span><span class="mi">11</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">probability</span> <span class="mf">0.51</span> <span class="o">+/-</span> <span class="mf">0.05024183937956914</span>
</pre></div>
</div>
<p>Notice how the estimated probability of the states differs from the ideal one due to “shot noise”. The <code class="docutils literal notranslate"><span class="pre">err</span></code>
field of the <code class="docutils literal notranslate"><span class="pre">sample</span></code> object contains the standard error of the mean on the frequency of appearance.
It decreases as <span class="math notranslate nohighlight">\(1/\sqrt{n_\mathrm{shots}}\)</span>.</p>
</section>
<section id="infinite-number-of-shots-only-one-qubit">
<h4>Infinite number of shots, only one qubit<a class="headerlink" href="#infinite-number-of-shots-only-one-qubit" title="Permalink to this heading"></a></h4>
<p>Here, we decide to measure only the second qubit:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">CNOT</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>

<span class="c1"># Create a circuit</span>
<span class="n">qprog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qbits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Create a job</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">nbshots</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">qubits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Execute</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
<span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;State </span><span class="si">%s</span><span class="s2">: probability </span><span class="si">%s</span><span class="s2"> +/- </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">probability</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">err</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">State</span> <span class="o">|</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">probability</span> <span class="mf">0.4999999999999999</span> <span class="o">+/-</span> <span class="kc">None</span>
<span class="n">State</span> <span class="o">|</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">probability</span> <span class="mf">0.4999999999999999</span> <span class="o">+/-</span> <span class="kc">None</span>
</pre></div>
</div>
<p>As expected, the probability of measuring “0” on the second qubit is the same as the
probability of measuring “1”. Here, <code class="docutils literal notranslate"><span class="pre">err</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> because we took an infinite number
of shots.</p>
</section>
</section>
<section id="observable-mode">
<h3>OBSERVABLE mode<a class="headerlink" href="#observable-mode" title="Permalink to this heading"></a></h3>
<p>Let us now turn to the second type of final processing, namely the “OBSERVABLE” mode.
Our goal is to compute the average value of the following observable:</p>
<div class="math notranslate nohighlight">
\[O = X_0 \otimes Z_1\]</div>
<p>for the Bell state <span class="math notranslate nohighlight">\(|\psi\rangle=(|00\rangle+|11\rangle)/\sqrt{2}\)</span>.
A straightforward computation yields <span class="math notranslate nohighlight">\(\langle O \rangle = 0\)</span>. Let us now perform
this computation with QLM.</p>
<section id="infinite-number-of-shots">
<h4>Infinite number of shots<a class="headerlink" href="#infinite-number-of-shots" title="Permalink to this heading"></a></h4>
<p>Let us start with a computation devoid of any shot noise. It directly yields the expectation value <span class="math notranslate nohighlight">\(\langle O \rangle\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">CNOT</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>

<span class="c1"># Create a circuit</span>
<span class="n">qprog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qbits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Create an observable</span>
<span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">Term</span>
<span class="n">obs</span> <span class="o">=</span> <span class="n">Observable</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pauli_terms</span><span class="o">=</span><span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;XZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])])</span>

<span class="c1"># Create a job</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">observable</span><span class="o">=</span><span class="n">obs</span><span class="p">)</span>

<span class="c1"># Execute</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;O&gt; = &quot;</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">O</span><span class="o">&gt;</span> <span class="o">=</span>  <span class="mf">0.0</span>
</pre></div>
</div>
</section>
<section id="finite-number-of-shots">
<h4>Finite number of shots<a class="headerlink" href="#finite-number-of-shots" title="Permalink to this heading"></a></h4>
<p>We now look at the effect of shot noise, i.e the fact that in practice one can only
repeat the measurement a finite number of times:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">CNOT</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>

<span class="c1"># Create a circuit</span>
<span class="n">qprog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qbits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">qprog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Create an observable</span>
<span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">Term</span>
<span class="n">obs</span> <span class="o">=</span> <span class="n">Observable</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pauli_terms</span><span class="o">=</span><span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;XZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])])</span>

<span class="c1"># Create a job</span>
<span class="k">for</span> <span class="n">nbshots</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]:</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">observable</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">nbshots</span><span class="o">=</span><span class="n">nbshots</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&lt;O&gt; (</span><span class="si">{</span><span class="n">nbshots</span><span class="si">}</span><span class="s2"> shots) = </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> +/- </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">error</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">18</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">&quot;qpu.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">198</span><span class="p">,</span> <span class="ow">in</span> <span class="n">qat</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">CommonQPU</span><span class="o">.</span><span class="n">submit</span>
  <span class="n">File</span> <span class="s2">&quot;qpu.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">201</span><span class="p">,</span> <span class="ow">in</span> <span class="n">qat</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">CommonQPU</span><span class="o">.</span><span class="n">submit</span>
  <span class="n">File</span> <span class="s2">&quot;qpu.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">124</span><span class="p">,</span> <span class="ow">in</span> <span class="n">qat</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">CommonQPU</span><span class="o">.</span><span class="n">_submit_batch</span>
  <span class="n">File</span> <span class="s2">&quot;qpu.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">240</span><span class="p">,</span> <span class="ow">in</span> <span class="n">qat</span><span class="o">.</span><span class="n">clinalg</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">CLinalg</span><span class="o">.</span><span class="n">submit_job</span>
  <span class="n">File</span> <span class="s2">&quot;qpu.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">246</span><span class="p">,</span> <span class="ow">in</span> <span class="n">qat</span><span class="o">.</span><span class="n">clinalg</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">CLinalg</span><span class="o">.</span><span class="n">submit_job</span>
  <span class="n">File</span> <span class="s2">&quot;qpu.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">278</span><span class="p">,</span> <span class="ow">in</span> <span class="n">qat</span><span class="o">.</span><span class="n">clinalg</span><span class="o">.</span><span class="n">qpu</span><span class="o">.</span><span class="n">CLinalg</span><span class="o">.</span><span class="n">_calculate_expectation_value</span>
<span class="n">qat</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ttypes</span><span class="o">.</span><span class="n">QPUException</span><span class="p">:</span> <span class="n">QPUException</span><span class="p">(</span><span class="n">code</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">modulename</span><span class="o">=</span><span class="s1">&#39;qat.clinalg&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Observable with nbshots &gt; 0 not implemented. Use ObservableSplitter plugin.&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="further-information">
<h2>Further information<a class="headerlink" href="#further-information" title="Permalink to this heading"></a></h2>
<p>You will find a complete documentation of the objects mentioned above in the <a class="reference internal" href="source_doc.html#source-doc"><span class="std std-ref">source code documentation</span></a>:</p>
<ul class="simple">
<li><p>job: <a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Job</span></code></a>. See also: <a class="reference internal" href="qat-core.html#qat.core.Circuit.to_job" title="qat.core.Circuit.to_job"><code class="xref py py-meth docutils literal notranslate"><span class="pre">qat.core.Circuit.to_job()</span></code></a>.</p></li>
<li><p>observable: <a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Observable</span></code></a> and <a class="reference internal" href="qat-core.html#qat.core.Term" title="qat.core.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Term</span></code></a>.</p></li>
<li><p>results and samples: <a class="reference internal" href="qat-core.html#qat.core.Result" title="qat.core.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Result</span></code></a> and <a class="reference internal" href="qat-core.html#qat.core.wrappers.result.Sample" title="qat.core.wrappers.result.Sample"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.wrappers.result.Sample</span></code></a>.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="programming.html" class="btn btn-neutral float-left" title="Writing quantum circuits" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="running_variational.html" class="btn btn-neutral float-right" title="Running variational algorithms" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Atos 2016-2022.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>