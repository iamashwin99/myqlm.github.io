<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Combinatorial optimization &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="static/contentui.css" type="text/css" />
    <link rel="shortcut icon" href="static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/doctools.js"></script>
        <script src="static/contentui.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="static/js/require.min.js"></script>
        <script async="async" src="static/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML,local/local"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Interoperability with myQLM" href="myqlm_specific/interoperability.html" />
    <link rel="prev" title="Running variational algorithms" href="running_variational.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> myQLM documentation
            <img src="static/myqlm.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                myQLM-1.5.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Combinatorial optimization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#formulating-combinatorial-problems">Formulating combinatorial problems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ising-hamiltonians">Ising Hamiltonians</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quadratic-unconstrained-binary-optimization-qubo">Quadratic Unconstrained Binary Optimization (QUBO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-combinatorial-problems">General combinatorial problems</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#solving-combinatorial-problems">Solving combinatorial problems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantum-approximate-optimization-algorithm-qaoa">Quantum Approximate Optimization Algorithm (QAOA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulated-annealing-sa">Simulated Annealing (SA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulated-quantum-annealing-sqa">Simulated Quantum Annealing (SQA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-annealing-qa">Quantum Annealing (QA)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Main objects: Jobs, Observables, Circuits…</a></li>
<li class="toctree-l1"><a class="reference internal" href="manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Command-line tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source code documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="source_doc.html">Source code documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/contrib.html">Contributing to myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/release-note.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Combinatorial optimization</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="combinatorial-optimization">
<span id="id1"></span><h1>Combinatorial optimization<a class="headerlink" href="#combinatorial-optimization" title="Permalink to this headline"></a></h1>
<p>Many real life problems are combinatorial and solving them has actual practical applications. An intrinsic feature of these problems is that they can be formulated as minimization or maximization problems, i.e. with a cost function. At the same time finding the lowest energy of a physical system, represented by a cost Hamiltonian, is also a minimization problem. Due to this intimate relation, problems described with a cost function (<a class="reference internal" href="#qubo-description"><span class="std std-ref">QUBO</span></a>) or a cost Hamiltonian (<a class="reference internal" href="#ising-description"><span class="std std-ref">Ising</span></a>) could be solved by simulating the process of finding their minimum energy. This lowest energy should encode the solution to our problem.</p>
<p>myQLM provides <a class="reference internal" href="qat-opt.html#qubo-and-ising-code"><span class="std std-ref">helper classes</span></a> for both of these formulations, and also the more generic <a class="reference internal" href="#combinatorial-problem-description"><span class="std std-ref">Combinatorial Problem</span></a>, in which one can describe problems with clauses and variables - see the <a class="reference internal" href="#formulating-comb"><span class="std std-ref">Formulating combinatorial problems</span></a> section below.</p>
<p>Once the problems are encoded, one could solve them using a Quantum Approximate Optimization Algorithm (<a class="reference internal" href="#qaoa-description"><span class="std std-ref">QAOA</span></a>) or Simulated Annealing (<a class="reference internal" href="#sa-description"><span class="std std-ref">SA</span></a>). There are also tools to solve the problems via Simulated Quantum Annealing (<a class="reference internal" href="#sqa-description"><span class="std std-ref">SQA</span></a>), but they come in the full QLM version.</p>
<p>Among the many different combinatorial problems, some of the most interesting and challenging ones are the NP-hard problems. A lot of effort has been put over the last 10-15 years into formulating such optimization problems as QUBO/Ising instances. See <span id="id3">[<a class="reference internal" href="#id15" title="Andrew Lucas. Ising formulations of many np problems. Frontiers in Physics, 2:5, 2014. URL: https://www.frontiersin.org/articles/10.3389/fphy.2014.00005/full.">Luc14</a>]</span>  for an extensive reference. A direct encoding of some of these problems, described in the <a class="reference internal" href="advanced_combinatorial_optimization.html#np-problems-formulation"><span class="std std-ref">NP-hard problems</span></a> section, has also been <span class="xref std std-ref">implemented</span> on myQLM, along with example <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Foverview_combinatorial_optimization_myqlm.ipynb" style="color: #ff7823; text-decoration: underline">notebooks</a>.</p>
<section id="formulating-combinatorial-problems">
<span id="formulating-comb"></span><h2>Formulating combinatorial problems<a class="headerlink" href="#formulating-combinatorial-problems" title="Permalink to this headline"></a></h2>
<p>This section presents definitions of Ising Hamiltonians and QUBO cost functions, along with our conventions regarding their precise formulation (see also an <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Fintroduction_combinatorial_optimization_myqlm.ipynb" style="color: #ff7823; text-decoration: underline">introductory notebook</a>). Here is the outline:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#ising-hamiltonians">Ising Hamiltonians</a></p></li>
<li><p><a class="reference internal" href="#quadratic-unconstrained-binary-optimization-qubo">Quadratic Unconstrained Binary Optimization (QUBO)</a></p></li>
<li><p><a class="reference internal" href="#general-combinatorial-problems">General combinatorial problems</a></p></li>
</ol>
<section id="ising-hamiltonians">
<span id="ising-description"></span><h3>Ising Hamiltonians<a class="headerlink" href="#ising-hamiltonians" title="Permalink to this headline"></a></h3>
<p>Given <span class="math notranslate nohighlight">\(n\)</span> qubits, a <strong>2-local Ising Hamiltonian</strong> is an operator of the
form:</p>
<div class="math notranslate nohighlight">
\[H = - \sum_{i=1}^{n} h_{i}\sigma_{z}^{i} - \sum_{i,j=1}^{n} J_{ij}\sigma_{z}^{i}\sigma_{z}^{j}\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma_{z}^{i} = \begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}\)</span>,
<span class="math notranslate nohighlight">\(h\)</span> is a vector of real coefficients usually referred to as the <strong>local magnetic field</strong>,
and <span class="math notranslate nohighlight">\(J\)</span> is a <strong>real symmetric matrix with a zero diagonal</strong>, usually referred to as the <strong>coupling matrix</strong>.</p>
<p>This Hamiltonian is the direct <strong>quantization</strong> of the following <strong>classical Ising cost
function</strong>:</p>
<div class="math notranslate nohighlight">
\[H(s_{1},...,s_{n}) = - \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j}\]</div>
<p>where <span class="math notranslate nohighlight">\(s_{i}\in \{-1,1\}\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the <strong>interaction term</strong>, we do <strong>not</strong> restrict the sum to, e.g.,
<span class="math notranslate nohighlight">\(i &lt; j\)</span>. This is to make the computation of the Ising cost function
more straightforward to write
using, for instance, standard numpy functions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For clarity and readability, we do not include any <strong>offset constant term</strong>
in the definitions above. A definition including this term would be:
<span class="math notranslate nohighlight">\(- \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j} + o\)</span>,
with <span class="math notranslate nohighlight">\(o\)</span> the offset. Such a term does not change the <strong>optimization landscape</strong>,
but might be needed if one wants to <strong>match values</strong> when <strong>converting Ising cost functions into
QUBO instances and vice versa</strong>. See below for more details: <a class="reference internal" href="#qubo-description"><span class="std std-ref">QUBO</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the context of Ising Hamiltonians, qubits are also called <strong>spins</strong>.</p>
</div>
<p>Quantum annealing machines are typically designed to try and reach the <strong>minimum energy state
of Ising Hamiltonians</strong>, also called <strong>ground state</strong>, relying on the <strong>Adiabatic Theorem</strong>.
See for instance <span id="id4">[<a class="reference internal" href="#id13" title="Tameem Albash and Daniel A Lidar. Adiabatic quantum computation. Reviews of Modern Physics, 90(1):015002, 2018. URL: https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.90.015002.">AL18</a>]</span> for a general reference on adiabatic quantum computation.</p>
<p><strong>Classical annealing codes</strong> like Simulated Quantum Annealing (<a class="reference internal" href="#sqa-description"><span class="std std-ref">SQA</span></a>) try and do the same thing: Given <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(J\)</span> as input, they will, starting from a random configuration, try to apply <strong>updates</strong>, as part of <strong>Markov chain over the configuration space</strong>, in order to look for <strong>low energy states</strong>, where “energy” is defined by the formulas above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A coupling value <span class="math notranslate nohighlight">\(J &gt; 0\)</span> between two spins <span class="math notranslate nohighlight">\(\sigma_{i}\)</span> and
<span class="math notranslate nohighlight">\(\sigma_{j}\)</span> can sometimes be called, in our convention, a <strong>ferromagnetic coupling</strong>,
as the alignment of the two spins onto a same value will tend to <strong>lower the energy</strong> of the system
making it closer to its <strong>ground state</strong>.</p>
</div>
<p>In other words, <strong>quantum annealing machines</strong> and, consequently, <strong>classical annealing codes</strong>, <a class="reference internal" href="#sa-description"><span class="std std-ref">SA</span></a>, aim at tackling the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[\min_{s_{1}...s_{n}\in \{-1,1\}} \left(- \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j}\right)\]</div>
<p>given <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(J\)</span> as input.</p>
<p>To produce such Ising-formulated problems, one can use the <a class="reference internal" href="qat-opt.html#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.Ising</span></code></a> class. It is also possible to translate it to <a class="reference internal" href="qat-opt.html#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.QUBO</span></code></a> via <a class="reference internal" href="qat-opt.html#qat.opt.Ising.to_qubo" title="qat.opt.Ising.to_qubo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_qubo()</span></code></a> or to <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a> via <a class="reference internal" href="qat-opt.html#qat.opt.Ising.to_combinatorial_problem" title="qat.opt.Ising.to_combinatorial_problem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_combinatorial_problem()</span></code></a>.</p>
</section>
<section id="quadratic-unconstrained-binary-optimization-qubo">
<span id="qubo-description"></span><h3>Quadratic Unconstrained Binary Optimization (QUBO)<a class="headerlink" href="#quadratic-unconstrained-binary-optimization-qubo" title="Permalink to this headline"></a></h3>
<p>Quadratic Unconstrained Binary Optimization consists in, given a <strong>real symmetric matrix</strong>
<span class="math notranslate nohighlight">\(Q\)</span>, <strong>minimizing</strong> the following cost function <span class="math notranslate nohighlight">\(q\)</span>:</p>
<div class="math notranslate nohighlight">
\[q(x_{1},...,x_{n}) = \sum_{i,j=1}^{n} - Q_{ij}x_{i}x_{j}\]</div>
<p>where <span class="math notranslate nohighlight">\(x_{1},...,x_{n}\in \{0,1\}\)</span> are <strong>binary variables</strong>.</p>
<p>Written differently, by <strong>solving a QUBO problem</strong>, we mean solving,
given <span class="math notranslate nohighlight">\(Q\)</span>:</p>
<div class="math notranslate nohighlight">
\[\min_{x_{1}...x_{n}\in \{0,1\}} \sum_{i,j=1}^{n} - Q_{ij}x_{i}x_{j}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <strong>diagonal</strong> of <span class="math notranslate nohighlight">\(Q\)</span> is allowed to contain <strong>non-zero elements</strong>.
Because <span class="math notranslate nohighlight">\(\forall i \quad x_{i}\in\{0,1\}\)</span>, <span class="math notranslate nohighlight">\(x_{i}^{2} = x_{i}\)</span>,
and the diagonal terms in the sum above effectively correspond to a <strong>linear part</strong>
of the cost function, which can be seen as similar to the <strong>magnetic field terms</strong>
in <strong>Ising Hamiltonians</strong>.</p>
</div>
<p><strong>QUBO instances</strong> are in one-to-one correspondance with <strong>Ising Hamiltonians and cost functions</strong>.</p>
<p>Indeed, starting from the expression above for <span class="math notranslate nohighlight">\(q\)</span>, the <strong>QUBO cost function</strong>,
and defining <span class="math notranslate nohighlight">\(s_{i}=2x_{i}-1\)</span> (<span class="math notranslate nohighlight">\(\in \{-1,1\}\)</span> as <span class="math notranslate nohighlight">\(x_{i}\in\{0,1\}\)</span>),
i.e <span class="math notranslate nohighlight">\(x_{i}=\frac{s_{i}+1}{2}\)</span>,
one can indeed write:</p>
<div class="math notranslate nohighlight">
\[\begin{split}q(x_{1},...x_{n}) &amp;= \sum_{i,j=1}^{n} - Q_{i,j} x_{i}x_{j} \\~\\
                  &amp;= - \sum_{i,j=1}^{n} Q_{i,j} \left(\frac{s_{i}+1}{2}\right)\left(\frac{s_{j}+1}{2}\right) \\~\\
                  &amp;= - \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4}\left(1+s_{i}+s_{j}+s_{i}s_{j}\right) \\~\\
                  &amp;= - \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} - \sum_{i}\left(\sum_{j}\frac{Q_{i,j}}{4}\right) s_{i} - \sum_{j}\left(\sum_{i}\frac{Q_{i,j}}{4}\right) s_{j} - \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} s_{i}s_{j} \\~\\
                  &amp;= - \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} - \sum_{i=1}^{n} \frac{Q_{i,i}}{4} - \sum_{i}\left(\sum_{j}\frac{Q_{i,j}}{2}\right) s_{i}  - \sum_{i,j | i\neq j}^{n} \frac{Q_{i,j}}{4} s_{i}s_{j} \\~\\
                  &amp;= - \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j} + o\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(h_{i}=\sum_{j}\frac{Q_{i,j}}{2}\)</span>, <span class="math notranslate nohighlight">\(J_{ij}=\frac{Q_{i,j}}{4}\)</span>
and an <strong>offset term</strong> <span class="math notranslate nohighlight">\(o=- \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} - \sum_{i=1}^{n} \frac{Q_{i,i}}{4}\)</span>.</p>
<p>In this case, <a class="reference internal" href="qat-opt.html#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> is the representative class and it can be translated to <a class="reference internal" href="qat-opt.html#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> and <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a> via the <a class="reference internal" href="qat-opt.html#qat.opt.QUBO.to_ising" title="qat.opt.QUBO.to_ising"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_ising()</span></code></a> and <a class="reference internal" href="qat-opt.html#qat.opt.QUBO.to_combinatorial_problem" title="qat.opt.QUBO.to_combinatorial_problem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_combinatorial_problem()</span></code></a>, respectively.</p>
</section>
<section id="general-combinatorial-problems">
<span id="combinatorial-problem-description"></span><h3>General combinatorial problems<a class="headerlink" href="#general-combinatorial-problems" title="Permalink to this headline"></a></h3>
<p>The most general way to specify a combinatorial problem is by explicitly declaring boolean variables (<a class="reference internal" href="qat-opt.html#qat.opt.boolexpr.Var" title="qat.opt.boolexpr.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a>) and  clauses (<a class="reference internal" href="qat-opt.html#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a>) combining these variables. This is achieved via the <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.CombinatorialProblem</span></code></a> class.</p>
<p>While <a class="reference internal" href="#ising-description"><span class="std std-ref">Ising</span></a> and <a class="reference internal" href="#qubo-description"><span class="std std-ref">QUBO</span></a> only accept up to two-variable terms, one can define clauses in <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a> with as many variables as desired. However, for the case of no more than two variables, a translation to the Ising and QUBO formulations is available using the <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem.to_ising" title="qat.opt.CombinatorialProblem.to_ising"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_ising()</span></code></a> and <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem.to_qubo" title="qat.opt.CombinatorialProblem.to_qubo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_qubo()</span></code></a> methods.</p>
<p>The cost Hamiltonian extraction is handled by the <a class="reference internal" href="qat-opt.html#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a> class such that the final cost Hamiltonian consists of the weighted sum of the cost Hamiltonian of its clauses.</p>
</section>
</section>
<section id="solving-combinatorial-problems">
<span id="solving-comb"></span><h2>Solving combinatorial problems<a class="headerlink" href="#solving-combinatorial-problems" title="Permalink to this headline"></a></h2>
<p>This section describes how to define and solve combinatorial problems using QLM tools. Here is the outline:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#quantum-approximate-optimization-algorithm-qaoa">Quantum Approximate Optimization Algorithm (QAOA)</a></p></li>
<li><p><a class="reference internal" href="#simulated-annealing-sa">Simulated Annealing (SA)</a></p></li>
<li><p><a class="reference internal" href="#simulated-quantum-annealing-sqa">Simulated Quantum Annealing (SQA)</a></p></li>
<li><p><a class="reference internal" href="#quantum-annealing-qa">Quantum Annealing (QA)</a></p></li>
</ol>
<section id="quantum-approximate-optimization-algorithm-qaoa">
<span id="qaoa-description"></span><h3>Quantum Approximate Optimization Algorithm (QAOA)<a class="headerlink" href="#quantum-approximate-optimization-algorithm-qaoa" title="Permalink to this headline"></a></h3>
<p>The Quantum Approximate Optimization Algorithm is a heuristic to design variational Ansätze for combinatorial optimization. It is inspired from the digitalization of an analog evolution using a linear ramp, starting from a simple initial Hamiltonian <span class="math notranslate nohighlight">\(H_0 = - \sum_i \sigma_x^i\)</span> to a diagonal Hamiltonian whose ground state encodes the solution to our problem.</p>
<p>The circuits produced by this method have the following shape:</p>
<figure class="align-default">
<img alt="images/qaoa_circuit.PNG" src="images/qaoa_circuit.PNG" />
</figure>
<p>where <span class="math notranslate nohighlight">\(H_0 = - \sum_i \sigma_x^i\)</span>, and <span class="math notranslate nohighlight">\(H_C\)</span> is an (efficiently generated) classical cost Hamiltonian that encodes the cost function to optimize. The propagator <span class="math notranslate nohighlight">\(e^{i\gamma H_C}\)</span> is usually simple to implement from a problem specification. <span class="math notranslate nohighlight">\(e^{i\beta H_0}\)</span> simply corresponds to a collection of <span class="math notranslate nohighlight">\(R_X\)</span> rotations of angle <span class="math notranslate nohighlight">\(2\beta\)</span>.</p>
<p>Once such a circuit is produced, one can use a QPU, along with a classical optimizer, to minimize the quantity:
<span class="math notranslate nohighlight">\(\langle 0|C(\gamma, \beta)^\dagger H_C C(\gamma, \beta)|0 \rangle\)</span>
in order to produce a quantum state with the lowest possible energy (i.e that overlaps well with the proper ground state of <span class="math notranslate nohighlight">\(H_C\)</span>, which, by construction, corresponds to the optimal solution of our problem). This can be handled via a variational plugin in the QLM, see <a class="reference internal" href="variational-plugin.html#variational-programs"><span class="std std-ref">this section</span></a> for more details.</p>
<p>As you can see, the circuit is also parametrized by a depth <span class="math notranslate nohighlight">\(d\)</span> corresponding to the number of alternating variational layers. The larger the depth, the better the approximation of the solution (at least in theory). In practice, increasing this parameter yields a larger circuit with greater number of parameters to optimize, which can slow down the convergence of the algorithm.</p>
<p>The algorithm is fully described in <span id="id5">[<a class="reference internal" href="#id12" title="Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. A quantum approximate optimization algorithm. 2014. arXiv:1411.4028.">FGG14</a>]</span>.</p>
<p>It is possible to directly generate ready to run QAOA jobs (containing an Ansatz and the target Hamiltonian) from an instance of <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a>/<a class="reference internal" href="qat-opt.html#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a>/<a class="reference internal" href="qat-opt.html#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> via the <a class="reference internal" href="qat-opt.html#qat.opt.circuit_generator.CircuitGenerator" title="qat.opt.circuit_generator.CircuitGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">CircuitGenerator</span></code></a> class. In that case the qlm will take care of generating a cost Hamiltonian for the problem (depending on how you specified it).</p>
<p>If you need a lower level interface, the <a class="reference internal" href="qat-opt.html#qat.vsolve.ansatz.AnsatzFactory" title="qat.vsolve.ansatz.AnsatzFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.vsolve.ansatz.AnsatzFactory</span></code></a> provides a recipe to produce such a variational circuit from a target Hamiltonian. In both cases, the Ansatz factory allows you to pick between (at least) three different circuit synthesis strategies, yielding functionally equivalent circuits with different shapes.</p>
</section>
<section id="simulated-annealing-sa">
<span id="sa-description"></span><h3>Simulated Annealing (SA)<a class="headerlink" href="#simulated-annealing-sa" title="Permalink to this headline"></a></h3>
<p><strong>Simulated annealing</strong> is a well-known, historical heuristic for
combinatorial optimization. It aims at finding low energy-states
of a classical Ising system with a <strong>Markov Chain</strong> over
<strong>spin configurations</strong>, with <strong>decreasing stochasticity</strong>.</p>
<p>Stochasticity is specified by a <strong>temperature</strong>. In practice, a
<strong>decreasing temperature schedule</strong> is given to the algorithm.
At the beginning of the execution, large temperature values allow
to <strong>jump over energy barriers</strong> to escape <strong>local optima</strong>. When
temperature settles to lower values, the <strong>Markov chain</strong> will
hopefully settle to the global optimum of the cost function.</p>
<p>Mathematically, simulated annealing tries to find, given <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(J\)</span>, the global minimum configuration of:</p>
<div class="math notranslate nohighlight">
\[H(s_{1},...,s_{n}) = -\sum_{i,j=1}^{n} J_{ij}s_{i}s_{j}-\sum_{i=1} h_{i}s_{i}\]</div>
<p>It does so by first choosing a <strong>random configuration</strong>, which then
evolves by applying <strong>updates</strong>. In the case of simulated annealing,
an update consists in <strong>flipping the value</strong> <span class="math notranslate nohighlight">\(s_{i}\)</span> <strong>of a single spin</strong>.</p>
<p>An update is <strong>accepted</strong> with probability:</p>
<div class="math notranslate nohighlight">
\[P_{flip} = min(1, e^{-\Delta H / T})\]</div>
<p>with <span class="math notranslate nohighlight">\(\Delta H\)</span> is the energy change incurred by switching from <span class="math notranslate nohighlight">\(s_{i}\)</span> to <span class="math notranslate nohighlight">\(-s_{i}\)</span>. A change decreasing the energy of the system is always accepted, whereas a change which increases it needs a temperature high enough to have a non-negligible probability of being accepted.</p>
<p>The following picture explains in pseudo-code how simulated annealing works.</p>
<a class="reference internal image-reference" href="images/simulated_annealing_algoritm_latex.png"><img alt="images/simulated_annealing_algoritm_latex.png" class="align-center" src="images/simulated_annealing_algoritm_latex.png" style="width: 600px;" /></a>
<p>A basic example of the use of SA - to solve the Antiferromagnetic Ising Model, is presented in the notebook <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Fgetting_started_with_sa.ipynb" style="color: #ff7823; text-decoration: underline">Getting started with SA</a>. Some more involved examples where SA solves some of the <a class="reference internal" href="advanced_combinatorial_optimization.html#np-problems-formulation"><span class="std std-ref">NP-hard problems</span></a> have also been implemented in the following <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Foverview_combinatorial_optimization_myqlm.ipynb" style="color: #ff7823; text-decoration: underline">notebooks</a>.</p>
</section>
<section id="simulated-quantum-annealing-sqa">
<h3>Simulated Quantum Annealing (SQA)<a class="headerlink" href="#simulated-quantum-annealing-sqa" title="Permalink to this headline"></a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Simulated Quantum Annealing is not available in myQLM.
QUBO and Ising problems can still be used to construct QAOA
Ansätze using the <cite>.qaoa_ansatz</cite> method or solved via
<a class="reference internal" href="#sa-description"><span class="std std-ref">Simulated Annealing</span></a>.</p>
</div>
<p>Simulated quantum annealing provides a heuristic which aims to
minimize <strong>quantum Ising Hamiltonians</strong>.</p>
<p>The questions of whether SQA performs such minimizations more efficiently
than <strong>physical quantum annealing machines</strong>, and whether SQA
can be called ‘emulation’ of those machines is a matter of hot scientific debate.</p>
<p>Settling these questions is of course beyond the scope of this
documentation. The interested reader may look at: <span id="id6">[<a class="reference internal" href="#id14" title="Troels F Rønnow, Zhihui Wang, Joshua Job, Sergio Boixo, Sergei V Isakov, David Wecker, John M Martinis, Daniel A Lidar, and Matthias Troyer. Defining and detecting quantum speedup. science, 345(6195):420–424, 2014. URL: https://science.sciencemag.org/content/345/6195/420.full.">RonnowWJ+14</a>]</span>,
<span id="id7">[<a class="reference internal" href="#id16" title="Vasil S Denchev, Sergio Boixo, Sergei V Isakov, Nan Ding, Ryan Babbush, Vadim Smelyanskiy, John Martinis, and Hartmut Neven. What is the computational value of finite-range tunneling? Physical Review X, 6(3):031015, 2016. URL: https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.031015.">DBI+16</a>]</span>, <span id="id8">[<a class="reference internal" href="#id18" title="Itay Hen, Joshua Job, Tameem Albash, Troels F Rønnow, Matthias Troyer, and Daniel A Lidar. Probing for quantum speedup in spin-glass problems with planted solutions. Physical Review A, 92(4):042325, 2015. URL: https://journals.aps.org/pra/abstract/10.1103/PhysRevA.92.042325.">HJA+15</a>]</span> or <span id="id9">[<a class="reference internal" href="#id17" title="Evgeny Andriyash and Mohammad H Amin. Can quantum monte carlo simulate quantum annealing? 2017. arXiv:1703.09277.">AA17</a>]</span>, for instance.</p>
<p>Formally, our SQA implementation is based on a <strong>discrete-time
path integral Monte Carlo</strong> formulation of quantum annealing, as derivedF
in <span id="id10">[<a class="reference internal" href="#id19" title="Roman Martoňák, Giuseppe E Santoro, and Erio Tosatti. Quantum annealing by the path-integral monte carlo method: the two-dimensional random ising model. Physical Review B, 66(9):094203, 2002. URL: https://journals.aps.org/prb/abstract/10.1103/PhysRevB.66.094203.">MartovnakST02</a>]</span>.</p>
<p>In short, instead of sampling the equilibrium distribution, at finite temperature of the quantum Ising Hamiltonian:</p>
<div class="math notranslate nohighlight">
\[H = -\sum_{i,j} J_{i,j}\sigma_{z}^{i}\sigma_{z}^{j}-\sum_{i} h_{i}\sigma_{z}^{i} - \Gamma\sum_{i}\sigma_{x}^{i}\]</div>
<p>one samples from the equivalent classical Ising Hamiltonian:</p>
<div class="math notranslate nohighlight">
\[H = -\sum_{k=1}^{n_{trotters}}\left( \sum_{i,j} J_{i,j} s_{i}^{k}s_{j}^{k} + \sum_{i} h_{i} s_{i}^{k} + J^{\perp}s_{l}^{k}s_{l}^{k+1} \right)\]</div>
<p>with <span class="math notranslate nohighlight">\(J^{\perp} = - n_{trotters}\cdot \log\left(\tanh(\frac{\Gamma}{n_{trotters}T})\right)\)</span> and <span class="math notranslate nohighlight">\(n\)</span> quantum spins are replaced with <span class="math notranslate nohighlight">\(n_{trotters}\times n\)</span> classical spins.</p>
<p>In quantum annealing, <span class="math notranslate nohighlight">\(\Gamma\)</span> is typically gradually decreased
from a high value to <span class="math notranslate nohighlight">\(0\)</span>, such that, if the system is prepared in the
ground state of <span class="math notranslate nohighlight">\(\sum_{i}\Gamma\sigma_{x}^{i}\)</span>, it ends up
in the ground state of the Ising Hamiltonian at the end of the transition.</p>
<p>The idea of simulated quantum annealing is to sample from the equilibrium
distribution of the equivalent classical Hamiltonian at several
points <span class="math notranslate nohighlight">\(\{\Gamma_{l}\}\)</span> along that transition.
The configuration resulting from sampling at <span class="math notranslate nohighlight">\(\Gamma_{l}\)</span>
is kept at the starting configuration for <span class="math notranslate nohighlight">\(\Gamma_{l+1}\)</span>.</p>
<p>The following picture describes in pseudo-code how the simulated
quantum annealing works.</p>
<a class="reference internal image-reference" href="images/simulated_quantum_annealing_algoritm_latex.png"><img alt="images/simulated_quantum_annealing_algoritm_latex.png" class="align-center" src="images/simulated_quantum_annealing_algoritm_latex.png" style="width: 600px;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <strong>memory requirements</strong> of <strong>simulated quantum
annealing</strong> are <strong>polynomial in the number of spins</strong>.
There is <strong>no hard memory
limit</strong> as to how many spins can be represented and manipulated with
this technique.</p>
</div>
<p>This SQA algorithm is implemented in the <code class="docutils literal notranslate"><span class="pre">qat.sqa.SQAQPU</span></code>. The quality of the solutions returned will depend on the parameters given to the algorithm (minimum and maximum <cite>gamma</cite> and temperature, number of Monte Carlo steps, etc). We provide a set of fine tuned parameters for common problem classes. The SQA solver was tested on the <a class="reference internal" href="advanced_combinatorial_optimization.html#np-problems-formulation"><span class="std std-ref">encoded NP-hard problems</span></a> with various benchmarks and the respective performances were recorded. Along with the problem size and annealing times, the results are presented in the <a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">SQA Benchmarking and Performance</span></a> section.</p>
</section>
<section id="quantum-annealing-qa">
<span id="qa-description"></span><h3>Quantum Annealing (QA)<a class="headerlink" href="#quantum-annealing-qa" title="Permalink to this headline"></a></h3>
<p>Quantum Annealing is a generic optimization framework that utilizes a continuous quantum dynamic to find the global minimum of a target function.
In practice, this framework is often applied to combinatorial optimization since combinatorial cost function are usually simple to encode into a Hamiltonian.</p>
<p>A generic quantum annealing is defined using a target Hamiltonian <span class="math notranslate nohighlight">\(H_{C}\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[H_C | x\rangle = C(x)|x\rangle\]</div>
<p>encodes a cost function <span class="math notranslate nohighlight">\(C\)</span>, and using a problem independent mixing Hamiltonian <span class="math notranslate nohighlight">\(H_0\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[[H_C, H_0] \neq 0\]</div>
<p>The quantum system is prepared in the (problem independent) ground state of <span class="math notranslate nohighlight">\(H_0\)</span> and evolved slowly according the following time-dependent Hamiltonian:</p>
<div class="math notranslate nohighlight">
\[H(t) = (1 - \frac{t}{T}) H_0 + \frac{t}{T} H_C\]</div>
<p>during a time <span class="math notranslate nohighlight">\(T\)</span>. For large <span class="math notranslate nohighlight">\(T\)</span>, the adiabatic theorem states that the final quantum state will ‘largely’ overlap the ground state of <span class="math notranslate nohighlight">\(H_C\)</span>. Thus, measuring this quantum state in the computational basis will produce the global minimum of <span class="math notranslate nohighlight">\(C\)</span> with large probability.</p>
<p>It is possible to automatically generate quantum annealing jobs from a any of the problem description classes descibed earlier. For instance, the following piece of code produces an annealing job for a MaxCut instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">MaxCut</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">generators</span><span class="o">.</span><span class="n">erdos_renyi_graph</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">MaxCut</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="c1"># We just need to specify the value of T (tmax)</span>
<span class="n">annealing_job</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">annealing_job</span><span class="p">(</span><span class="n">tmax</span><span class="o">=</span><span class="mi">47</span><span class="p">)</span>
</pre></div>
</div>
<p>The default mixing Hamitonian (<span class="math notranslate nohighlight">\(H_0\)</span>) is :</p>
<div class="math notranslate nohighlight">
\[H_0 = - \sum \sigma_x^{(i)}\]</div>
<p>Its ground state is <span class="math notranslate nohighlight">\(|+\rangle^{\otimes n}\)</span> (a simple product state).</p>
<p>Some applications may require more advanced mixing Hamiltonians. QLM comes with a few mixing Hamiltonians already pre-programmed in a <a class="reference internal" href="qat-opt.html#qat.opt.MixingFactory" title="qat.opt.MixingFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixingFactory</span></code></a>.</p>
<p>One can, for instance, define a bit-move mixing Hamiltonian that will mix the subspaces of constant Hamming weights. This is useful when one needs to restrict the search to bit-strings of fixed Hamming weight:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">MaxCut</span><span class="p">,</span> <span class="n">MixingFactory</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">generators</span><span class="o">.</span><span class="n">erdos_renyi_graph</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">MaxCut</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

<span class="c1"># Looking for a solution of Hamming weight 3</span>
<span class="n">mixing</span> <span class="o">=</span> <span class="n">MixingFactory</span><span class="o">.</span><span class="n">bit_move</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">annealing_job</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">annealing_job</span><span class="p">(</span><span class="n">tmax</span><span class="o">=</span><span class="mi">47</span><span class="p">,</span> <span class="n">mixing</span><span class="o">=</span><span class="n">mixing</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;stdin&gt;:8: DeprecationWarning: `np.complex` is a deprecated alias for the builtin `complex`. To silence this warning, use `complex` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.complex128` here.
Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
</pre></div>
</div>
<p>Doing this will effectively change the mixing Hamiltonian, and, of course, the initial state of the computation. This change can lead to an increase in the computation time since some mixing Hamiltonians have non trivial ground states whose preparation might involve a problem independent annealing to take place before the true annealing.</p>
</section>
</section>
<section id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline"></a></h2>
<p id="id11"><dl class="citation">
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id4">AL18</a></span></dt>
<dd><p>Tameem Albash and Daniel A Lidar. Adiabatic quantum computation. <em>Reviews of Modern Physics</em>, 90(1):015002, 2018. URL: <a class="reference external" href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.90.015002">https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.90.015002</a>.</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id9">AA17</a></span></dt>
<dd><p>Evgeny Andriyash and Mohammad H Amin. Can quantum monte carlo simulate quantum annealing? 2017. <a class="reference external" href="https://arxiv.org/abs/1703.09277">arXiv:1703.09277</a>.</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id7">DBI+16</a></span></dt>
<dd><p>Vasil S Denchev, Sergio Boixo, Sergei V Isakov, Nan Ding, Ryan Babbush, Vadim Smelyanskiy, John Martinis, and Hartmut Neven. What is the computational value of finite-range tunneling? <em>Physical Review X</em>, 6(3):031015, 2016. URL: <a class="reference external" href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.031015">https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.031015</a>.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id5">FGG14</a></span></dt>
<dd><p>Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. A quantum approximate optimization algorithm. 2014. <a class="reference external" href="https://arxiv.org/abs/1411.4028">arXiv:1411.4028</a>.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id8">HJA+15</a></span></dt>
<dd><p>Itay Hen, Joshua Job, Tameem Albash, Troels F Rønnow, Matthias Troyer, and Daniel A Lidar. Probing for quantum speedup in spin-glass problems with planted solutions. <em>Physical Review A</em>, 92(4):042325, 2015. URL: <a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.92.042325">https://journals.aps.org/pra/abstract/10.1103/PhysRevA.92.042325</a>.</p>
</dd>
<dt class="label" id="id15"><span class="brackets">Luc14</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>Andrew Lucas. Ising formulations of many np problems. <em>Frontiers in Physics</em>, 2:5, 2014. URL: <a class="reference external" href="https://www.frontiersin.org/articles/10.3389/fphy.2014.00005/full">https://www.frontiersin.org/articles/10.3389/fphy.2014.00005/full</a>.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id10">MartovnakST02</a></span></dt>
<dd><p>Roman Martoňák, Giuseppe E Santoro, and Erio Tosatti. Quantum annealing by the path-integral monte carlo method: the two-dimensional random ising model. <em>Physical Review B</em>, 66(9):094203, 2002. URL: <a class="reference external" href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.66.094203">https://journals.aps.org/prb/abstract/10.1103/PhysRevB.66.094203</a>.</p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id6">RonnowWJ+14</a></span></dt>
<dd><p>Troels F Rønnow, Zhihui Wang, Joshua Job, Sergio Boixo, Sergei V Isakov, David Wecker, John M Martinis, Daniel A Lidar, and Matthias Troyer. Defining and detecting quantum speedup. <em>science</em>, 345(6195):420–424, 2014. URL: <a class="reference external" href="https://science.sciencemag.org/content/345/6195/420.full">https://science.sciencemag.org/content/345/6195/420.full</a>.</p>
</dd>
</dl>
</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="running_variational.html" class="btn btn-neutral float-left" title="Running variational algorithms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="myqlm_specific/interoperability.html" class="btn btn-neutral float-right" title="Interoperability with myQLM" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Atos 2016-2021.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>