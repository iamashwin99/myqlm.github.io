<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qat-opt: representation and encoding of combinatorial problems, QAOA &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="static/contentui.css" type="text/css" />
      <link rel="stylesheet" href="static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
    <link rel="shortcut icon" href="static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="static/doctools.js"></script>
        <script src="static/sphinx_highlight.js"></script>
        <script src="static/contentui.js"></script>
        <script src="static/design-tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Combinatorial Optimization Generators tools" href="combinatorial_optimization_generators_utils.html" />
    <link rel="prev" title="Digital quantum simulation for spin and fermionic systems" href="qat-fermion_source.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> myQLM documentation
            <img src="static/myqlm.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                myQLM-1.7.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorial_optimization_intro.html">Combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">List of notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Main objects: Jobs, Observables, Circuits…</a></li>
<li class="toctree-l1"><a class="reference internal" href="manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch_generators.html">Building advanced computation stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="qat-fermion.html">Digital quantum simulation for spin and fermionic systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Command-line tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source code documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="source_doc.html">Source code documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#quantum-application-toolchain-qat-python-libraries">Quantum Application ToolChain (QAT) Python libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#the-core-library">The core library</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#the-programming-library">The programming library</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#the-device-library">The device library</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#generators">Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#plugins">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#qpus">QPUs</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#interoperability-with-other-frameworks">Interoperability with other frameworks</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#digital-quantum-simulation-tools">Digital quantum simulation tools</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="source_doc.html#combinatorial-optimization-and-qaoa">Combinatorial optimization and QAOA</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">qat-opt: representation and encoding of combinatorial problems, QAOA</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#declaring-and-manipulating-combinatorial-problems">Declaring and manipulating combinatorial problems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-the-qaoa-ansatz">Generating the QAOA Ansatz</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-qa-jobs">Generating QA jobs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encoding-np-hard-problems">Encoding NP-hard Problems</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="combinatorial_optimization_generators_utils.html">Combinatorial Optimization Generators tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/contrib.html">Contributing to myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/release-note.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="source_doc.html">Source code documentation</a> &raquo;</li>
      <li>qat-opt: representation and encoding of combinatorial problems, QAOA</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="qat-opt-representation-and-encoding-of-combinatorial-problems-qaoa">
<span id="combinatorial-optimization-source"></span><h1>qat-opt: representation and encoding of combinatorial problems, QAOA<a class="headerlink" href="#qat-opt-representation-and-encoding-of-combinatorial-problems-qaoa" title="Permalink to this heading"></a></h1>
<p>This section describes how to define and solve combinatorial problems using myQLM tools.</p>
<section id="declaring-and-manipulating-combinatorial-problems">
<h2>Declaring and manipulating combinatorial problems<a class="headerlink" href="#declaring-and-manipulating-combinatorial-problems" title="Permalink to this heading"></a></h2>
<p>The most generic class used to describe combinatorial problems is the <a class="reference internal" href="#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.CombinatorialProblem</span></code></a> class.
It provides a simple interface to declare boolean variables and clauses, and ways to turn abstract problems into <a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">Job</span></code></a> or objects that can be fed to solvers.</p>
<p>In the (quite common case) where the problem’s clauses only involve at most two variables at a time (QUBO), we also provide a couple of optimized classes to describe the problem
directly in terms of Ising coupling matrix or QUBO <span class="math notranslate nohighlight">\(Q\)</span> matrix (see below).
Back-and-forth translations are avaible between the three problem classes using the <code class="code docutils literal notranslate"><span class="pre">to_XXX</span></code> methods.</p>
<section id="generic-combinatorial-optimization">
<h3>Generic combinatorial optimization<a class="headerlink" href="#generic-combinatorial-optimization" title="Permalink to this heading"></a></h3>
<div class="toggle-header docutils container">
<p><strong>Combinatorial Problem</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.CombinatorialProblem">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.</span></span><span class="sig-name descname"><span class="pre">CombinatorialProblem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.CombinatorialProblem" title="Permalink to this definition"></a></dt>
<dd><p>Basic interface to describe a combinatorial optimization problem.</p>
<p>The problem declaration is done via methods <a class="reference internal" href="#qat.opt.CombinatorialProblem.new_var" title="qat.opt.CombinatorialProblem.new_var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">new_var()</span></code></a>
(or <a class="reference internal" href="#qat.opt.CombinatorialProblem.new_vars" title="qat.opt.CombinatorialProblem.new_vars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">new_vars()</span></code></a> to declare arrays)
and <a class="reference internal" href="#qat.opt.CombinatorialProblem.add_clause" title="qat.opt.CombinatorialProblem.add_clause"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_clause()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">CombinatorialProblem</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">CombinatorialProblem</span><span class="p">(</span><span class="s2">&quot;MyProblem&quot;</span><span class="p">)</span>
<span class="c1"># Declare two fresh variables</span>
<span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">new_vars</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Add a new clause consisting of the logical AND of the two variables</span>
<span class="n">problem</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">var1</span> <span class="o">&amp;</span> <span class="n">var2</span><span class="p">)</span>
<span class="c1"># Add a new clause consisting of the XOR of the two variables</span>
<span class="n">problem</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">var1</span> <span class="o">^</span> <span class="n">var2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyProblem</span><span class="p">:</span>
 <span class="mi">2</span> <span class="n">variables</span><span class="p">,</span> <span class="mi">2</span> <span class="n">clauses</span>
</pre></div>
</div>
<p>It is possible to add weights to the clauses:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">CombinatorialProblem</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">CombinatorialProblem</span><span class="p">()</span>
<span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">new_vars</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">problem</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">var1</span> <span class="o">&amp;</span> <span class="n">var2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Problem</span><span class="p">:</span>
 <span class="mi">2</span> <span class="n">variables</span><span class="p">,</span> <span class="mi">1</span> <span class="n">clauses</span>
</pre></div>
</div>
<p>A diagonal Hamiltonian encoding the cost function of the problem can be extracted using the
<a class="reference internal" href="#qat.opt.CombinatorialProblem.get_observable" title="qat.opt.CombinatorialProblem.get_observable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_observable()</span></code></a> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">CombinatorialProblem</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">CombinatorialProblem</span><span class="p">()</span>
<span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">new_vars</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">problem</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">var1</span> <span class="o">&amp;</span> <span class="n">var2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">obs</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">get_observable</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">0.125</span> <span class="o">*</span> <span class="n">I</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.125</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.125</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span><span class="o">|</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">0.125</span> <span class="o">*</span> <span class="p">(</span><span class="n">ZZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Finally, this class inherits from the <a class="reference internal" href="#qat.opt.circuit_generator.CircuitGenerator" title="qat.opt.circuit_generator.CircuitGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">CircuitGenerator</span></code></a>
class, which provides
a method to directly generate variational Ansätze
to try and minimize the energy of the cost Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>optional</em><em>, </em><em>str</em>) – a name to display when the problem is printed</p></li>
<li><p><strong>maximization</strong> (<em>optional</em><em>, </em><em>bool</em>) – Used to specify that the problem is
a maximization problem (i.e its cost function is the sum of its clauses).
In practice, it will simply flip the sign of the generated cost
Hamiltonian. Default to false.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.CombinatorialProblem.add_clause">
<span class="sig-name descname"><span class="pre">add_clause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.CombinatorialProblem.add_clause" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new clause to the problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<a class="reference internal" href="#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a>) – a clause object</p></li>
<li><p><strong>weight</strong> (<em>optional</em><em>, </em><em>float</em>) – optionally a weight (default to 1)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the problem itself</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.CombinatorialProblem.get_observable">
<span class="sig-name descname"><span class="pre">get_observable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.CombinatorialProblem.get_observable" title="Permalink to this definition"></a></dt>
<dd><p>Generates a cost Hamiltonian for the problem.</p>
<p>The cost Hamiltonian is diagonal and associate to each bitstring <span class="math notranslate nohighlight">\(|s\rangle\)</span> an
energy <span class="math notranslate nohighlight">\(\sum_\alpha w_\alpha C_\alpha(s)\)</span> where <span class="math notranslate nohighlight">\(C_\alpha\)</span> are the clauses
of the problem, seen as <span class="math notranslate nohighlight">\(\{0, 1\}\)</span> valued functions
and <span class="math notranslate nohighlight">\(w_\alpha\)</span> their corresponding weights.</p>
<p>This encoding is done recursively and is described in the documentation of the
<a class="reference internal" href="#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a> class.</p>
<p>If the problem is specified as a maximization problem, the sign of the cost
Hamiltonian if flipped.
This means that the “best” solution is always encoded in the ground state of the returned
Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a cost Hamiltonian</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.CombinatorialProblem.new_var">
<span class="sig-name descname"><span class="pre">new_var</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.CombinatorialProblem.new_var" title="Permalink to this definition"></a></dt>
<dd><p>Returns a fresh variable</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a fresh variable</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.opt.boolexpr.Var" title="qat.opt.boolexpr.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.CombinatorialProblem.new_vars">
<span class="sig-name descname"><span class="pre">new_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbvars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.CombinatorialProblem.new_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of fresh variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nbvars</strong> (<em>int</em>) – the number of fresh variables to declare</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of fresh variables of length <cite>nbvars</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>list</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.CombinatorialProblem.to_ising">
<span class="sig-name descname"><span class="pre">to_ising</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.CombinatorialProblem.to_ising" title="Permalink to this definition"></a></dt>
<dd><p>Translates the problem into an Ising problem. Might raise an exception
if the problem is not quadratic.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an Ising object</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.CombinatorialProblem.to_qubo">
<span class="sig-name descname"><span class="pre">to_qubo</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.CombinatorialProblem.to_qubo" title="Permalink to this definition"></a></dt>
<dd><p>Translates the problem into a QUBO problem. Might raise an exception
if the problem is not quadratic.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a QUBO object</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<p>Clauses (<a class="reference internal" href="#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a>) are declared by combining variables (<a class="reference internal" href="#qat.opt.boolexpr.Var" title="qat.opt.boolexpr.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a>). The cost Hamiltonian extraction is handled by the
(<a class="reference internal" href="#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a>) class. The final cost Hamiltonian consists of the weighted sum of the cost Hamiltonian of its clauses.</p>
<div class="toggle-header docutils container">
<p><strong>Clause</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.boolexpr.Clause">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.boolexpr.</span></span><span class="sig-name descname"><span class="pre">Clause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arity</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">children</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.boolexpr.Clause" title="Permalink to this definition"></a></dt>
<dd><p>Class representing a boolean clause (boolean formula).</p>
<p>Clauses are trees whose leaves are <a class="reference internal" href="#qat.opt.boolexpr.Var" title="qat.opt.boolexpr.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a> objects and internal nodes
are labelled by boolean operators (&amp;, |, ^, ~).</p>
<p>Clauses are meant to be built either using the <cite>.and_clause</cite>, <cite>.or_clause</cite>,
<cite>.xor_clause</cite>, <cite>neg_clause</cite> static methods, or via boolean operators
overloading:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<em>str</em>) – the operator (in [”&amp;”, “|”, “^”, “~”])</p></li>
<li><p><strong>arity</strong> (<em>int</em>) – the arity of the operator</p></li>
<li><p><strong>*children</strong> (<a class="reference internal" href="#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a>) – the subclauses</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.boolexpr.Clause.get_observable">
<span class="sig-name descname"><span class="pre">get_observable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.boolexpr.Clause.get_observable" title="Permalink to this definition"></a></dt>
<dd><p>Returns a boolean valued diagonal cost observable matching the evaluation
of the clause.</p>
<p>The cost observable is built by induction:</p>
<p><span class="math notranslate nohighlight">\(H(A \wedge B) = H(A) H(B)\)</span></p>
<p><span class="math notranslate nohighlight">\(H(A \vee B) = H(A) + H(B) - H(A) H(B)\)</span></p>
<p><span class="math notranslate nohighlight">\(H(A \oplus B) = H(A) + H(B) - 2 H(A) H(B)\)</span></p>
<p><span class="math notranslate nohighlight">\(H(\neg A) = 1 - H(A)\)</span></p>
<p><span class="math notranslate nohighlight">\(H(v) = (1 - \sigma_z^v)/2\)</span></p>
<p>Consequently: the resulting Hamiltonian is {0, 1} valued and has
as 1-eigenstates the states that satisfy the clause.</p>
</dd></dl>

</dd></dl>

</div>
<p>The variable class is quite simple and overloads logical operators to closely interact with the <cite>Clause</cite> class:</p>
<div class="toggle-header docutils container">
<p><strong>Var</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.boolexpr.Var">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.boolexpr.</span></span><span class="sig-name descname"><span class="pre">Var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.boolexpr.Var" title="Permalink to this definition"></a></dt>
<dd><p>Simple class for boolean variables</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="qat.opt.boolexpr.Var.index">
<span class="sig-name descname"><span class="pre">index</span></span><a class="headerlink" href="#qat.opt.boolexpr.Var.index" title="Permalink to this definition"></a></dt>
<dd><p>the variable index (unique identifier)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – the variable index</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.boolexpr.Var.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assignment</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.boolexpr.Var.evaluate" title="Permalink to this definition"></a></dt>
<dd><p>Returns the boolean value of the variable in an assignment list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>assignment</strong> (<em>list&lt;bool&gt;</em>) – A list of boolean representing
the value of each variables</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The result of the evaluation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.boolexpr.Var.get_observable">
<span class="sig-name descname"><span class="pre">get_observable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.boolexpr.Var.get_observable" title="Permalink to this definition"></a></dt>
<dd><p>Returns a boolean valued diagonal cost observable matching the evaluation
of the variable: <span class="math notranslate nohighlight">\((1 - \sigma_z^i) / 2\)</span> where <span class="math notranslate nohighlight">\(i\)</span> is the index of the
variable.</p>
<p>The observable will act upon self.index + 1 qubits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.boolexpr.Var.get_variables">
<span class="sig-name descname"><span class="pre">get_variables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.boolexpr.Var.get_variables" title="Permalink to this definition"></a></dt>
<dd><p>Returns a singleton with the index of the variable</p>
</dd></dl>

</dd></dl>

</div>
</section>
<section id="quadratic-problems-qubo-and-ising">
<span id="qubo-and-ising-code"></span><h3>Quadratic problems: QUBO and Ising<a class="headerlink" href="#quadratic-problems-qubo-and-ising" title="Permalink to this heading"></a></h3>
<div class="toggle-header docutils container">
<p><strong>QUBO</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.QUBO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.</span></span><span class="sig-name descname"><span class="pre">QUBO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.QUBO" title="Permalink to this definition"></a></dt>
<dd><p>Class representing Quadratic Unconstrained Binary Optimization
(<a class="reference internal" href="combinatorial_optimization_intro.html#formulating-comb"><span class="std std-ref">QUBO</span></a>) problems.</p>
<p>The class allows for the representation of a problem as QUBO - by providing
with a symmetric <span class="math notranslate nohighlight">\(Q\)</span> matrix and a QUBO offset energy <span class="math notranslate nohighlight">\(E_Q\)</span>, both
of which coming from the respective Hamiltonian encoding,</p>
<div class="math notranslate nohighlight">
\[H = - x^T Q x - E_Q\]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is the vector of binary values <span class="math notranslate nohighlight">\(\{0,1\}\)</span> we look for,
such that <span class="math notranslate nohighlight">\(H\)</span> is minimum.</p>
<p>The class can also translate from a QUBO problem to an Ising problem via
<a class="reference internal" href="#qat.opt.QUBO.to_ising" title="qat.opt.QUBO.to_ising"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_ising()</span></code></a> by returning an Ising object.</p>
<p>QUBO problems can be translated to a <a class="reference internal" href="#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a>
object via <a class="reference internal" href="#qat.opt.QUBO.to_combinatorial_problem" title="qat.opt.QUBO.to_combinatorial_problem"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_combinatorial_problem()</span></code></a>.</p>
<p>This class also inherits from the <a class="reference internal" href="#qat.opt.circuit_generator.CircuitGenerator" title="qat.opt.circuit_generator.CircuitGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">CircuitGenerator</span></code></a>
class which allows to construct QAOA-Ansätze.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<em>2D numpy array</em>) – a symmetric array representing the <span class="math notranslate nohighlight">\(Q\)</span> matrix from
the Hamiltonian of the problem</p></li>
<li><p><strong>offset_q</strong> (<em>optional</em><em>, </em><em>double</em>) – the value of the QUBO offset energy in
the Hamiltonian of the problem</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.QUBO.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.QUBO.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <strong>quantum</strong> annealing (SQA) of the
respective QUBO problem. SQA is available in QLM, but the temperature parameters
<em>temp_max</em> and <em>temp_min</em> could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>), available in myQLM.</p>
<p>The method should be called from one of the child problem classes
(e.g. GraphColouring, VertexCover, etc.) and not directly from the parent
QUBO class as this will raise an exception.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.QUBO.get_observable">
<span class="sig-name descname"><span class="pre">get_observable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.QUBO.get_observable" title="Permalink to this definition"></a></dt>
<dd><p>Returns an Observable for the problem containing an Ising tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an Ising Observable representing the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.QUBO.get_q_and_offset">
<span class="sig-name descname"><span class="pre">get_q_and_offset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.QUBO.get_q_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>This method returns the <span class="math notranslate nohighlight">\(Q\)</span> matrix and QUBO energy offset,
which define the QUBO object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p><strong>Q</strong> (<em>2D numpy array</em>) - a symmetric array representing the <span class="math notranslate nohighlight">\(Q\)</span> matrix
from the Hamiltonian of the problem</p></li>
<li><p><strong>offset_q</strong> (<em>double</em>) - the value of the QUBO offset energy in the
Hamiltonian of the problem</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.QUBO.to_combinatorial_problem">
<span class="sig-name descname"><span class="pre">to_combinatorial_problem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.QUBO.to_combinatorial_problem" title="Permalink to this definition"></a></dt>
<dd><p>Translates the QUBO problem into a combinatorial problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a combinatorial problem instance</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.QUBO.to_ising">
<span class="sig-name descname"><span class="pre">to_ising</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.QUBO.to_ising" title="Permalink to this definition"></a></dt>
<dd><p>Translates the QUBO problem into an Ising problem over spins.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an Ising instance</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.QUBO.to_job">
<span class="sig-name descname"><span class="pre">to_job</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.QUBO.to_job" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Job for the problem - ready to run on a QPU for simulated annealing (<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>)
or simulated quantum anealing (SQA). The second one comes in the QLM.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p><strong>tmax</strong> (<em>float, optional</em>) - time duration of the annealing. Default is 1.</p></li>
<li><p><strong>gamma_t</strong> (<a class="reference internal" href="qat-core.html#qat.core.variables.ArithExpression" title="qat.core.variables.ArithExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArithExpression</span></code></a>, <em>SQA only</em>) - a function specifying
the time dependence of Gamma. It should be produced using the variable ‘t’ created by
the class <a class="reference internal" href="qat-core.html#qat.core.Variable" title="qat.core.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a ready to run Job for the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">Job</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the supported NP problems, some well performing max and min Gamma for a linearly decreasing
gamma_t have been found and could be accessed via the method <code class="code docutils literal notranslate"><span class="pre">get_best_parameters</span></code> of the
respective problem class.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="toggle-header docutils container">
<p><strong>Ising</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.Ising">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.</span></span><span class="sig-name descname"><span class="pre">Ising</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_i</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.Ising" title="Permalink to this definition"></a></dt>
<dd><p>Class representing <a class="reference internal" href="combinatorial_optimization_intro.html#formulating-comb"><span class="std std-ref">Ising</span></a> problems.</p>
<p>The class allows for the representation of a problem in the Ising framework - by providing
with a symmetric coupling matrix <span class="math notranslate nohighlight">\(J\)</span> with zero diagonal elements, magnetic field <span class="math notranslate nohighlight">\(h\)</span>
and an Ising offset energy <span class="math notranslate nohighlight">\(E_I\)</span>, all of which coming from the respective Hamiltonian
encoding,</p>
<div class="math notranslate nohighlight">
\[H = - s^T J s - h^T s - E_I\]</div>
<p>where <span class="math notranslate nohighlight">\(s\)</span> is the spin vector we look for with values <span class="math notranslate nohighlight">\(\{-1,1\}\)</span>,
such that <span class="math notranslate nohighlight">\(H\)</span> is minimum.</p>
<p>The class can also translate from an Ising problem to a QUBO problem through
<a class="reference internal" href="#qat.opt.Ising.to_qubo" title="qat.opt.Ising.to_qubo"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_qubo()</span></code></a> by returning a <a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> object.</p>
<p>Ising problems can be translated to a <a class="reference internal" href="#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a>
object via <a class="reference internal" href="#qat.opt.Ising.to_combinatorial_problem" title="qat.opt.Ising.to_combinatorial_problem"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_combinatorial_problem()</span></code></a>.</p>
<p>Similarly to QUBO and CombinatorialProblem, this class inherits from the
<a class="reference internal" href="#qat.opt.circuit_generator.CircuitGenerator" title="qat.opt.circuit_generator.CircuitGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">CircuitGenerator</span></code></a> class, thus is able to generate
QAOA-Ansätze.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>2D numpy array</em>) – a symmetric array with zero diagonal elements for the coupling between
each two spins - it represents the <span class="math notranslate nohighlight">\(J\)</span> matrix from the Hamiltonian of the problem</p></li>
<li><p><strong>h</strong> (<em>1D numpy array</em>) – an array with the magnetic field acting on each of the spins,
coming from the Hamiltonian of the problem</p></li>
<li><p><strong>offset_i</strong> (<em>optional</em><em>, </em><em>double</em>) – the value of the Ising offset energy in the
respective Hamiltonian</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.Ising.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.Ising.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <strong>quantum</strong> annealing (SQA) of the
respective Ising problem. SQA is available in QLM, but the temperature parameters
<em>temp_max</em> and <em>temp_min</em> could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>), available in myQLM.</p>
<p>The method should be called from one of the child problem classes (e.g. MaxCut,
NumberPartitioning, etc.) and not directly from the parent Ising class as this
will raise an exception.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.Ising.get_j_h_and_offset">
<span class="sig-name descname"><span class="pre">get_j_h_and_offset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.Ising.get_j_h_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>This method returns the <span class="math notranslate nohighlight">\(J\)</span> coupling matrix, the magnetic field <span class="math notranslate nohighlight">\(h\)</span> and Ising
energy offset, which define the Ising object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>3-element tuple containing</p>
<ul class="simple">
<li><p><strong>J</strong> (<em>2D numpy array</em>) - a symmetric array with zero diagonal elements for the
coupling between each two spins - it represents the <span class="math notranslate nohighlight">\(J\)</span> matrix from the
Hamiltonian of the problem</p></li>
<li><p><strong>h</strong> (<em>1D numpy array</em>) - an array with the magnetic field acting on each of the
spins, coming from the Hamiltonian of the problem</p></li>
<li><p><strong>offset_i</strong> (<em>double</em>) - the value of the Ising offset energy in the respective
Hamiltonian</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.Ising.get_observable">
<span class="sig-name descname"><span class="pre">get_observable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.Ising.get_observable" title="Permalink to this definition"></a></dt>
<dd><p>Returns an Observable for the problem containing an Ising tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an Ising Observable representing the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.Ising.to_combinatorial_problem">
<span class="sig-name descname"><span class="pre">to_combinatorial_problem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.Ising.to_combinatorial_problem" title="Permalink to this definition"></a></dt>
<dd><p>Translates the Ising problem into a CombinatorialProblem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a combinatorial problem instance</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.Ising.to_job">
<span class="sig-name descname"><span class="pre">to_job</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.Ising.to_job" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Job for the problem - ready to run on a QPU for simulated annealing (<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>)
or simulated quantum anealing (SQA). The second one comes in the QLM.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p><strong>tmax</strong> (<em>float, optional</em>) - time duration of the annealing. Default is 1.</p></li>
<li><p><strong>gamma_t</strong> (<a class="reference internal" href="qat-core.html#qat.core.variables.ArithExpression" title="qat.core.variables.ArithExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArithExpression</span></code></a>, <em>SQA only</em>) - a function specifying
the time dependence of Gamma. It should be produced using the variable ‘t’ created by
the class <a class="reference internal" href="qat-core.html#qat.core.Variable" title="qat.core.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a ready to run Job for the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">Job</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the supported NP problems, some well performing max and min Gamma for a linearly decreasing
gamma_t have been found and could be accessed via the method <code class="code docutils literal notranslate"><span class="pre">get_best_parameters</span></code> of the
respective problem class.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.Ising.to_qubo">
<span class="sig-name descname"><span class="pre">to_qubo</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.Ising.to_qubo" title="Permalink to this definition"></a></dt>
<dd><p>Translates the Ising problem into a QUBO problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a QUBO object</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</section>
</section>
<section id="generating-the-qaoa-ansatz">
<h2>Generating the QAOA Ansatz<a class="headerlink" href="#generating-the-qaoa-ansatz" title="Permalink to this heading"></a></h2>
<p>The Quantum Approximate Optimization Algorithms is a heuristics to design variational Ansätze for combinatorial optimization. It is inspired from the digitalization of an analog evolution using a linear ramp, starting from a simple initial Hamiltonian <span class="math notranslate nohighlight">\(H_0 = - \sum_i \sigma_x^i\)</span> to a diagonal Hamiltonian whose ground state encodes the solution to our problem.
This digitalization leads to a layered parametrized quantum circuit consisting of entangling layers sperated by collective <span class="math notranslate nohighlight">\(R_X\)</span> rotations.</p>
<p>QAOA Ansätze are usually parametrized by a <cite>depth</cite> parameter specifying the number of alternating layers.</p>
<p>It is possible to directly generate ready to run QAOA jobs (containing an Ansatz and the target Hamiltonian) from an instance
of <a class="reference internal" href="#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.CombinatorialProblem</span></code></a>/<a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.QUBO</span></code></a>/<a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.Ising</span></code></a> instance via the following interface:</p>
<div class="toggle-header docutils container">
<p><strong>Circuit Generator</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.circuit_generator.CircuitGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.circuit_generator.</span></span><span class="sig-name descname"><span class="pre">CircuitGenerator</span></span><a class="headerlink" href="#qat.opt.circuit_generator.CircuitGenerator" title="Permalink to this definition"></a></dt>
<dd><p>Class for circuit generation interface from a diagonal observable.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.circuit_generator.CircuitGenerator.qaoa_ansatz">
<span class="sig-name descname"><span class="pre">qaoa_ansatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cnots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coloring'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_circ_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.circuit_generator.CircuitGenerator.qaoa_ansatz" title="Permalink to this definition"></a></dt>
<dd><p>Generates a QAOA Ansatz using the cost observable returned
by the abstract method <code class="code docutils literal notranslate"><span class="pre">get_observable</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When setting the <cite>cnots</cite> option to False, the circuit might make
use of generalized many-qubits Z rotations. In that case,
you might want to instantiate your variational plugins using
a gate set that contains definition of these gates. If not,
some matrices in the circuit structure
will be missing and some QPUs may not be able to handle the circuit.</p>
<p>The following piece of code should allow you to link the correct gate
set to a variational plugin:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.plugins</span> <span class="kn">import</span> <span class="n">ScipyMinimizePlugin</span>
<span class="kn">from</span> <span class="nn">qat.vsolve.ansatz</span> <span class="kn">import</span> <span class="n">get_qaoa_gate_set</span>

<span class="c1"># This plugin will no be able to bind variables inside a</span>
<span class="c1"># job generated with cnot set to False!</span>
<span class="n">my_plugin</span> <span class="o">=</span> <span class="n">ScipyMinimizePlugin</span><span class="p">()</span>

<span class="c1"># This plugin can now be used with job generated with the</span>
<span class="c1"># cnots option sets to False!</span>
<span class="n">my_plugin</span> <span class="o">=</span> <span class="n">ScipyMinimizePlugin</span><span class="p">(</span><span class="n">gate_set</span><span class="o">=</span><span class="n">get_qaoa_gate_set</span><span class="p">())</span>
</pre></div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>depth</strong> (<em>int</em>) – the depth of the Ansatz</p></li>
<li><p><strong>strategy</strong> (<em>str</em>) – the strategy to adopt to generate the circuit. Possible
strategies are “default” or “coloring”. The “coloring” strategy uses
a greedy coloring heuristics to try to optimize the overall depth of the
Ansatz. Default is “default” which synthesize the circuit without optimizing
the term ordering.</p></li>
<li><p><strong>cnots</strong> (<em>optional</em><em>, </em><em>bool</em>) – If set to True the Ansatz will only use CNOT
gates. If set to False, some abstract gates will be used to
generate collective pauli rotations, resulting in a lower gate count.
Defaults to True.</p></li>
<li><p><strong>**kwargs</strong> – optional arguments that will be transfered to the
job’s constructor (e.g nbshots, etc).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a qlm job, ready to run</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">Job</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<p>The <a class="reference internal" href="#qat.vsolve.ansatz.AnsatzFactory" title="qat.vsolve.ansatz.AnsatzFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.vsolve.ansatz.AnsatzFactory</span></code></a> provides a recipe to produce such a variational circuits from a target Hamiltonian.</p>
<div class="toggle-header docutils container">
<p><strong>Ansatz Factory</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.vsolve.ansatz.AnsatzFactory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.vsolve.ansatz.</span></span><span class="sig-name descname"><span class="pre">AnsatzFactory</span></span><a class="headerlink" href="#qat.vsolve.ansatz.AnsatzFactory" title="Permalink to this definition"></a></dt>
<dd><p>This class regroups the implementation all the different Ansätze available
in the QLM.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.vsolve.ansatz.AnsatzFactory.qaoa_circuit">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qaoa_circuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cnots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">to_circ_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.vsolve.ansatz.AnsatzFactory.qaoa_circuit" title="Permalink to this definition"></a></dt>
<dd><p>Generates a QAOA Ansatz from an observable and an Ansatz depth</p>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.vsolve.ansatz</span> <span class="kn">import</span> <span class="n">AnsatzFactory</span>

<span class="n">line_obs</span> <span class="o">=</span> <span class="n">Observable</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
    <span class="n">line_obs</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;ZZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">ansatz_with_cnots</span> <span class="o">=</span> <span class="n">AnsatzFactory</span><span class="o">.</span><span class="n">qaoa_circuit</span><span class="p">(</span><span class="n">line_obs</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Ansatz has </span><span class="si">{}</span><span class="s2"> gates&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ansatz_with_cnots</span><span class="o">.</span><span class="n">ops</span><span class="p">)))</span>
<span class="n">ansatz_with_rzz</span> <span class="o">=</span> <span class="n">AnsatzFactory</span><span class="o">.</span><span class="n">qaoa_circuit</span><span class="p">(</span><span class="n">line_obs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">cnots</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Ansatz has </span><span class="si">{}</span><span class="s2"> gates&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ansatz_with_rzz</span><span class="o">.</span><span class="n">ops</span><span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">Ansatz</span> <span class="n">has</span> <span class="mi">121</span> <span class="n">gates</span>
<span class="n">The</span> <span class="n">Ansatz</span> <span class="n">has</span> <span class="mi">67</span> <span class="n">gates</span>
</pre></div>
</div>
<p>The synthesis strategy may influence the depth of the circuit:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="n">circuit</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Computes the depth of a circuit &#39;&#39;&#39;</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">circuit</span><span class="p">:</span>
        <span class="n">qbits</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">qbits</span>
        <span class="n">insert_in</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">slic</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">slices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">qb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">slic</span> <span class="k">for</span> <span class="n">qb</span> <span class="ow">in</span> <span class="n">qbits</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">insert_in</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">insert_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qb</span> <span class="ow">in</span> <span class="n">qbits</span><span class="p">:</span>
                <span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">insert_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">qbits</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qb</span> <span class="ow">in</span> <span class="n">qbits</span><span class="p">:</span>
                <span class="n">slices</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">-</span> <span class="n">insert_in</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.vsolve.ansatz</span> <span class="kn">import</span> <span class="n">AnsatzFactory</span>

<span class="n">line_obs</span> <span class="o">=</span> <span class="n">Observable</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
    <span class="n">line_obs</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;ZZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">ansatz_default</span> <span class="o">=</span> <span class="n">AnsatzFactory</span><span class="o">.</span><span class="n">qaoa_circuit</span><span class="p">(</span><span class="n">line_obs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Ansatz has depth </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">(</span><span class="n">ansatz_default</span><span class="p">)))</span>
<span class="n">ansatz_coloring</span> <span class="o">=</span> <span class="n">AnsatzFactory</span><span class="o">.</span><span class="n">qaoa_circuit</span><span class="p">(</span><span class="n">line_obs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;coloring&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The Ansatz has depth </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">(</span><span class="n">ansatz_coloring</span><span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">Ansatz</span> <span class="n">has</span> <span class="n">depth</span> <span class="mi">43</span>
<span class="n">The</span> <span class="n">Ansatz</span> <span class="n">has</span> <span class="n">depth</span> <span class="mi">22</span>
</pre></div>
</div>
<p>When considering QAOA instances with large Clauses (i.e clauses with more than 2 variables),
the “gray_synth” strategy can often remove lots of CNOTS:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cnot_count</span><span class="p">(</span><span class="n">circuit</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; count cnots in a circuit &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;CNOT&quot;</span> <span class="k">else</span> <span class="mi">0</span>
               <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">qbits</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">iterate_simple</span><span class="p">())</span>

<span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.vsolve.ansatz</span> <span class="kn">import</span> <span class="n">AnsatzFactory</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">line_obs</span> <span class="o">=</span> <span class="n">Observable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">line_obs</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;ZZZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]))</span>

<span class="n">ansatz_default</span> <span class="o">=</span> <span class="n">AnsatzFactory</span><span class="o">.</span><span class="n">qaoa_circuit</span><span class="p">(</span><span class="n">line_obs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>
<span class="n">ansatz_gray_synth</span> <span class="o">=</span> <span class="n">AnsatzFactory</span><span class="o">.</span><span class="n">qaoa_circuit</span><span class="p">(</span><span class="n">line_obs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;gray_synth&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cnot count in default:&quot;</span><span class="p">,</span> <span class="n">cnot_count</span><span class="p">(</span><span class="n">ansatz_default</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cnot count in gray synth:&quot;</span><span class="p">,</span> <span class="n">cnot_count</span><span class="p">(</span><span class="n">ansatz_gray_synth</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cnot</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">default</span><span class="p">:</span> <span class="mi">36</span>
<span class="n">Cnot</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">gray</span> <span class="n">synth</span><span class="p">:</span> <span class="mi">24</span>
</pre></div>
</div>
<p>Synthesis strategies:</p>
<blockquote>
<div><ul class="simple">
<li><p>default: uses the default term ordering provided by the input observable</p></li>
<li><p>coloring: orders terms using a graph coloring technique in order to
reduce circuit depth</p></li>
<li><p>gray_synth: uses Amy et al GraySynth algorithm to synthesize the entangling
layer. This might help in reducing the overall CNOT count.</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observable</strong> (<a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>) – some diagonal observable</p></li>
<li><p><strong>depth</strong> (<em>int</em>) – the depth of the Ansatz</p></li>
<li><p><strong>strategy</strong> (<em>str</em>) – the strategy to adopt to generate the circuit.</p></li>
<li><p><strong>cnots</strong> (<em>optional</em><em>, </em><em>bool</em>) – if set to True, the generator will onlt use CNOT gates
as entangling gates. Default to True. This argument is ignored for some strategies.</p></li>
<li><p><strong>**to_circ_args</strong> – arguments passed to the to_circ method</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</section>
<section id="generating-qa-jobs">
<h2>Generating QA jobs<a class="headerlink" href="#generating-qa-jobs" title="Permalink to this heading"></a></h2>
<p>It is possible to turn <a class="reference internal" href="#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.CombinatorialProblem</span></code></a>/<a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.QUBO</span></code></a>/<a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.Ising</span></code></a> into Quantum Annealing jobs thanks to the <a class="reference internal" href="#qat.opt.schedule_generator.ScheduleGenerator" title="qat.opt.schedule_generator.ScheduleGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScheduleGenerator</span></code></a> interface:</p>
<div class="toggle-header docutils container">
<p><strong>Schedule Generator</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.schedule_generator.ScheduleGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.schedule_generator.</span></span><span class="sig-name descname"><span class="pre">ScheduleGenerator</span></span><a class="headerlink" href="#qat.opt.schedule_generator.ScheduleGenerator" title="Permalink to this definition"></a></dt>
<dd><p>Interface for problems that can be solved by a quantum annealing.</p>
<p>It requires the implementation of method that returns an Hamiltonian
formulation of the target cost function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.schedule_generator.ScheduleGenerator.annealing_job">
<span class="sig-name descname"><span class="pre">annealing_job</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mixing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.schedule_generator.ScheduleGenerator.annealing_job" title="Permalink to this definition"></a></dt>
<dd><p>Generates a Quantum Annealing job performing a linear interpolation
between an initial mixing Hamiltonian and the problem’s Hamiltonian.</p>
</dd></dl>

</dd></dl>

</div>
<p>Mixing Hamiltonians can be generated through the <a class="reference internal" href="#qat.opt.MixingFactory" title="qat.opt.MixingFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.MixingFactory</span></code></a>:</p>
<div class="toggle-header docutils container">
<p><strong>Mixing Factory</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.MixingFactory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.</span></span><span class="sig-name descname"><span class="pre">MixingFactory</span></span><a class="headerlink" href="#qat.opt.MixingFactory" title="Permalink to this definition"></a></dt>
<dd><p>A factory to define problem independent mixing Hamiltonians
(i.e initial Hamiltonians in quantum annealing schedules).</p>
<p>All methods generate object implementing the <a class="reference internal" href="#qat.opt.mixing_factory.InitialStateBuilder" title="qat.opt.mixing_factory.InitialStateBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">InitialStateBuilder</span></code></a> interface
and returns a pair (such an object, mixing Hamiltonian).</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.MixingFactory.bit_flip">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bit_flip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restrict_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.MixingFactory.bit_flip" title="Permalink to this definition"></a></dt>
<dd><p>Builds a bit flip mixing Hamiltonian:</p>
<div class="math notranslate nohighlight">
\[H_0 = - \sum \sigma_x\]</div>
<p>Its ground state is the product state:</p>
<div class="math notranslate nohighlight">
\[|\psi_0\rangle = |+\rangle ^ {\otimes n}\]</div>
<p>and is returned in string format.</p>
<p>This is the standard Hamiltonian for most applications.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbits</strong> (<em>int</em>) – the number of qubits in the system</p></li>
<li><p><strong>restrict_to</strong> (<em>optional</em><em>, </em><em>list&lt;int&gt;</em>) – a possible list of qubits
to restrict the mixing to. If set, the sum over <span class="math notranslate nohighlight">\(\sigma_x\)</span> is
restricted to these qubits. The initial state of other qubits will be set
to <span class="math notranslate nohighlight">\(|0\rangle\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a pair (structure
preparing the initial state, mixing Hamiltonian).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="#qat.opt.mixing_factory.SimpleInitialState" title="qat.opt.mixing_factory.SimpleInitialState"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleInitialState</span></code></a>, <a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.MixingFactory.bit_move">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bit_move</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamming_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmax_psi_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.MixingFactory.bit_move" title="Permalink to this definition"></a></dt>
<dd><p>Builds a bit move mixing Hamiltonian that preserves
Hamming weight:</p>
<div class="math notranslate nohighlight">
\[H_0 = - \sum_{i, j} S_{i, j}\]</div>
<p>where <span class="math notranslate nohighlight">\(S_{i,j}\)</span> is the following two qubits operator located on qubits <span class="math notranslate nohighlight">\(i, j\)</span>:</p>
<div class="math notranslate nohighlight">
\[S_{i, j} = \frac{\sigma_y\otimes\sigma_y + \sigma_x\otimes\sigma_x}{2}\]</div>
<p>The main purpose of this mixing is to explore subset of bitstrings of constant Hamming weight.
In that regard, it is important to start from an appropriate initial state that corresponds to the
ground state of <span class="math notranslate nohighlight">\(H_0\)</span> restricted to the classical states of fixed Hamming weight <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>This ground state is the equi-superposition of classical states of Hamming weight <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="math notranslate nohighlight">
\[|\psi_0\rangle = {n \choose k}^{-\frac{1}{2}} \sum_{x} |x\rangle\]</div>
<p>where the sum ranges over all bit-strings <span class="math notranslate nohighlight">\(x\)</span> of Hamming weight <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>When using a simulator, one can prepare this state using a numpy array (which is fine for small number of qubits).</p>
<p>In real use cases, it is possible to approximate this state by performing a problem independent annealing
using:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}H'_0 = - \sum_i \sigma_x^i\\|\psi'_0\rangle = |+\rangle ^{\otimes n}\end{aligned}\end{align} \]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[H'_1 = \left(\sum_i \frac{1 - \sigma_z^i}{2} - k\right)^2\]</div>
<p>The ground state of <span class="math notranslate nohighlight">\(H'_1\)</span> is exactly the state <span class="math notranslate nohighlight">\(|\psi_0\rangle\)</span>.
Moreover, it is argued in <span id="id1">[]</span> that the min-gap of this evolution is located close to the
end of the evolution and that its width is a <span class="math notranslate nohighlight">\(O(\frac{1}{T})\)</span>. In particular, this entails that one
can pick a polynomially large <span class="math notranslate nohighlight">\(T\)</span> and be sure to build a large overlap between the state of our system
and the perfect <span class="math notranslate nohighlight">\(|\psi_0\rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbits</strong> (<em>int</em>) – the number of qubits in the system</p></li>
<li><p><strong>hamming_weight</strong> (<em>int</em>) – the Hamming weight of the bit strings to mix</p></li>
<li><p><strong>exact</strong> (<em>optional</em><em>, </em><em>bool</em>) – if set to True, the initial state will be described using
a numpy array (which is not a scalable solution, but is faster and simpler for small systems).</p></li>
<li><p><strong>tmax_psi_0</strong> (<em>optional</em><em>, </em><em>float</em>) – the tmax for the first annealing (in the case of an inexact preparation).
Default to 50.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">MixingFactory</span>

<span class="c1"># Mixes bit-strings of length 10 and Hamming weight 5</span>
<span class="c1"># This generates a numpy array of length 2^10 to describe the initial state (be careful :))</span>
<span class="n">mixing</span> <span class="o">=</span> <span class="n">MixingFactory</span><span class="o">.</span><span class="n">bit_move</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1"># Mixes bit-strings of length 10 and Hamming weight 5</span>
<span class="c1"># and prepares the initial state via a problem independent annealing</span>
<span class="n">mixing</span> <span class="o">=</span> <span class="n">MixingFactory</span><span class="o">.</span><span class="n">bit_move</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># Mixes bit-strings of length 10 and Hamming weight 5</span>
<span class="c1"># and prepares the initial state via a problem independent annealing</span>
<span class="c1"># of duration 70</span>
<span class="n">mixing</span> <span class="o">=</span> <span class="n">MixingFactory</span><span class="o">.</span><span class="n">bit_move</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmax_psi_0</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;stdin&gt;:5: DeprecationWarning: `np.complex` is a deprecated alias for the builtin `complex`. To silence this warning, use `complex` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.complex128` here.
Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a pair (structure
preparing the initial state, mixing Hamiltonian). The return type of the first entry depends on the
<cite>exact</cite> parameter.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(<a class="reference internal" href="#qat.opt.mixing_factory.SimpleInitialState" title="qat.opt.mixing_factory.SimpleInitialState"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleInitialState</span></code></a>/<a class="reference internal" href="#qat.opt.mixing_factory.IndependentAnnealing" title="qat.opt.mixing_factory.IndependentAnnealing"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndependentAnnealing</span></code></a>, <a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<p>You can also define you own mixing by creating a class that implements the following (very straightforward) interface:</p>
<div class="toggle-header docutils container">
<p><strong>Initial State Builder</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.mixing_factory.InitialStateBuilder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.mixing_factory.</span></span><span class="sig-name descname"><span class="pre">InitialStateBuilder</span></span><a class="headerlink" href="#qat.opt.mixing_factory.InitialStateBuilder" title="Permalink to this definition"></a></dt>
<dd><p>A concept for an object that can modify an analog job in order to
inject some particular initial state in the computation.</p>
<p>This interface requires implementation of a single method <cite>inject_initial_state</cite> that
can modify a <a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">Job</span></code></a> object in order to setup the correct initial state
for a quantum annealing.</p>
<p>This method might simply modify the <cite>psi_0</cite> field of the job, or prepend instructions to the
job’s schedule.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.mixing_factory.InitialStateBuilder.inject_initial_state">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inject_initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">annealing_job</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.mixing_factory.InitialStateBuilder.inject_initial_state" title="Permalink to this definition"></a></dt>
<dd><p>Modifies in place an annealing job in order to prepare a particular initial state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>annealing_job</strong> (<a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Job</span></code></a>) – the job to modify</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<p>This interface is used by the following specializations:</p>
<div class="toggle-header docutils container">
<p><strong>Simple Initial State</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.mixing_factory.SimpleInitialState">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.mixing_factory.</span></span><span class="sig-name descname"><span class="pre">SimpleInitialState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psi_0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.mixing_factory.SimpleInitialState" title="Permalink to this definition"></a></dt>
<dd><p>A very simple initial state builder that simply forces the initial state to some value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>psi_0</strong> (<em>str</em><em>, </em><em>numpy.ndarray</em>) – the initial state to prepare</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.mixing_factory.SimpleInitialState.inject_initial_state">
<span class="sig-name descname"><span class="pre">inject_initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">annealing_job</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.mixing_factory.SimpleInitialState.inject_initial_state" title="Permalink to this definition"></a></dt>
<dd><p>Modifies in place an annealing job in order to prepare a particular initial state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>annealing_job</strong> (<a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Job</span></code></a>) – the job to modify</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="toggle-header docutils container">
<p><strong>Independent Annealing</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.mixing_factory.IndependentAnnealing">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.mixing_factory.</span></span><span class="sig-name descname"><span class="pre">IndependentAnnealing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_ham</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_ham</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_psi_0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.mixing_factory.IndependentAnnealing" title="Permalink to this definition"></a></dt>
<dd><p>An implementation of an <a class="reference internal" href="#qat.opt.mixing_factory.InitialStateBuilder" title="qat.opt.mixing_factory.InitialStateBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">InitialStateBuilder</span></code></a> that prepend a problem independent annealing
to the current annealing in order to prepare the correct initial state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_ham</strong> (<a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>) – the mixing Hamiltonian of the annealing</p></li>
<li><p><strong>end_ham</strong> (<a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>) – the target Hamiltonian of the annealing</p></li>
<li><p><strong>tmax</strong> (<em>float/expression</em>) – the annealing time (or a variable/expression)</p></li>
<li><p><strong>true_psi_0</strong> (<em>str/numpy.ndarray</em>) – the initial state of the initial annealing</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.mixing_factory.IndependentAnnealing.inject_initial_state">
<span class="sig-name descname"><span class="pre">inject_initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">annealing_job</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.mixing_factory.IndependentAnnealing.inject_initial_state" title="Permalink to this definition"></a></dt>
<dd><p>Modifies in place an annealing job in order to prepare a particular initial state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>annealing_job</strong> (<a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Job</span></code></a>) – the job to modify</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</section>
<section id="encoding-np-hard-problems">
<span id="np-hard-problems-code"></span><h2>Encoding NP-hard Problems<a class="headerlink" href="#encoding-np-hard-problems" title="Permalink to this heading"></a></h2>
<p>We present here classes for encoding some of the famous NP problems. An instrinsic feature of these problems is that they can be formulated as minimization or maximization problems, i.e. with a cost function. At the same time finding the lowest energy of a physical system, represented by a cost Hamiltonian, is also a minimization problem. Therefore, we can represent the cost function of an NP problem by a cost Hamiltonian. Such a Hamiltonian, given in an Ising form can then be annealed using Simulated Annealing (SA).</p>
<p>Furthermore, problems formulated as Quadratic Unconstrained Binary Optimisation (QUBO), can also be annealed, since we can translate them to Ising via our <a class="reference internal" href="#qat.opt.QUBO.to_ising" title="qat.opt.QUBO.to_ising"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_ising()</span></code></a> method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Simulated Quantum Annealing is not available in myQLM.
QUBO and Ising problems can still be used to construct QAOA
Ansätze using the <cite>.qaoa_ansatz</cite> method or solved via
<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">Simulated Annealing</span></a>.</p>
</div>
<section id="unconstrained-graph-problems">
<h3>Unconstrained Graph Problems<a class="headerlink" href="#unconstrained-graph-problems" title="Permalink to this heading"></a></h3>
<div class="toggle-header docutils container" id="maxcut">
<p><strong>Max Cut</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.max_cut.MaxCut">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.max_cut.</span></span><span class="sig-name descname"><span class="pre">MaxCut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.max_cut.MaxCut" title="Permalink to this definition"></a></dt>
<dd><p>Specialization of the <a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> class for Max Cut.</p>
<p>This class allows for the encoding of a Max Cut problem for a given graph.
The method <a class="reference internal" href="#qat.opt.max_cut.produce_j_h_and_offset" title="qat.opt.max_cut.produce_j_h_and_offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">produce_j_h_and_offset()</span></code></a> is automatically
called. It calculates the coupling matrix <span class="math notranslate nohighlight">\(J\)</span>, magnetic field <span class="math notranslate nohighlight">\(h\)</span>
and Ising energy offset corresponding to the Hamiltonian representation of
the problem, as described in the reference. These are stored in the parent
class <a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> and would be needed if one wishes to solve
the problem through Simulated Annealing (<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>),
for instance - see the <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Fmax_cut_myqlm.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">Max Cut notebook</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Reference</dt>
<dd class="field-odd"><p><a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_cut#Theoretical_physics">Maximum cut, Theoretical physics, Wikipedia</a>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">MaxCut</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">full_rary_tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span>

<span class="n">maxcut</span> <span class="o">=</span> <span class="n">MaxCut</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To anneal the problem, the solver would need &quot;</span>
      <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span> <span class="o">+</span> <span class="s2">&quot; spins.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">anneal</span> <span class="n">the</span> <span class="n">problem</span><span class="p">,</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">would</span> <span class="n">need</span> <span class="mi">256</span> <span class="n">spins</span><span class="o">.</span>
<span class="o">&lt;</span><span class="n">stdin</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span> <span class="ne">FutureWarning</span><span class="p">:</span> <span class="n">adjacency_matrix</span> <span class="n">will</span> <span class="k">return</span> <span class="n">a</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span> <span class="n">array</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">a</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">Networkx</span> <span class="mf">3.0</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.max_cut.MaxCut.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.max_cut.MaxCut.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <em>quantum</em> annealing (SQA), available
in the QLM. However, the temperature parameters could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>6-key dictionary containing</p>
<ul class="simple">
<li><p><strong>n_monte_carlo_updates</strong> (<em>int</em>) - the number of Monte Carlo updates</p></li>
<li><p><strong>n_trotters</strong> (<em>int</em>) - the number of “classical replicas” or “Trotter
replicas”</p></li>
<li><p><strong>gamma_max</strong> (<em>double</em>) - the starting magnetic field</p></li>
<li><p><strong>gamma_min</strong> (<em>double</em>) - the final magnetic field</p></li>
<li><p><strong>temp_max</strong> (<em>double</em>) - the starting temperature</p></li>
<li><p><strong>temp_min</strong> (<em>double</em>) - the final temperature</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.max_cut.MaxCut.parse_result">
<span class="sig-name descname"><span class="pre">parse_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.max_cut.MaxCut.parse_result" title="Permalink to this definition"></a></dt>
<dd><p>Returns the best approximated solution of the Max Cut problem from a list of samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>result</strong> (<a class="reference internal" href="qat-core.html#qat.core.BatchResult" title="qat.core.BatchResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchResult</span></code></a>) – BatchResult containing a list of samples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The best partition among the samples with the maximum cut size</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="combinatorial_optimization_generators_utils.html#qat.opt.results.GraphPartitioningResult" title="qat.opt.results.GraphPartitioningResult">GraphPartitioningResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.opt.max_cut.produce_j_h_and_offset">
<span class="sig-prename descclassname"><span class="pre">qat.opt.max_cut.</span></span><span class="sig-name descname"><span class="pre">produce_j_h_and_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.max_cut.produce_j_h_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(J\)</span> coupling matrix of the problem, along with the magnetic field <span class="math notranslate nohighlight">\(h\)</span> and the Ising energy offset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="toggle-header docutils container" id="graph-partitioning">
<p><strong>Graph Partitioning</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.graph_partitioning.GraphPartitioning">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.graph_partitioning.</span></span><span class="sig-name descname"><span class="pre">GraphPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.graph_partitioning.GraphPartitioning" title="Permalink to this definition"></a></dt>
<dd><p>Specialization of the <a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> class for Graph Partitioning.</p>
<p>This class allows for the encoding of a Graph Partitioning problem for a given graph.
The method <a class="reference internal" href="#qat.opt.graph_partitioning.produce_j_h_and_offset" title="qat.opt.graph_partitioning.produce_j_h_and_offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">produce_j_h_and_offset()</span></code></a> is automatically
called. It computes the coupling matrix <span class="math notranslate nohighlight">\(J\)</span>, magnetic field <span class="math notranslate nohighlight">\(h\)</span> and Ising
energy offset corresponding to the Hamiltonian representation of the problem, as described
in the reference. These are stored in the parent class <a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> and would
be needed if one wishes to solve the problem through Simulated Annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>), for instance - see the
<a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Fgraph_partitioning_myqlm.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">Graph Partitioning notebook</a>.</p>
<p>For right encoding we need <span class="math notranslate nohighlight">\(\frac { A } { B } \geq \frac { min(2D, N) } { 8 }\)</span> with
<span class="math notranslate nohighlight">\(D\)</span> - the maximal degree of a node in the graph and <span class="math notranslate nohighlight">\(N\)</span> - the number of nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Reference</dt>
<dd class="field-odd"><p><a class="reference external" href="https://arxiv.org/abs/1302.5843/">“Ising formulations of many NP problems”, A. Lucas, 2014 - Section 2.2</a>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">GraphPartitioning</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span>
                      <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">)])</span>

<span class="n">B</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">A</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">graph_partitioning_problem</span> <span class="o">=</span> <span class="n">GraphPartitioning</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To anneal the problem, the solver would need &quot;</span>
      <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span> <span class="o">+</span> <span class="s2">&quot; spins.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">anneal</span> <span class="n">the</span> <span class="n">problem</span><span class="p">,</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">would</span> <span class="n">need</span> <span class="mi">10</span> <span class="n">spins</span><span class="o">.</span>
<span class="o">&lt;</span><span class="n">stdin</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span> <span class="ne">FutureWarning</span><span class="p">:</span> <span class="n">adjacency_matrix</span> <span class="n">will</span> <span class="k">return</span> <span class="n">a</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span> <span class="n">array</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">a</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">Networkx</span> <span class="mf">3.0</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p></li>
<li><p><strong>A</strong> (<em>double</em>) – a positive constant by which the terms inside <span class="math notranslate nohighlight">\(H_A\)</span> from <span class="math notranslate nohighlight">\(H = H_A + H_B\)</span>
are multiplied. This equation comes from the Hamiltonian representation of the problem.</p></li>
<li><p><strong>B</strong> (<em>optional</em><em>, </em><em>double</em>) – similar to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> is a positive factor for the <span class="math notranslate nohighlight">\(H_B\)</span> terms, default is 1</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.graph_partitioning.GraphPartitioning.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.graph_partitioning.GraphPartitioning.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <em>quantum</em> annealing (SQA), available
in the QLM. However, the temperature parameters could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>6-key dictionary containing</p>
<ul class="simple">
<li><p><strong>n_monte_carlo_updates</strong> (<em>int</em>) - the number of Monte Carlo updates</p></li>
<li><p><strong>n_trotters</strong> (<em>int</em>) - the number of “classical replicas” or “Trotter
replicas”</p></li>
<li><p><strong>gamma_max</strong> (<em>double</em>) - the starting magnetic field</p></li>
<li><p><strong>gamma_min</strong> (<em>double</em>) - the final magnetic field</p></li>
<li><p><strong>temp_max</strong> (<em>double</em>) - the starting temperature</p></li>
<li><p><strong>temp_min</strong> (<em>double</em>) - the final temperature</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.graph_partitioning.GraphPartitioning.parse_result">
<span class="sig-name descname"><span class="pre">parse_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.graph_partitioning.GraphPartitioning.parse_result" title="Permalink to this definition"></a></dt>
<dd><p>Returns the best approximated solution of the Graph Partitioning problem from
a list of samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>result</strong> (<a class="reference internal" href="qat-core.html#qat.core.BatchResult" title="qat.core.BatchResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchResult</span></code></a>) – BatchResult containing a list of samples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The best balanced partition among the samples with the
minimum cut size</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="combinatorial_optimization_generators_utils.html#qat.opt.results.GraphPartitioningResult" title="qat.opt.results.GraphPartitioningResult">GraphPartitioningResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.opt.graph_partitioning.produce_j_h_and_offset">
<span class="sig-prename descclassname"><span class="pre">qat.opt.graph_partitioning.</span></span><span class="sig-name descname"><span class="pre">produce_j_h_and_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.graph_partitioning.produce_j_h_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(J\)</span> coupling matrix of the problem, along with the magnetic field
<span class="math notranslate nohighlight">\(h\)</span> and the Ising energy offset.
For right encoding we need <span class="math notranslate nohighlight">\(\frac{A}{B} \geq \frac{min(2D, N)}{8}\)</span> with
<span class="math notranslate nohighlight">\(D\)</span> - the maximal degree of a node in the graph and <span class="math notranslate nohighlight">\(N\)</span> - the number of nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p></li>
<li><p><strong>A</strong> (<em>double</em>) – a positive constant by which the terms inside <span class="math notranslate nohighlight">\(H_A\)</span> from <span class="math notranslate nohighlight">\(H = H_A + H_B\)</span>
are multiplied. This equation comes from the Hamiltonian representation of the problem.</p></li>
<li><p><strong>B</strong> (<em>optional</em><em>, </em><em>double</em>) – similar to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> is a positive factor for the <span class="math notranslate nohighlight">\(H_B\)</span> terms, default is 1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="constrained-graph-problems">
<h3>Constrained Graph Problems<a class="headerlink" href="#constrained-graph-problems" title="Permalink to this heading"></a></h3>
<div class="toggle-header docutils container" id="colouring">
<p><strong>Graph Colouring</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.graph_colouring.GraphColouring">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.graph_colouring.</span></span><span class="sig-name descname"><span class="pre">GraphColouring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_colours</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.graph_colouring.GraphColouring" title="Permalink to this definition"></a></dt>
<dd><p>Specialization of the <a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> class for Graph Colouring.</p>
<p>This class allows for the encoding of a Graph Colouring problem for a given
graph and a number of colours.
The method <a class="reference internal" href="#qat.opt.graph_colouring.produce_q_and_offset" title="qat.opt.graph_colouring.produce_q_and_offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">produce_q_and_offset()</span></code></a> is automatically
called. It computes the <span class="math notranslate nohighlight">\(Q\)</span> matrix and QUBO energy offset corresponding to
the Hamiltonian representation of the problem, as described in the reference.
These are stored in the parent class <a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> and would be needed
if one wishes to solve the problem through Simulated Annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>), for instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Reference</dt>
<dd class="field-odd"><p><a class="reference external" href="https://arxiv.org/abs/1302.5843/">“Ising formulations of many NP problems”, A. Lucas, 2014 - Section 6.1</a>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">GraphColouring</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="n">number_of_colours</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">graph_colouring_problem</span> <span class="o">=</span> <span class="n">GraphColouring</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">number_of_colours</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To anneal the problem, the solver would need &quot;</span>
      <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">*</span> <span class="n">number_of_colours</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; spins.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">anneal</span> <span class="n">the</span> <span class="n">problem</span><span class="p">,</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">would</span> <span class="n">need</span> <span class="mi">12</span> <span class="n">spins</span><span class="o">.</span>
<span class="o">&lt;</span><span class="n">stdin</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span> <span class="ne">FutureWarning</span><span class="p">:</span> <span class="n">adjacency_matrix</span> <span class="n">will</span> <span class="k">return</span> <span class="n">a</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span> <span class="n">array</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">a</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">Networkx</span> <span class="mf">3.0</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p></li>
<li><p><strong>number_of_colours</strong> (<em>int</em>) – the number of colours</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.graph_colouring.GraphColouring.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.graph_colouring.GraphColouring.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <em>quantum</em> annealing (SQA), available
in the QLM. However, the temperature parameters could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>6-key dictionary containing</p>
<ul class="simple">
<li><p><strong>n_monte_carlo_updates</strong> (<em>int</em>) - the number of Monte Carlo updates</p></li>
<li><p><strong>n_trotters</strong> (<em>int</em>) - the number of “classical replicas” or “Trotter
replicas”</p></li>
<li><p><strong>gamma_max</strong> (<em>double</em>) - the starting magnetic field</p></li>
<li><p><strong>gamma_min</strong> (<em>double</em>) - the final magnetic field</p></li>
<li><p><strong>temp_max</strong> (<em>double</em>) - the starting temperature</p></li>
<li><p><strong>temp_min</strong> (<em>double</em>) - the final temperature</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.graph_colouring.GraphColouring.parse_result">
<span class="sig-name descname"><span class="pre">parse_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.graph_colouring.GraphColouring.parse_result" title="Permalink to this definition"></a></dt>
<dd><p>Returns the best approximated solution of the Graph Colouring problem from a list of samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>result</strong> (<a class="reference internal" href="qat-core.html#qat.core.BatchResult" title="qat.core.BatchResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchResult</span></code></a>) – BatchResult containing a list of samples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The best partition among the samples thatrepresents
the colour of each node</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="combinatorial_optimization_generators_utils.html#qat.opt.results.GraphPartitioningResult" title="qat.opt.results.GraphPartitioningResult">GraphPartitioningResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.opt.graph_colouring.produce_q_and_offset">
<span class="sig-prename descclassname"><span class="pre">qat.opt.graph_colouring.</span></span><span class="sig-name descname"><span class="pre">produce_q_and_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_colours</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.graph_colouring.produce_q_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(Q\)</span> matrix and the offset energy of the problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p></li>
<li><p><strong>number_of_colours</strong> (<em>int</em>) – the number of colours</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="toggle-header docutils container" id="kclique">
<p><strong>K-Clique</strong></p>
</div>
<div class="toggle-content docutils container">
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="qat.opt.k_clique.KClique">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.k_clique.</span></span><span class="sig-name descname"><span class="pre">KClique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.k_clique.KClique" title="Permalink to this definition"></a></dt>
<dd><p>Specialization of the <a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> class for K-Clique.</p>
<p>This class allows for the encoding of a K-Clique problem for a given graph
and positive factors <span class="math notranslate nohighlight">\(K, A, B\)</span>.
The method <a class="reference internal" href="#qat.opt.k_clique.produce_q_and_offset" title="qat.opt.k_clique.produce_q_and_offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">produce_q_and_offset()</span></code></a> is automatically
called. It computes the <span class="math notranslate nohighlight">\(Q\)</span> matrix and QUBO energy offset corresponding
to the Hamiltonian representation of the problem, as described in the reference.
These are stored in the parent class <a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> and would be needed
if one wishes to solve the problem through Simulated Annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>), for instance - see the
<a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Fk_clique_myqlm.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">KClique notebook</a>.</p>
<p>For a right encoding, one should ensure that <span class="math notranslate nohighlight">\(A &gt; B * K\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Reference</dt>
<dd class="field-odd"><p><a class="reference external" href="https://arxiv.org/abs/1302.5843/">“Ising formulations of many NP problems”, A. Lucas, 2014 - Section 2.3</a>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">KClique</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>

<span class="n">B</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">K</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">k_clique_problem</span> <span class="o">=</span> <span class="n">KClique</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To anneal the problem, the solver would need &quot;</span>
      <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span> <span class="o">+</span> <span class="s2">&quot; spins.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">anneal</span> <span class="n">the</span> <span class="n">problem</span><span class="p">,</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">would</span> <span class="n">need</span> <span class="mi">6</span> <span class="n">spins</span><span class="o">.</span>
<span class="o">&lt;</span><span class="n">stdin</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span> <span class="ne">FutureWarning</span><span class="p">:</span> <span class="n">adjacency_matrix</span> <span class="n">will</span> <span class="k">return</span> <span class="n">a</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span> <span class="n">array</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">a</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">Networkx</span> <span class="mf">3.0</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p></li>
<li><p><strong>K</strong> (<em>int</em>) – the size of the clique</p></li>
<li><p><strong>A</strong> (<em>double</em>) – a positive constant by which the terms inside <span class="math notranslate nohighlight">\(H_A\)</span> from <span class="math notranslate nohighlight">\(H = H_A + H_B\)</span>
are multiplied. This equation comes from the Hamiltonian representation of the problem.</p></li>
<li><p><strong>B</strong> (<em>optional</em><em>, </em><em>double</em>) – similar to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> is a positive factor for the <span class="math notranslate nohighlight">\(H_B\)</span> terms, default is 1</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.k_clique.KClique.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.k_clique.KClique.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <em>quantum</em> annealing (SQA), available
in the QLM. However, the temperature parameters could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>6-key dictionary containing</p>
<ul class="simple">
<li><p><strong>n_monte_carlo_updates</strong> (<em>int</em>) - the number of Monte Carlo updates</p></li>
<li><p><strong>n_trotters</strong> (<em>int</em>) - the number of “classical replicas” or “Trotter
replicas”</p></li>
<li><p><strong>gamma_max</strong> (<em>double</em>) - the starting magnetic field</p></li>
<li><p><strong>gamma_min</strong> (<em>double</em>) - the final magnetic field</p></li>
<li><p><strong>temp_max</strong> (<em>double</em>) - the starting temperature</p></li>
<li><p><strong>temp_min</strong> (<em>double</em>) - the final temperature</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.k_clique.KClique.parse_result">
<span class="sig-name descname"><span class="pre">parse_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.k_clique.KClique.parse_result" title="Permalink to this definition"></a></dt>
<dd><p>Returns the best approximated solution of the K-Clique problem from a list of samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>result</strong> (<a class="reference internal" href="qat-core.html#qat.core.BatchResult" title="qat.core.BatchResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchResult</span></code></a>) – BatchResult containing a list of samples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The best partition among the samples with a K-clique
as the first subset</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="combinatorial_optimization_generators_utils.html#qat.opt.results.GraphPartitioningResult" title="qat.opt.results.GraphPartitioningResult">GraphPartitioningResult</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="qat.opt.k_clique.produce_q_and_offset">
<span class="sig-prename descclassname"><span class="pre">qat.opt.k_clique.</span></span><span class="sig-name descname"><span class="pre">produce_q_and_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.k_clique.produce_q_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(Q\)</span> matrix and the offset energy of the problem.
The constant <span class="math notranslate nohighlight">\(A\)</span> should be bigger than <span class="math notranslate nohighlight">\(K*B\)</span> for a right encoding. They are also all positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p></li>
<li><p><strong>K</strong> (<em>int</em>) – the size of the clique</p></li>
<li><p><strong>A</strong> (<em>double</em>) – a positive constant by which the terms inside <span class="math notranslate nohighlight">\(H_A\)</span> from <span class="math notranslate nohighlight">\(H = H_A + H_B\)</span>
are multiplied. This equation comes from the Hamiltonian representation of the problem.</p></li>
<li><p><strong>B</strong> (<em>optional</em><em>, </em><em>double</em>) – similar to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> is a positive factor for the <span class="math notranslate nohighlight">\(H_B\)</span> terms, default is 1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="toggle-header docutils container" id="vertex-cover">
<p><strong>Vertex Cover</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.vertex_cover.VertexCover">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.vertex_cover.</span></span><span class="sig-name descname"><span class="pre">VertexCover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.vertex_cover.VertexCover" title="Permalink to this definition"></a></dt>
<dd><p>Specialization of the <a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> class for Vertex Cover.</p>
<p>This class allows for the encoding of a Vertex Cover problem for a given
graph and positive constants <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>.
The method <a class="reference internal" href="#qat.opt.vertex_cover.produce_q_and_offset" title="qat.opt.vertex_cover.produce_q_and_offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">produce_q_and_offset()</span></code></a> is automatically
called. It computes the <span class="math notranslate nohighlight">\(Q\)</span> matrix and QUBO energy offset corresponding
to the Hamiltonian representation of the problem, as described in the
reference. These are stored in the parent class <a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a>
and would be needed if one wishes to solve the problem through Simulated
Annealing (<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>), for instance - see the
<a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Fvertex_cover_myqlm.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">Vertex Cover notebook</a>.</p>
<p>For a right encoding, one should ensure that <span class="math notranslate nohighlight">\(A &gt; B\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Reference</dt>
<dd class="field-odd"><p><a class="reference external" href="https://arxiv.org/abs/1302.5843/">“Ising formulations of many NP problems”, A. Lucas, 2014 - Section 4.3</a>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">VertexCover</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="n">A</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">vertex_cover_problem</span> <span class="o">=</span> <span class="n">VertexCover</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To anneal the problem, the solver would need &quot;</span>
       <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span> <span class="o">+</span> <span class="s2">&quot; spins.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">anneal</span> <span class="n">the</span> <span class="n">problem</span><span class="p">,</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">would</span> <span class="n">need</span> <span class="mi">6</span> <span class="n">spins</span><span class="o">.</span>
<span class="o">&lt;</span><span class="n">stdin</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span> <span class="ne">FutureWarning</span><span class="p">:</span> <span class="n">adjacency_matrix</span> <span class="n">will</span> <span class="k">return</span> <span class="n">a</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span> <span class="n">array</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">a</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">Networkx</span> <span class="mf">3.0</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p></li>
<li><p><strong>A</strong> (<em>optional</em><em>, </em><em>double</em>) – a positive constant by which the terms inside <span class="math notranslate nohighlight">\(H_A\)</span>
from <span class="math notranslate nohighlight">\(H = H_A + H_B\)</span> are multiplied, default is 2. This equation comes
from the Hamiltonian representation of the problem.</p></li>
<li><p><strong>B</strong> (<em>optional</em><em>, </em><em>double</em>) – similar to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> is a positive factor for the <span class="math notranslate nohighlight">\(H_B\)</span> terms, default is 1</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.vertex_cover.VertexCover.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.vertex_cover.VertexCover.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <em>quantum</em> annealing (SQA), available
in the QLM. However, the temperature parameters could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>6-key dictionary containing</p>
<ul class="simple">
<li><p><strong>n_monte_carlo_updates</strong> (<em>int</em>) - the number of Monte Carlo updates</p></li>
<li><p><strong>n_trotters</strong> (<em>int</em>) - the number of “classical replicas” or “Trotter
replicas”</p></li>
<li><p><strong>gamma_max</strong> (<em>double</em>) - the starting magnetic field</p></li>
<li><p><strong>gamma_min</strong> (<em>double</em>) - the final magnetic field</p></li>
<li><p><strong>temp_max</strong> (<em>double</em>) - the starting temperature</p></li>
<li><p><strong>temp_min</strong> (<em>double</em>) - the final temperature</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.vertex_cover.VertexCover.parse_result">
<span class="sig-name descname"><span class="pre">parse_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.vertex_cover.VertexCover.parse_result" title="Permalink to this definition"></a></dt>
<dd><p>Returns the approximated solution of the Vertex cut problem from a list of samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>result</strong> (<a class="reference internal" href="qat-core.html#qat.core.BatchResult" title="qat.core.BatchResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchResult</span></code></a>) – BatchResult containing a list of samples</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.opt.vertex_cover.produce_q_and_offset">
<span class="sig-prename descclassname"><span class="pre">qat.opt.vertex_cover.</span></span><span class="sig-name descname"><span class="pre">produce_q_and_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.vertex_cover.produce_q_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(Q\)</span> matrix and the offset energy of the problem.
The constant <span class="math notranslate nohighlight">\(A\)</span> should be bigger than <span class="math notranslate nohighlight">\(B\)</span> for a right encoding. They are also both positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>networkx.Graph</em>) – a networkx graph</p></li>
<li><p><strong>A</strong> (<em>optional</em><em>, </em><em>double</em>) – a positive constant by which the terms inside <span class="math notranslate nohighlight">\(H_A\)</span>
from <span class="math notranslate nohighlight">\(H = H_A + H_B\)</span> are multiplied, default is 2. This equation comes
from the Hamiltonian representation of the problem.</p></li>
<li><p><strong>B</strong> (<em>optional</em><em>, </em><em>double</em>) – similar to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> is a positive factor for the <span class="math notranslate nohighlight">\(H_B\)</span> terms, default is 1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="other-problems">
<h3>Other problems<a class="headerlink" href="#other-problems" title="Permalink to this heading"></a></h3>
<div class="toggle-header docutils container" id="number-partitioning">
<p><strong>Number Partitioning</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.number_partitioning.NumberPartitioning">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.number_partitioning.</span></span><span class="sig-name descname"><span class="pre">NumberPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array_of_numbers</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.number_partitioning.NumberPartitioning" title="Permalink to this definition"></a></dt>
<dd><p>Specialization of the <a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> class for Number Partitioning.</p>
<p>This class allows for the encoding of a Number Partitioning problem for
a given array of numbers.
The method <a class="reference internal" href="#qat.opt.number_partitioning.produce_j_h_and_offset" title="qat.opt.number_partitioning.produce_j_h_and_offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">produce_j_h_and_offset()</span></code></a>
is automatically called. It computes the coupling matrix <span class="math notranslate nohighlight">\(J\)</span>,
magnetic field <span class="math notranslate nohighlight">\(h\)</span> and Ising energy offset corresponding to the
Hamiltonian representation of the problem, as described in the reference.
These are stored in the parent class <a class="reference internal" href="#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> and would
be needed if one wishes to solve the problem through Simulated Annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>), for instance - see the
<a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fcombinatorial_optimization%2Fnumber_partitioning_myqlm.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">Number Partitioning notebook</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Reference</dt>
<dd class="field-odd"><p><a class="reference external" href="https://arxiv.org/abs/1302.5843/">“Ising formulations of many NP problems”, A. Lucas, 2014 - Section 2.1</a>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">NumberPartitioning</span>

<span class="n">array_of_numbers_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">array_of_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">array_of_numbers_size</span><span class="p">)</span>

<span class="n">number_partitioning_problem</span> <span class="o">=</span> <span class="n">NumberPartitioning</span><span class="p">(</span><span class="n">array_of_numbers</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To anneal the problem, the solver would need &quot;</span>
      <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">array_of_numbers_size</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; spins.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">anneal</span> <span class="n">the</span> <span class="n">problem</span><span class="p">,</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">would</span> <span class="n">need</span> <span class="mi">9558</span> <span class="n">spins</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>numbers_array</strong> (<em>1D numpy array</em>) – an array with all the numbers we want to partition</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.number_partitioning.NumberPartitioning.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.number_partitioning.NumberPartitioning.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <em>quantum</em> annealing (SQA), available
in the QLM. However, the temperature parameters could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>6-key dictionary containing</p>
<ul class="simple">
<li><p><strong>n_monte_carlo_updates</strong> (<em>int</em>) - the number of Monte Carlo updates</p></li>
<li><p><strong>n_trotters</strong> (<em>int</em>) - the number of “classical replicas” or “Trotter
replicas”</p></li>
<li><p><strong>gamma_max</strong> (<em>double</em>) - the starting magnetic field</p></li>
<li><p><strong>gamma_min</strong> (<em>double</em>) - the final magnetic field</p></li>
<li><p><strong>temp_max</strong> (<em>double</em>) - the starting temperature</p></li>
<li><p><strong>temp_min</strong> (<em>double</em>) - the final temperature</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.opt.number_partitioning.produce_j_h_and_offset">
<span class="sig-prename descclassname"><span class="pre">qat.opt.number_partitioning.</span></span><span class="sig-name descname"><span class="pre">produce_j_h_and_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array_of_numbers</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.number_partitioning.produce_j_h_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(J\)</span> coupling matrix of the problem, along with the magnetic field <span class="math notranslate nohighlight">\(h\)</span> and the Ising energy offset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>numbers_array</strong> (<em>1D numpy array</em>) – an array with all the numbers we want to partition</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="toggle-header docutils container" id="bilp">
<p><strong>Binary Integer Linear Programming</strong></p>
</div>
<div class="toggle-content docutils container">
<dl class="py class">
<dt class="sig sig-object py" id="qat.opt.binary_linear_integer_programming.BILP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.opt.binary_linear_integer_programming.</span></span><span class="sig-name descname"><span class="pre">BILP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.binary_linear_integer_programming.BILP" title="Permalink to this definition"></a></dt>
<dd><p>Specialization of the <a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> class for Binary Integer
Linear Programming (BILP).</p>
<p>This class allows for the encoding of a BILP problem from a given
matrix <span class="math notranslate nohighlight">\(S\)</span>, vectors <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(c\)</span> and positive constants
<span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. The aim is to maximise <span class="math notranslate nohighlight">\(c * x\)</span> subject to
<span class="math notranslate nohighlight">\(x\)</span> obeying <span class="math notranslate nohighlight">\(S * x = b\)</span>.
The method
<a class="reference internal" href="#qat.opt.binary_linear_integer_programming.produce_q_and_offset" title="qat.opt.binary_linear_integer_programming.produce_q_and_offset"><code class="xref py py-func docutils literal notranslate"><span class="pre">produce_q_and_offset()</span></code></a>
is automatically called. It computes the <span class="math notranslate nohighlight">\(Q\)</span> matrix and QUBO energy
offset corresponding to the Hamiltonian representation of the problem, as
described in the reference. These are stored in the parent class
<a class="reference internal" href="#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> and would be needed if one wishes to solve the problem
through Simulated Annealing (<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>), for instance.</p>
<p>For a right encoding, one should ensure that <span class="math notranslate nohighlight">\(A \gg B\)</span> and
<span class="math notranslate nohighlight">\(A &gt; 0, B &gt; 0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Reference</dt>
<dd class="field-odd"><p><a class="reference external" href="https://arxiv.org/abs/1302.5843/">“Ising formulations of many NP problems”, A. Lucas, 2014 - Section 3</a>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.opt</span> <span class="kn">import</span> <span class="n">BILP</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">B</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">A</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">B</span>

<span class="n">bilp_problem</span> <span class="o">=</span> <span class="n">BILP</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To anneal the problem, the solver would need &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; spins.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">anneal</span> <span class="n">the</span> <span class="n">problem</span><span class="p">,</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">would</span> <span class="n">need</span> <span class="mi">4</span> <span class="n">spins</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> (<em>1D numpy array</em><em> of </em><em>size N</em>) – a specified vector <span class="math notranslate nohighlight">\(c\)</span>. We want to maximize <span class="math notranslate nohighlight">\(c * x\)</span>.</p></li>
<li><p><strong>S</strong> (<em>2D numpy array</em><em> of </em><em>size m*N</em>) – the matrix, for which <span class="math notranslate nohighlight">\(S * x = b\)</span>. This equation is our constraint.</p></li>
<li><p><strong>b</strong> (<em>1D numpy array</em><em> of </em><em>size m</em>) – a specified vector <span class="math notranslate nohighlight">\(b\)</span> obeying the constraint <span class="math notranslate nohighlight">\(S * x = b\)</span></p></li>
<li><p><strong>A</strong> (<em>double</em>) – a positive constant by which the terms inside <span class="math notranslate nohighlight">\(H_A\)</span> from <span class="math notranslate nohighlight">\(H = H_A + H_B\)</span>
are multiplied. This equation comes from the Hamiltonian representation of the problem.</p></li>
<li><p><strong>B</strong> (<em>optional</em><em>, </em><em>double</em>) – similar to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> is a positive factor for the <span class="math notranslate nohighlight">\(H_B\)</span> terms, default is 1</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.opt.binary_linear_integer_programming.BILP.get_best_parameters">
<span class="sig-name descname"><span class="pre">get_best_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.binary_linear_integer_programming.BILP.get_best_parameters" title="Permalink to this definition"></a></dt>
<dd><p>This method returns a dictionary with the best found parameters (after
<a class="reference internal" href="advanced_combinatorial_optimization.html#benchmarking"><span class="std std-ref">benchmarking</span></a>) for simulated <em>quantum</em> annealing (SQA), available
in the QLM. However, the temperature parameters could also be used for simulated annealing
(<a class="reference internal" href="combinatorial_optimization_intro.html#solving-comb"><span class="std std-ref">SA</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>6-key dictionary containing</p>
<ul class="simple">
<li><p><strong>n_monte_carlo_updates</strong> (<em>int</em>) - the number of Monte Carlo updates</p></li>
<li><p><strong>n_trotters</strong> (<em>int</em>) - the number of “classical replicas” or “Trotter
replicas”</p></li>
<li><p><strong>gamma_max</strong> (<em>double</em>) - the starting magnetic field</p></li>
<li><p><strong>gamma_min</strong> (<em>double</em>) - the final magnetic field</p></li>
<li><p><strong>temp_max</strong> (<em>double</em>) - the starting temperature</p></li>
<li><p><strong>temp_min</strong> (<em>double</em>) - the final temperature</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.opt.binary_linear_integer_programming.produce_q_and_offset">
<span class="sig-prename descclassname"><span class="pre">qat.opt.binary_linear_integer_programming.</span></span><span class="sig-name descname"><span class="pre">produce_q_and_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.opt.binary_linear_integer_programming.produce_q_and_offset" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(Q\)</span> matrix and the offset energy of the problem.
For right encoding <span class="math notranslate nohighlight">\(A \gg B\)</span> and <span class="math notranslate nohighlight">\(A &gt; 0, B &gt; 0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> (<em>1D numpy array</em><em> of </em><em>size N</em>) – a specified vector <span class="math notranslate nohighlight">\(c\)</span>. We want to maximize <span class="math notranslate nohighlight">\(c * x\)</span>.</p></li>
<li><p><strong>S</strong> (<em>2D numpy array</em><em> of </em><em>size m*N</em>) – the matrix, for which <span class="math notranslate nohighlight">\(S * x = b\)</span>. This equation is our constraint.</p></li>
<li><p><strong>b</strong> (<em>1D numpy array</em><em> of </em><em>size m</em>) – a specified vector <span class="math notranslate nohighlight">\(b\)</span> obeying the constraint <span class="math notranslate nohighlight">\(S * x = b\)</span></p></li>
<li><p><strong>A</strong> (<em>double</em>) – a positive constant by which the terms inside <span class="math notranslate nohighlight">\(H_A\)</span> from <span class="math notranslate nohighlight">\(H = H_A + H_B\)</span>
are multiplied. This equation comes from the Hamiltonian representation of the problem.</p></li>
<li><p><strong>B</strong> (<em>optional</em><em>, </em><em>double</em>) – similar to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> is a positive factor for the <span class="math notranslate nohighlight">\(H_B\)</span> terms, default is 1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="qat-fermion_source.html" class="btn btn-neutral float-left" title="Digital quantum simulation for spin and fermionic systems" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="combinatorial_optimization_generators_utils.html" class="btn btn-neutral float-right" title="Combinatorial Optimization Generators tools" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Atos 2016-2022.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>