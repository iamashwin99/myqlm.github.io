<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qat.pylinalg: Python Linear-algebra simulator &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../static/contentui.css" type="text/css" />
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../static/documentation_options.js"></script>
        <script src="../static/jquery.js"></script>
        <script src="../static/underscore.js"></script>
        <script src="../static/doctools.js"></script>
        <script src="../static/contentui.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script src="../static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="qat.simulated_annealing: Simulated Annealing" href="qat-simulated_annealing.html" />
    <link rel="prev" title="QuameleonPlugin : emulating hardware constraints via a plugin" href="../quameleon.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> myQLM documentation
            <img src="../static/myqlm.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                myQLM-1.6.1.705
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../combinatorial_optimization_intro.html">Combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Main objects: Jobs, Observables, Circuits…</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../qat-fermion.html">Digital quantum simulation for spin and fermionic systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commands.html">Command-line tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source code documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../source_doc.html">Source code documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#quantum-application-toolchain-qat-python-libraries">Quantum Application ToolChain (QAT) Python libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#the-core-library">The core library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#the-programming-library">The programming library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#the-device-library">The device library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#plugins">Plugins</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../source_doc.html#qpus">QPUs</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">qat.pylinalg: Python Linear-algebra simulator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quantum-processing-unit">Quantum Processing Unit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simulator-internal-functions">Simulator Internal Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="qat-simulated_annealing.html">qat.simulated_annealing: Simulated Annealing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#interoperability-with-other-frameworks">Interoperability with other frameworks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#digital-quantum-simulation-tools">Digital quantum simulation tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#combinatorial-optimization-and-qaoa">Combinatorial optimization and QAOA</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributing to myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-note.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../source_doc.html">Source code documentation</a> &raquo;</li>
      <li>qat.pylinalg: Python Linear-algebra simulator</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<span class="target" id="module-qat.pylinalg"></span><section id="qat-pylinalg-python-linear-algebra-simulator">
<h1>qat.pylinalg: Python Linear-algebra simulator<a class="headerlink" href="#qat-pylinalg-python-linear-algebra-simulator" title="Permalink to this headline"></a></h1>
<p>myQLM comes with one simulator which performs a unitary evolution of the
initial quantum state using the operations described in a quantum circuit. This
simulator is called “Python Linear-Algebra”.</p>
<p>It is entirely written in Python, and is based in particular on the
<a class="reference external" href="http://www.numpy.org/">Numpy</a> library.</p>
<p>The quantum state is stored as an <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html">ndarray</a> of shape
<span class="math notranslate nohighlight">\(\left(2,...,2\right)\)</span>, with one 2-valued index per qubit:</p>
<div class="math notranslate nohighlight">
\[\vert\psi\rangle = \sum_{i_{1},\dots,i_{N}\in \{0,1\}^{N}}
a_{i_{1} \dots i_{N}}|i_{1} \dots i_{N}\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(|i_{1}\dots i_{N}\rangle\)</span> represents a computational basis state.</p>
<p>Quantum gates are also manipulated as ndarrays, with <span class="math notranslate nohighlight">\(2\times \text{arity}\)</span>
2-valued indices. Half of the indices are <strong>input indices</strong> and the other half
<strong>output indices</strong>.</p>
<p>Applying a gate consists in contracting the input indices with the indices
corresponding to the qubits on which the gate is applied:</p>
<figure class="align-default">
<img alt="../images/tensordot.png" src="../images/tensordot.png" />
</figure>
<p>The main point of using ndarrays is that this operation can be easily written
with the <a class="reference external" href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.tensordot.html">np.tensordot</a>
function. See source code documentation for more details.</p>
<p><strong>miscellanous remarks about the simulator</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>it accepts any gate, of any arity.</p></li>
<li><p>it works with the entire amplitude vector. Any information is available.</p></li>
<li><p>it is memory and run-time exponential in the number of qubits. This implies a hard simulation limit at around 20-30 qubits, depending on your RAM.</p></li>
</ul>
</div></blockquote>
<p>Within myQLM, this simulator is contained in the <a class="reference internal" href="#module-qat.pylinalg" title="qat.pylinalg"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.pylinalg</span></code></a> module.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The full QLM appliance also includes ‘’noisy’’ simulators, which take into account
realistic, parametrable physical noise into the execution of a quantum circuit.</p>
</div>
<p>The <a class="reference internal" href="#module-qat.pylinalg" title="qat.pylinalg"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.pylinalg</span></code></a> module contains a linear-algebra-based quantum simulator.
This simulator encodes the quantum amplitudes in a vector with <span class="math notranslate nohighlight">\(2^n\)</span>
complex numbers, where <span class="math notranslate nohighlight">\(n\)</span> is the number of qubits. This vector is modified
by the application of quantum gates.</p>
<section id="quantum-processing-unit">
<h2>Quantum Processing Unit<a class="headerlink" href="#quantum-processing-unit" title="Permalink to this headline"></a></h2>
<p>This is the high-level class wrapping the simulator. It follows the convention
of the <a class="reference internal" href="../qat-core.html#qat.core.qpu.QPUHandler" title="qat.core.qpu.QPUHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.qpu.QPUHandler</span></code></a> structure.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qat.pylinalg.PyLinalg">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">qat.pylinalg.</span></span><span class="sig-name descname"><span class="pre">PyLinalg</span></span><a class="headerlink" href="#qat.pylinalg.PyLinalg" title="Permalink to this definition"></a></dt>
<dd><p>Simple linalg simulator plugin.</p>
<p>Inherits <a class="reference internal" href="#qat.pylinalg.PyLinalg.serve" title="qat.pylinalg.PyLinalg.serve"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve()</span></code></a> and <a class="reference internal" href="#qat.pylinalg.PyLinalg.submit" title="qat.pylinalg.PyLinalg.submit"><code class="xref py py-func docutils literal notranslate"><span class="pre">submit()</span></code></a> method from <a class="reference internal" href="../qat-core.html#qat.core.qpu.QPUHandler" title="qat.core.qpu.QPUHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.qpu.QPUHandler</span></code></a>
Only the <a class="reference internal" href="#qat.pylinalg.PyLinalg.submit_job" title="qat.pylinalg.PyLinalg.submit_job"><code class="xref py py-func docutils literal notranslate"><span class="pre">submit_job()</span></code></a> method is simulator-specific and defined here.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.pylinalg.PyLinalg.serve">
<span class="sig-name descname"><span class="pre">serve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host_ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'localhost'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.PyLinalg.serve" title="Permalink to this definition"></a></dt>
<dd><p>Runs the QPU inside a server</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port</strong> (<em>int</em>) – the port on which to listen</p></li>
<li><p><strong>host_ip</strong> (<em>str</em>) – the url on which to publish the API. Optional.
Defaults to ‘localhost’.</p></li>
<li><p><strong>server_type</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>type of server. The different
types of server are:</p>
<blockquote>
<div><ul>
<li><p>”simple”: single-thread server, accepts one connection
at a time (default server type)</p></li>
<li><p>”threaded”: multi-thread server, each connection
starts a new thread</p></li>
<li><p>”pool”: multi-thread server, each connection runs
in a thread, with a maximum of 10 running threads</p></li>
<li><p>”fork”: multi-process server, each connection runs
in a new process</p></li>
</ul>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.pylinalg.PyLinalg.submit">
<span class="sig-name descname"><span class="pre">submit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="../qat-core.html#qat.core.Batch" title="qat.core.wrappers.batch.Batch"><span class="pre">qat.core.wrappers.batch.Batch</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta_data</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">dict</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../qat-core.html#qat.core.BatchResult" title="qat.core.wrappers.result.BatchResult"><span class="pre">qat.core.wrappers.result.BatchResult</span></a></span></span><a class="headerlink" href="#qat.pylinalg.PyLinalg.submit" title="Permalink to this definition"></a></dt>
<dd><p>Executes a batch of jobs and returns the corresponding list of Results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>batch</strong> (<a class="reference internal" href="../qat-core.html#qat.core.Batch" title="qat.core.Batch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Batch</span></code></a>) – a batch of jobs. If a single job is provided, the
job is embedded into a Batch, executed, and the first result
is returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a batch result</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="../qat-core.html#qat.core.BatchResult" title="qat.core.BatchResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchResult</span></code></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.pylinalg.PyLinalg.submit_job">
<span class="sig-name descname"><span class="pre">submit_job</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">job</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.PyLinalg.submit_job" title="Permalink to this definition"></a></dt>
<dd><p>Returns a Result structure corresponding to the execution
of a Job</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>job</strong> (<a class="reference internal" href="../qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">Job</span></code></a>) – the job to execute</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the result</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../qat-core.html#qat.core.Result" title="qat.core.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="#qat.pylinalg.PyLinalg.submit_job" title="qat.pylinalg.PyLinalg.submit_job"><code class="xref py py-func docutils literal notranslate"><span class="pre">submit_job()</span></code></a> method above basically consists of two
imbricated if statements.</p>
<p>The first one looks at the <code class="code docutils literal notranslate"><span class="pre">type</span></code> attribute of the job, which can take
two values:</p>
<blockquote>
<div><ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">OBSERVABLE</span></code> (cf. <a class="reference internal" href="../qat-core.html#qat.comm.shared.ttypes.ProcessingType" title="qat.comm.shared.ttypes.ProcessingType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessingType</span></code></a>): the job consists in evaluating an observable at
the end of the circuit. Currently, the attribute <strong>nbshots</strong> has no effect if the <strong>type</strong> is <code class="code docutils literal notranslate"><span class="pre">OBSERVABLE</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">SAMPLING</span></code> (cf. <a class="reference internal" href="../qat-core.html#qat.comm.shared.ttypes.ProcessingType" title="qat.comm.shared.ttypes.ProcessingType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessingType</span></code></a>): the job consists in sampling the output probability
distribution of the quantum circuit. This is where the second if loop comes in, depending on the <strong>number of shots</strong> which is asked (<code class="code docutils literal notranslate"><span class="pre">job.nbshots</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li><p>if <strong>nbshots=0</strong> then the simulator/quantum-processor returns <em>the best it can do</em>. In our case, of a linear-algebra-based simulator, this is the entire probability distribution.</p></li>
<li><p>else, the simulator samples the output probability distribution <em>nbshots</em> times.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<span class="target" id="module-qat.pylinalg.simulator"></span></section>
<section id="simulator-internal-functions">
<h2>Simulator Internal Functions<a class="headerlink" href="#simulator-internal-functions" title="Permalink to this headline"></a></h2>
<p>The actual numpy-based simulation code can be accessed in the <a class="reference internal" href="#module-qat.pylinalg.simulator" title="qat.pylinalg.simulator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.pylinalg.simulator</span></code></a>
module, whose source code is documented here.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qat.pylinalg.simulator.simulate">
<span class="sig-prename descclassname"><span class="pre">qat.pylinalg.simulator.</span></span><span class="sig-name descname"><span class="pre">simulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.simulate" title="Permalink to this definition"></a></dt>
<dd><p>Computes state vector at the output of provided circuit.</p>
<p>State vector is stored as a <code class="code docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>
It is initialized at <span class="math notranslate nohighlight">\(|0^n\rangle\)</span>.
Then, loop over gates, updating the state vector using <cite>np.tensordot</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circuit</strong> (<a class="reference internal" href="../qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a>) – Input circuit. The
circuit to simulate.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>a tuple composed of a state vector and
intermediate measurements:</p>
<blockquote>
<div><ul class="simple">
<li><p>state vector: <code class="code docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> containing the final
state vector. It has one 2-valued index per qubits.</p></li>
<li><p>intermediate measurements: <code class="code docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="../qat-core.html#qat.comm.shared.ttypes.IntermediateMeasurement" title="qat.comm.shared.ttypes.IntermediateMeasurement"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.comm.shared.ttypes.IntermediateMeasurement</span></code></a>. List containing descriptors of the intermediate measurements that occurred within the circuit, so that the classical branching is known to the user.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#qat.pylinalg.simulator.simulate" title="qat.pylinalg.simulator.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">qat.pylinalg.simulator.simulate()</span></code></a> mainly consists in a for loop
over the <code class="code docutils literal notranslate"><span class="pre">ops</span></code> attribute of the input <a class="reference internal" href="../qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a>,
i.e the gates of the circuit. They are successively applied onto the quantum
state, which starts in <span class="math notranslate nohighlight">\(|0...0\rangle\)</span>. A gate can be of several types:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>GATETYPE</strong> (default)</p></li>
<li><p><strong>MEASURE</strong> (measure some qubits, store the result)</p></li>
<li><p><strong>RESET</strong> (measure a qubit, if result is 1, apply X onto it)</p></li>
<li><p><strong>CLASSIC</strong> (perform classical logical computation on classical bits)</p></li>
<li><p><strong>CLASSICCTRL</strong> (perform classically controlled quantum gate)</p></li>
<li><p><strong>BREAK</strong> (raise break exception if a clasical formula is evaluated to True)</p></li>
</ul>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">circuit.ops</span></code> is a list of <a class="reference internal" href="../introduction.html#qat.comm.datamodel.ttypes.Op" title="qat.comm.datamodel.ttypes.Op"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.comm.datamodel.ttypes.Op</span></code></a>.</p>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="qat.pylinalg.simulator.measure">
<span class="sig-prename descclassname"><span class="pre">qat.pylinalg.simulator.</span></span><span class="sig-name descname"><span class="pre">measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.measure" title="Permalink to this definition"></a></dt>
<dd><p>Samples measurement results on the specified qubits.</p>
<p>No projection is carried out ! See “project” function.
Thanks to the absence of projection, several samples can be asked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_vec</strong> (<em>numpy.ndarray</em>) – the <code class="code docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>
containing full state vector.</p></li>
<li><p><strong>qubits</strong> (<em>list</em>) – list of integers specifying the subset
of qubits to measure.</p></li>
<li><p><strong>nb_samples</strong> (<em>int</em><em>, </em><em>optional</em>) – the number of samples to return. Set to 1
by default.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intprob_list</strong>, a list (of length nb_samples) containing tuples of the form (integer, probability). The integer is the result of the measurement on the subset of qubits (when converted to binary representation, it needs to have a width of len(qubits)). The probability is the probability the measurement had to occur. It is useful for renormalizing afterwards.
In short: it is a list of samples. One sample is a (int, prob) tuple.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.pylinalg.simulator.project">
<span class="sig-prename descclassname"><span class="pre">qat.pylinalg.simulator.</span></span><span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intprob</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.project" title="Permalink to this definition"></a></dt>
<dd><p>Projects the state by assigning qubits to specified values.</p>
<p>The “measure” function does not project. This is nice when asking for
several samples. But the full behavior of a quantum state when undergoing
measurement includes a projection onto the result state. This is what
this function does. In practice, it is used for intermediary measurements.
(i.e within measure and reset gates)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_vec</strong> (<em>numpy.ndarray</em>) – The state vector to project, i.e the
one from which the results were sampled.</p></li>
<li><p><strong>qubits</strong> (<em>list</em>) – The qubits that were measured, presented as a list
of integers. Without this info, we don’t know to what axes the result
corresponds.</p></li>
<li><p><strong>intprob</strong> (<em>tuple</em>) – a tuple of the form (integer, probability). The
integer codes for the value that was measured on the qubits in the list
“qubits”. The probability that the measurement had to occur. It is
useful for renormalizing without having to recompute a norm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The projected state vector. The values of the qubits in the “qubits” list have been assigned to the measured values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.pylinalg.simulator.reset">
<span class="sig-prename descclassname"><span class="pre">qat.pylinalg.simulator.</span></span><span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.reset" title="Permalink to this definition"></a></dt>
<dd><p>Resets the value of the specified qubits to 0.</p>
<p>It works by measuring each
qubit, and then applying an X gate if the result is 1.</p>
<p>for one qubit, entirely equivalent to, in AQASM:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>MEAS q[k] c[k]
?c[k] : X q[k]
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_vec</strong> (<em>numpy.ndarray</em>) – nd-array containing the full state
vector.</p></li>
<li><p><strong>qubits</strong> (<em>list</em>) – list of integers, containing the qubits to reset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>a tuple composed
of:</p>
<blockquote>
<div><ul class="simple">
<li><p>state_vec(<cite>numpy.ndarray</cite>) the full state vector. the specified qubits
have been reset.</p></li>
<li><p>an integer: result of the measurement on the subset of qubits (when
converted to binary representation, it needs to have a width of
len(qubits)).</p></li>
<li><p>a float: probability the measurement had to occur.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(state_vec, int, prob)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.pylinalg.simulator.raise_break">
<span class="sig-prename descclassname"><span class="pre">qat.pylinalg.simulator.</span></span><span class="sig-name descname"><span class="pre">raise_break</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.raise_break" title="Permalink to this definition"></a></dt>
<dd><p>Raises break exception, as a result of a boolean classical formula being
evaluated to True.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.pylinalg.simulator.mat2nparray">
<span class="sig-prename descclassname"><span class="pre">qat.pylinalg.simulator.</span></span><span class="sig-name descname"><span class="pre">mat2nparray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.mat2nparray" title="Permalink to this definition"></a></dt>
<dd><p>Converts serialized matrix format into numpy array.</p>
<p>When extracted from the quantum circuit, gate matrices are not
directly numpy arrays. They are instances of
<code class="code docutils literal notranslate"><span class="pre">Matrix</span></code>, an internally-defined structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<code class="code docutils literal notranslate"><span class="pre">qat.comm.datamodel.ttypes.Matrix</span></code>) – The matrix, as extracted
from circuit operation, to convert to <code class="code docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <code class="code docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> of shape (2*arity,2*arity) containing
the matrix data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../quameleon.html" class="btn btn-neutral float-left" title="QuameleonPlugin : emulating hardware constraints via a plugin" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="qat-simulated_annealing.html" class="btn btn-neutral float-right" title="qat.simulated_annealing: Simulated Annealing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Atos 2016-2022.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>