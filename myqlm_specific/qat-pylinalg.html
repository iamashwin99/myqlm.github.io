

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>qat.pylinalg: Python Linear-algebra simulator &mdash; myQLM documentation myQLM-1.1.6.25 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script src="../static/jquery.js"></script>
        <script src="../static/underscore.js"></script>
        <script src="../static/doctools.js"></script>
        <script src="../static/language_data.js"></script>
        <script src="../static/contentui.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="qat-opt: representation and encoding of combinatorial problems, QAOA" href="../qat-opt.html" />
    <link rel="prev" title="QuameleonPlugin : emulating hardware constraints via a plugin" href="../quameleon.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> myQLM documentation
          

          
            
            <img src="../static/myqlm.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                myQLM-1.1.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Basic usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../combinatorial_optimization_intro.html">Combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Architecture and data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../source_doc.html">Source code documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#quantum-application-toolchain-qat-python-libraries">Quantum Application ToolChain (QAT) Python libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#the-core-library">The core library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#the-programming-library">The programming library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#plugins">Plugins</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../source_doc.html#qpus">QPUs</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">qat.pylinalg: Python Linear-algebra simulator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quantum-processing-unit">Quantum Processing Unit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simulator-internal-functions">Simulator Internal Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#interoperability-with-other-frameworks">Interoperability with other frameworks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source_doc.html#combinatorial-optimization-and-qaoa">Combinatorial optimization and QAOA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commands.html">Command line tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributing to myQLM</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">myQLM documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../source_doc.html">Source code documentation</a> &raquo;</li>
        
      <li>qat.pylinalg: Python Linear-algebra simulator</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="qat-pylinalg-python-linear-algebra-simulator">
<h1>qat.pylinalg: Python Linear-algebra simulator<a class="headerlink" href="#qat-pylinalg-python-linear-algebra-simulator" title="Permalink to this headline">¶</a></h1>
<p>myQLM comes with one simulator which performs a unitary evolution of the
initial quantum state using the operations described in a quantum circuit. This
simulator is called “Python Linear-Algebra”.</p>
<p>It is entirely written in Python, and is based in particular on the
<a class="reference external" href="http://www.numpy.org/">Numpy</a> library.</p>
<p>The quantum state is stored as an <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html">ndarray</a> of shape
<span class="math notranslate nohighlight">\(\left(2,...,2\right)\)</span>, with one 2-valued index per qubit:</p>
<div class="math notranslate nohighlight">
\[\vert\psi\rangle = \sum_{i_{1},\dots,i_{N}\in \{0,1\}^{N}}
a_{i_{1} \dots i_{N}}|i_{1} \dots i_{N}\rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(|i_{1}\dots i_{N}\rangle\)</span> represents a computational basis state.</p>
<p>Quantum gates are also manipulated as ndarrays, with <span class="math notranslate nohighlight">\(2\times \text{arity}\)</span>
2-valued indices. Half of the indices are <strong>input indices</strong> and the other half
<strong>output indices</strong>.</p>
<p>Applying a gate consists in contracting the input indices with the indices
corresponding to the qubits on which the gate is applied:</p>
<div class="figure align-default">
<img alt="../images/tensordot.png" src="../images/tensordot.png" />
</div>
<p>The main point of using ndarrays is that this operation can be easily written
with the <a class="reference external" href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.tensordot.html">np.tensordot</a>
function. See source code documentation for more details.</p>
<p><strong>miscellanous remarks about the simulator</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>it accepts any gate, of any arity.</p></li>
<li><p>it works with the entire amplitude vector. Any information is available.</p></li>
<li><p>it is memory and run-time exponential in the number of qubits. This implies a hard simulation limit at around 20-30 qubits, depending on your RAM.</p></li>
</ul>
</div></blockquote>
<p>Within myQLM, this simulator is contained in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.pylinalg</span></code> module.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The full QLM appliance also includes ‘’noisy’’ simulators, which take into account
realistic, parametrable physical noise into the execution of a quantum circuit.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">qat-pylinalg</span></code> module contains a linear-algebra-based quantum simulator.
This simulator encodes the quantum amplitudes in a vector with <span class="math notranslate nohighlight">\(2^n\)</span>
complex numbers, where <span class="math notranslate nohighlight">\(n\)</span> is the number of qubits. This vector is modified
by the application of quantum gates.</p>
<div class="section" id="quantum-processing-unit">
<h2>Quantum Processing Unit<a class="headerlink" href="#quantum-processing-unit" title="Permalink to this headline">¶</a></h2>
<p>This is the high-level class wrapping the simulator. It follows the convention
of the <a class="reference internal" href="../qat-core.html#qat.core.qpu.QPUHandler" title="qat.core.qpu.QPUHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.qpu.QPUHandler</span></code></a> structure.</p>
<dl class="py class">
<dt id="qat.pylinalg.PyLinalg">
<em class="property">class </em><code class="sig-prename descclassname">qat.pylinalg.</code><code class="sig-name descname">PyLinalg</code><a class="headerlink" href="#qat.pylinalg.PyLinalg" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple linalg simulator plugin.</p>
<p>Inherits <a class="reference internal" href="#qat.pylinalg.PyLinalg.serve" title="qat.pylinalg.PyLinalg.serve"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve()</span></code></a> and <a class="reference internal" href="#qat.pylinalg.PyLinalg.submit" title="qat.pylinalg.PyLinalg.submit"><code class="xref py py-func docutils literal notranslate"><span class="pre">submit()</span></code></a> method from <a class="reference internal" href="../qat-core.html#qat.core.qpu.QPUHandler" title="qat.core.qpu.QPUHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.qpu.QPUHandler</span></code></a>
Only the <a class="reference internal" href="#qat.pylinalg.PyLinalg.submit_job" title="qat.pylinalg.PyLinalg.submit_job"><code class="xref py py-func docutils literal notranslate"><span class="pre">submit_job()</span></code></a> method is simulator-specific and defined here.</p>
<dl class="py method">
<dt id="qat.pylinalg.PyLinalg.serve">
<code class="sig-name descname">serve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">port</span></em>, <em class="sig-param"><span class="n">host_ip</span><span class="o">=</span><span class="default_value">'localhost'</span></em>, <em class="sig-param"><span class="n">server_type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.PyLinalg.serve" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the QPU inside a server</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port</strong> (<em>int</em>) – the port on which to listen</p></li>
<li><p><strong>host_ip</strong> (<em>str</em>) – the url on which to publish the API. Optional.
Defaults to ‘localhost’.</p></li>
<li><p><strong>server_type</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>type of server. The different
types of server are:</p>
<blockquote>
<div><ul>
<li><p>”simple”: single-thread server, accepts one connection
at a time (default server type)</p></li>
<li><p>”threaded”: multi-thread server, each connection
starts a new thread</p></li>
<li><p>”pool”: multi-thread server, each connection runs
in a thread, with a maximum of 10 running threads</p></li>
<li><p>”fork”: multi-process server, each connection runs
in a new process</p></li>
</ul>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qat.pylinalg.PyLinalg.submit">
<code class="sig-name descname">submit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">batch</span><span class="p">:</span> <span class="n">qat.core.wrappers.batch.Batch</span></em>, <em class="sig-param"><span class="n">meta_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>dict<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; qat.core.wrappers.result.BatchResult<a class="headerlink" href="#qat.pylinalg.PyLinalg.submit" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a batch of jobs and returns the corresponding list of Results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>batch</strong> (<a class="reference internal" href="../qat-core.html#qat.core.Batch" title="qat.core.Batch"><em>Batch</em></a>) – a batch of jobs. If a single job is provided, the
job is embedded into a Batch, executed, and the first result
is returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>BatchResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qat.pylinalg.PyLinalg.submit_job">
<code class="sig-name descname">submit_job</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">job</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.PyLinalg.submit_job" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Result structure corresponding to the execution
of a Job</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>job</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Job</span></code>) – the job to execute</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the result</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="xref py py-func docutils literal notranslate"><span class="pre">submit_job()</span></code> method above basically consists of two
imbricated if statements.</p>
<p>The first one looks at the <code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code> attribute of the job, which can take
two values:</p>
<blockquote>
<div><ul>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">qat.comm.shared.ttypes.ProcessingType.OBSERVABLE</span></code>: the job consists in evaluating an observable at the end of the circuit. This job type is not implemented (yet) in <code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.pylinalg</span></code> but could be, as the simulator contains all of the state vector.</p></li>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">qat.comm.shared.ttypes.ProcessingType.SAMPLING</span></code>: the job consists in sampling the output probability distribution of the quantum circuit. This is where the second if loop comes in, depending on the <strong>number of shots</strong> which is asked (<code class="xref py py-obj docutils literal notranslate"><span class="pre">job.nbshots</span></code>):</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(\cdot\)</span> if <strong>nbshots=0</strong> then the simulator/quantum-processor returns <em>the best it can do</em>. In our case, of a linear-algebra-based simulator, this is the entire probability distribution.</p>
<p><span class="math notranslate nohighlight">\(\cdot\)</span> else, the simulator samples the output probability distribution <em>nbshots</em> times.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="simulator-internal-functions">
<h2>Simulator Internal Functions<a class="headerlink" href="#simulator-internal-functions" title="Permalink to this headline">¶</a></h2>
<p>The actual numpy-based simulation code can be accessed in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.pylinalg.simulator</span></code>
module, whose source code is documented here.</p>
<dl class="py function">
<dt id="qat.pylinalg.simulator.simulate">
<code class="sig-prename descclassname">qat.pylinalg.simulator.</code><code class="sig-name descname">simulate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">circuit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes state vector at the output of provided circuit.</p>
<p>State vector is stored as a <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>
It is initialized at <span class="math notranslate nohighlight">\(|0^n\rangle\)</span>.
Then, loop over gates, updating the state vector using <cite>np.tensordot</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circuit</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">qat.comm.datamodel.ttypes.Circuit</span></code>) – Input circuit. The
circuit to simulate.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>a tuple: state_vec, interm_measurements.</dt><dd><ul class="simple">
<li><p>state_vec: <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> containing the final
state vector. It has one 2-valued index per qubits.</p></li>
<li><p>interm_measurements: <code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qat.comm.shared_types.IntermediateMeasurement</span></code>. List containing descriptors of the intermediate measurements that occurred within the circuit, so that the classical branching is known to the user.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#qat.pylinalg.simulator.simulate" title="qat.pylinalg.simulator.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">qat.pylinalg.simulator.simulate()</span></code></a> mainly consists in a for loop
over the <code class="xref py py-obj docutils literal notranslate"><span class="pre">ops</span></code> attribute of the input <code class="xref py py-class docutils literal notranslate"><span class="pre">qat.comm.datamodel.ttypes.Circuit</span></code>,
i.e the gates of the circuit. They are successively applied onto the quantum
state, which starts in <span class="math notranslate nohighlight">\(|0...0\rangle\)</span>. A gate can be of several types:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">GATETYPE</span></code> (default)</p></li>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MEASURE</span></code> (measure some qubits, store the result)</p></li>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RESET</span></code> (measure a qubit, if result is 1, apply X onto it)</p></li>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CLASSIC</span></code> (perform classical logical computation on classical bits)</p></li>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CLASSICCTRL</span></code> (perform classically controlled quantum gate)</p></li>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">BREAK</span></code> (raise break exception if a clasical formula is evaluated to True)</p></li>
</ul>
</div></blockquote>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">circuit.ops</span></code> is a list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qat.comm.datamodel.ttypes.Op</span></code>.</p>
</div>
<dl class="py function">
<dt id="qat.pylinalg.simulator.measure">
<code class="sig-prename descclassname">qat.pylinalg.simulator.</code><code class="sig-name descname">measure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state_vec</span></em>, <em class="sig-param"><span class="n">qubits</span></em>, <em class="sig-param"><span class="n">nb_samples</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples measurement results on the specified qubits.</p>
<p>No projection is carried out ! See “project” function.
Thanks to the absence of projection, several samples can be asked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_vec</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – the <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>
containing full state vector.</p></li>
<li><p><strong>qubits</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – list of integers specifying the subset
of qubits to measure.</p></li>
<li><p><strong>nb_samples</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional) – the number of samples to return. Set to 1
by default.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intprob_list</strong>, a list (of length nb_samples) containing tuples of the form (integer, probability). The integer is the result of the measurement on the subset of qubits (when converted to binary representation, it needs to have a width of len(qubits)). The probability is the probability the measurement had to occur. It is useful for renormalizing afterwards.
In short: it is a list of samples. One sample is a (int, prob) tuple.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qat.pylinalg.simulator.project">
<code class="sig-prename descclassname">qat.pylinalg.simulator.</code><code class="sig-name descname">project</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state_vec</span></em>, <em class="sig-param"><span class="n">qubits</span></em>, <em class="sig-param"><span class="n">intprob</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects the state by assigning qubits to specified values.</p>
<p>The “measure” function does not project. This is nice when asking for
several samples. But the full behavior of a quantum state when undergoing
measurement includes a projection onto the result state. This is what
this function does. In practice, it is used for intermediary measurements.
(i.e within measure and reset gates)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_vec</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – The state vector to project, i.e the
one from which the results were sampled.</p></li>
<li><p><strong>qubits</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – The qubits that were measured, presented as a list
of integers. Without this info, we don’t know to what axes the result
corresponds.</p></li>
<li><p><strong>intprob</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>) – a tuple of the form (integer, probability). The
integer codes for the value that was measured on the qubits in the list
“qubits”. The probability that the measurement had to occur. It is
useful for renormalizing without having to recompute a norm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The projected state vector. The values of the qubits in the “qubits” list have been assigned to the measured values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qat.pylinalg.simulator.reset">
<code class="sig-prename descclassname">qat.pylinalg.simulator.</code><code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state_vec</span></em>, <em class="sig-param"><span class="n">qubits</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the value of the specified qubits to 0.</p>
<p>It works by measuring each
qubit, and then applying an X gate if the result is 1.</p>
<p>for one qubit, entirely equivalent to, in AQASM:</p>
<div class="line-block">
<div class="line">MEAS q[k] c[k]</div>
<div class="line">?c[k] : X q[k]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_vec</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – nd-array containing the full state
vector.</p></li>
<li><p><strong>qubits</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – list of integers, containing the qubits to reset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>a tuple composed of:</dt><dd><ul class="simple">
<li><p>state_vec(<cite>numpy.ndarray</cite>) the full state vector. the specified qubits
have been reset.</p></li>
<li><p>an integer: result of the measurement on the subset of qubits (when
converted to binary representation, it needs to have a width of
len(qubits)).</p></li>
<li><p>a float: probability the measurement had to occur.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(state_vec, int, prob)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qat.pylinalg.simulator.raise_break">
<code class="sig-prename descclassname">qat.pylinalg.simulator.</code><code class="sig-name descname">raise_break</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">op</span></em>, <em class="sig-param"><span class="n">op_pos</span></em>, <em class="sig-param"><span class="n">cbits</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.raise_break" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises break exception, as a result of a boolean classical formula being
evaluated to True.</p>
</dd></dl>

<dl class="py function">
<dt id="qat.pylinalg.simulator.mat2nparray">
<code class="sig-prename descclassname">qat.pylinalg.simulator.</code><code class="sig-name descname">mat2nparray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">matrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.pylinalg.simulator.mat2nparray" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts serialized matrix format into numpy array.</p>
<p>When extracted from the quantum circuit, gate matrices are not
directly numpy arrays. They are instances of
<code class="xref py py-class docutils literal notranslate"><span class="pre">qat.comm.datamodel.Matrix</span></code>, an internally-defined structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">qat.comm.datamodel.Matrix</span></code>) – The matrix, as extracted
rom circuit operation, to convert to <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> of shape (2*arity,2*arity) containing
the matrix data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It could directly return a <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> of the shape we
use in <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.tensordot()</span></code>, but as quantum gates are typically
represented as matrices, we kept this step.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../qat-opt.html" class="btn btn-neutral float-right" title="qat-opt: representation and encoding of combinatorial problems, QAOA" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../quameleon.html" class="btn btn-neutral float-left" title="QuameleonPlugin : emulating hardware constraints via a plugin" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Atos 2016-2020

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>