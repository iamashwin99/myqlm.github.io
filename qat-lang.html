<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qat.lang : Programming tools &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="static/contentui.css" type="text/css" />
      <link rel="stylesheet" href="static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
    <link rel="shortcut icon" href="static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="static/doctools.js"></script>
        <script src="static/sphinx_highlight.js"></script>
        <script src="static/contentui.js"></script>
        <script src="static/design-tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Arithmetic routines" href="qat-lang-arith.html" />
    <link rel="prev" title="qat-core: Core data structures and Abstract classes" href="qat-core.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> myQLM documentation
            <img src="static/myqlm-doc-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                myQLM-1.7.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorial_optimization_intro.html">Combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">List of notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Main objects: Jobs, Observables, Circuits…</a></li>
<li class="toctree-l1"><a class="reference internal" href="manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch_generators.html">Building advanced computation stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="qat-fermion.html">Digital quantum simulation for spin and fermionic systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Command-line tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source code documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="source_doc.html">Source code documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#quantum-application-toolchain-qat-python-libraries">Quantum Application ToolChain (QAT) Python libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#the-core-library">The core library</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="source_doc.html#the-programming-library">The programming library</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">qat.lang : Programming tools</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-program-class">The Program class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gate-structures">Gate structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quantum-types">Quantum Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-structures">Other structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qat.lang.AQASM.util">Utilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qat.lang.AQASM.misc">Gate set management and generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quantum-libraries">Quantum libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linker-and-low-level-circuit-manipulation">Linker and low level circuit manipulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-algorithms">Basic algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#the-device-library">The device library</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#generators">Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#plugins">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#qpus">QPUs</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#interoperability-with-other-frameworks">Interoperability with other frameworks</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#digital-quantum-simulation-tools">Digital quantum simulation tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#combinatorial-optimization-and-qaoa">Combinatorial optimization and QAOA</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/contrib.html">Contributing to myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/release-note.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="source_doc.html">Source code documentation</a> &raquo;</li>
      <li>qat.lang : Programming tools</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<span class="target" id="module-qat.lang"></span><section id="qat-lang-programming-tools">
<h1>qat.lang : Programming tools<a class="headerlink" href="#qat-lang-programming-tools" title="Permalink to this heading"></a></h1>
<section id="the-program-class">
<h2>The Program class<a class="headerlink" href="#the-program-class" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.</span></span><span class="sig-name descname"><span class="pre">Program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default_gate_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program" title="Permalink to this definition"></a></dt>
<dd><p>Class for quantum programs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>default_gate_set</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to False,
the Program is initialized with an empty gate set.
The gate set is updated dynamically when one applies
gates to the Program via the <cite>apply</cite> method.
Default to True.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.apply" title="Permalink to this definition"></a></dt>
<dd><p>Applies a <a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a> to a list of qbits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gate</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – The quantum gate to apply.</p></li>
<li><p><strong>*args</strong> – Variable length qbit list. Accepts any iterator
over <a class="reference internal" href="#qat.lang.AQASM.bits.Qbit" title="qat.lang.AQASM.bits.Qbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qbit</span></code></a> objects.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.calloc">
<span class="sig-name descname"><span class="pre">calloc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.calloc" title="Permalink to this definition"></a></dt>
<dd><p>Allocates a new classical bit register of the given size.
Returns the register.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (<em>int</em>) – The number of classical bits to allocate.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A fresh classical bit register of size <cite>size</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.bits.CRegister" title="qat.lang.AQASM.bits.CRegister"><code class="xref py py-class docutils literal notranslate"><span class="pre">CRegister</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.cbreak">
<span class="sig-name descname"><span class="pre">cbreak</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.cbreak" title="Permalink to this definition"></a></dt>
<dd><p>Conditional break.
The program execution will stop if and only if
the formula given as argument evaluates to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>formula</strong> (<a class="reference internal" href="#qat.lang.AQASM.bits.BoolFormula" title="qat.lang.AQASM.bits.BoolFormula"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolFormula</span></code></a>) – a boolean
formula</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.cc_apply">
<span class="sig-name descname"><span class="pre">cc_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cbit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.cc_apply" title="Permalink to this definition"></a></dt>
<dd><p>Conditional application of a quantum gate.
The quantum gate will be applied if and only if the
control classical bit given as first argument evaluates to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctrlbit</strong> (<a class="reference internal" href="#qat.lang.AQASM.bits.Cbit" title="qat.lang.AQASM.bits.Cbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cbit</span></code></a>) – The classical bit</p></li>
<li><p><strong>gate</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – The quantum gate</p></li>
<li><p><strong>*args</strong> – Variable length qbit list (see <a class="reference internal" href="#qat.lang.AQASM.Program.apply" title="qat.lang.AQASM.Program.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.comment">
<span class="sig-name descname"><span class="pre">comment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.comment" title="Permalink to this definition"></a></dt>
<dd><p>Add a comment inside the circuit.
The comment will appear in the AQASM export of the circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>message</strong> (<em>str</em>) – a string containing the comment</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.conjugate">
<span class="sig-name descname"><span class="pre">conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gate2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.conjugate" title="Permalink to this definition"></a></dt>
<dd><p>Apply a sequence of 3 gates. gate2 will be conjugated by gate1.
The two gates are required to have the same arity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gate1</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – a gate</p></li>
<li><p><strong>gate2</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – another gate</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.display">
<span class="sig-name descname"><span class="pre">display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.display" title="Permalink to this definition"></a></dt>
<dd><p>Transforms the program into a circuit and displays it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>kwargs</strong> – key word arguments passed to the <cite>display</cite> method of the circuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.export">
<span class="sig-name descname"><span class="pre">export</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.export" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Exports the Program in AQASM text format.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) – A file name</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.free_ancillae">
<span class="sig-name descname"><span class="pre">free_ancillae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.free_ancillae" title="Permalink to this definition"></a></dt>
<dd><p>Releases a set of ancillae</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.get_free_ancillae">
<span class="sig-name descname"><span class="pre">get_free_ancillae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.get_free_ancillae" title="Permalink to this definition"></a></dt>
<dd><p>Returns a collection of free ancillae</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.logic">
<span class="sig-name descname"><span class="pre">logic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cbit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">formula</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.logic" title="Permalink to this definition"></a></dt>
<dd><p>Performs a classical logic operation using classical bits
and stores the result in a classical bit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cbit</strong> (<a class="reference internal" href="#qat.lang.AQASM.bits.Cbit" title="qat.lang.AQASM.bits.Cbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cbit</span></code></a>) – the cbit that will store the result</p></li>
<li><p><strong>formula</strong> (<a class="reference internal" href="#qat.lang.AQASM.bits.BoolFormula" title="qat.lang.AQASM.bits.BoolFormula"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolFormula</span></code></a>) – A boolean
formula.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qbits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.measure" title="Permalink to this definition"></a></dt>
<dd><p>Applies a measurement operator.
All measurements are <span class="math notranslate nohighlight">\(Z\)</span> measurements (i.e in the computational
basis).
Qbits are simply collapsed and not destroyed (i.e they are still usable
afterward).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qbits</strong> (<em>list&lt;Qbit&gt;</em>) – The qubits to measure specified as a
list/register/array</p></li>
<li><p><strong>cbits</strong> – (list&lt;Cbit&gt;, optional): The classical bits in which to store
the result. Default to None. If defaulted/set to None, the
results will be stored in classical bits with matching indices.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.new_var">
<span class="sig-name descname"><span class="pre">new_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.new_var" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a new variable bound to the circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var_type</strong> (<em>type</em>) – The type of the variable.</p></li>
<li><p><strong>var_name</strong> (<em>str</em>) – The name of the variable.
Raises a <a class="reference internal" href="#qat.core.circuit_builder.builder.VariableNameNotAvailable" title="qat.core.circuit_builder.builder.VariableNameNotAvailable"><code class="xref py py-class docutils literal notranslate"><span class="pre">VariableNameNotAvailable</span></code></a>
if a variable with the same name is already bound to the circuit.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A variable</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="qat-core.html#qat.core.Variable" title="qat.core.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.qalloc">
<span class="sig-name descname"><span class="pre">qalloc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.qalloc" title="Permalink to this definition"></a></dt>
<dd><p>Allocates a new qbit register of the given size.
Returns the register.</p>
<p>If no constructor is provided, the register will
simply behave as an array of qubits.</p>
<p>The two implemented quantum types are <a class="reference internal" href="#qat.lang.AQASM.qint.QInt" title="qat.lang.AQASM.qint.QInt"><code class="xref py py-class docutils literal notranslate"><span class="pre">QInt</span></code></a>
and <a class="reference internal" href="#qat.lang.AQASM.qbool.QBoolArray" title="qat.lang.AQASM.qbool.QBoolArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBoolArray</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">QInt</span><span class="p">,</span> <span class="n">QBoolArray</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qbits</span><span class="p">)</span>
<span class="n">qint</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qint</span><span class="p">)</span>
<span class="n">qbools</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">QBoolArray</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qbools</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QReg</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">..</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="n">QInt</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">..</span><span class="n">q</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span>
<span class="n">QBoolArray</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">..</span><span class="n">q</span><span class="p">[</span><span class="mi">14</span><span class="p">])</span>
</pre></div>
</div>
<p>The main purpose of this wrapping process is to provide a higher
level interface for some quantum register, depending on the application.
This allows to generate complicated quantum circuits without having
to deal with low level administrative constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – the number of qbits to allocate.</p></li>
<li><p><strong>class_type</strong> (<em>type</em>) – the quantum type of the register</p></li>
<li><p><strong>kwargs</strong> – any keyword argument is passed to the constructor
of the quantum type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A fresh qbit register of size <cite>size</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.bits.QRegister" title="qat.lang.AQASM.bits.QRegister"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRegister</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qblist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cblist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.reset" title="Permalink to this definition"></a></dt>
<dd><p>Resets the value of a set of qbits to <span class="math notranslate nohighlight">\(|0\rangle\)</span>.
and/or a set of cbits to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qblist</strong> (<em>list&lt;Qbit&gt;</em>) – The list of qbits</p></li>
<li><p><strong>cblist</strong> (<em>list&lt;Cbit&gt;</em><em>, </em><em>optional</em>) – The list of cbits. Default to [].</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.Program.to_circ">
<span class="sig-name descname"><span class="pre">to_circ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">include_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_locks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_link</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comparison_eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box_routines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.Program.to_circ" title="Permalink to this definition"></a></dt>
<dd><p>Return a <a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a> implementing the program.</p>
<p>The circuit extraction consists
of three stages:</p>
<blockquote>
<div><ul>
<li><p><strong>Circuit generation</strong>: a simple circuit is extracted from the
Program object. Any call to an abstract gate will be
left untouched. All circuit implementation attached to
abstract gates definition will be ignored at this stage.</p></li>
<li><p><strong>Linking</strong>: this simple circuit is then
linked against:</p>
<blockquote>
<div><ul class="simple">
<li><p>the gate set aggregated by the program during
its construction</p></li>
<li><p>any other gate set/abstract gate/python module
passed as argument.</p></li>
</ul>
</div></blockquote>
<p>The linking process simply attach to each abstract
gate a circuit implementation using the function specified
at definition of the abstract gate.</p>
</li>
<li><p><strong>Inlining</strong>: these implementations are then inlined in place,
turning the circuit into a (potentially) very long sequence
of gates/operations. By default this step is skipped, as it is
very demanding.</p></li>
</ul>
</div></blockquote>
<p>All these steps can be controlled using various parameters detailed
below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>include_matrices</strong> (<em>bool</em><em>, </em><em>optional</em>) – if set to True,
matrices will be generated and included in the circuit.
Defaults to True.</p></li>
<li><p><strong>include_locks</strong> (<em>bool</em>) – If set to True, additional gates will be
added on the ancilla wire to signify lock and release of
the ancilla. Defaults to False. This can be used to debug
ancilla usage or further optimize the circuit later on.
Lock/release operations can be removed from the circuit via
the .remove_locks() method.</p></li>
<li><p><strong>do_link</strong> (<em>bool</em>) – if set to False, skips the linking step.
Default to True.</p></li>
<li><p><strong>inline</strong> (<em>bool</em>) – if set to False, no inlining/linking will happen.
Default to False.</p></li>
<li><p><strong>comparison_eps</strong> (<em>float</em>) – Optional argument to set the matrix/gate
parameters comparison threshold. If two parameters are
<cite>comparison_eps</cite> close, they will be considered
as identical, resulting in the indentification of their
correspondig gates (thus saving space and time).
Default value is 1e-20.</p></li>
<li><p><strong>box_routines</strong> (<em>bool</em>) – If set to True, routines will be systematically
boxed before being included inside the initial circuit
(the one generated during the <strong>Circuit generation</strong> step).
Setting this option to True can save up a lot of time for
repetitive circuits.</p></li>
<li><p><strong>**kwargs</strong> – other arguments passed to the linker. See below.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>submatrices_only</strong> (<em>bool</em>) – <p>if set to True,
only submatrices will be generated and included in the
circuit. Default to False.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Setting this argument to True will decrease (by a lot) the circuit
generation time.
For instance, using the default settings, a RZ rotation controlled
10 times will end up generating a matrix of
size (<span class="math notranslate nohighlight">\(2^{11} \times 2^{11}\)</span>). By setting this argument to True,
only a <span class="math notranslate nohighlight">\(2\times 2\)</span> matrix will be generated.
However, not all simulators are able to infer a matrix from
the structure of the gate.
In particular, this means that you should set this option to True
to simulate circuits on <a class="reference internal" href="myqlm_specific/qat-pylinalg.html#qat.pylinalg.PyLinalg" title="qat.pylinalg.PyLinalg"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyLinalg</span></code></a>.</p>
</div>
</p></li>
<li><p><strong>keep</strong> (<em>list&lt;str&gt;</em>) – if set to a list of gate names,
these gates won’t be inlined by the linker. Default to None.</p></li>
<li><p><strong>link</strong> (<em>list</em>) – a list of <a class="reference internal" href="#qat.lang.AQASM.gates.AbstractGate" title="qat.lang.AQASM.gates.AbstractGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractGate</span></code></a>,
<a class="reference internal" href="qat-core.html#qat.core.gate_set.GateSet" title="qat.core.gate_set.GateSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">GateSet</span></code></a>, or
python packages to pass to the linker.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A circuit implementing the program</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="gate-structures">
<h2>Gate structures<a class="headerlink" href="#gate-structures" title="Permalink to this heading"></a></h2>
<p>All classes describing unitary operators inherit from the <a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a> class.
This parent class contains very little information. Its primary function is to store information about control, dagger and other high-level gate operations. Since this class is not made to be used directly, we skip some part of its documentation.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.Gate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.gates.</span></span><span class="sig-name descname"><span class="pre">Gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.Gate" title="Permalink to this definition"></a></dt>
<dd><p>Mother class for all quantum gates/unitary operators.
This class should never be instantiated directly.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.Gate.conj">
<span class="sig-name descname"><span class="pre">conj</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.Gate.conj" title="Permalink to this definition"></a></dt>
<dd><p>Builds a new gate that is the complex conjugate
of the initial gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The conjugate of the gate.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.Gate.ctrl">
<span class="sig-name descname"><span class="pre">ctrl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbctrls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.Gate.ctrl" title="Permalink to this definition"></a></dt>
<dd><p>Builds a new gate that is a controlled version of the initial gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The same gate, but controlled.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.Gate.dag">
<span class="sig-name descname"><span class="pre">dag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.Gate.dag" title="Permalink to this definition"></a></dt>
<dd><p>Builds a new gate that is the dagger of the initial gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The dagger of the gate.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.Gate.trans">
<span class="sig-name descname"><span class="pre">trans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.Gate.trans" title="Permalink to this definition"></a></dt>
<dd><p>Builds a new gate that is the transpose
of the initial gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The transpose of the gate.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Another important class is the <a class="reference internal" href="#qat.lang.AQASM.gates.AbstractGate" title="qat.lang.AQASM.gates.AbstractGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractGate</span></code></a> class. This class provides a way to define new parametrized gates. Basically, an abstract gate describes a family of gates parametrized by a list of values of various types. The current list of admissible types contains: <code class="code docutils literal notranslate"><span class="pre">int</span></code>, <code class="code docutils literal notranslate"><span class="pre">float</span></code>, <code class="code docutils literal notranslate"><span class="pre">str</span></code></p>
<p>For instance, to declare a new <a class="reference internal" href="#qat.lang.AQASM.gates.AbstractGate" title="qat.lang.AQASM.gates.AbstractGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractGate</span></code></a> that describes a <span class="math notranslate nohighlight">\(R_z\)</span> rotation, we would write:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_rz</span> <span class="o">=</span> <span class="n">AbstractGate</span><span class="p">(</span><span class="s2">&quot;RZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">arity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>and use this new abstract gate as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_rz</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)(</span><span class="n">qbits_reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>It is possible to attach a matrix generator to the abstract gate in order to generate and include a matrix in the final circuit (if you want to be able to simulate the circuit for instance).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">matrix_gen</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)])</span>

<span class="n">my_rz</span> <span class="o">=</span> <span class="n">AbstractGate</span><span class="p">(</span><span class="s2">&quot;RZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">arity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">matrix_generator</span><span class="o">=</span><span class="n">matrix_gen</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.AbstractGate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.gates.</span></span><span class="sig-name descname"><span class="pre">AbstractGate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.AbstractGate" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This class is for advanced usage.</p>
</div>
<p>Abstract gate class. Abstract gates are used to
define gate constructors such as Rx, Ry, Rz, etc.</p>
<p>They behave as quantum gate constructing functions.</p>
<p>This class extends <a class="reference internal" href="qat-core.html#qat.core.gate_set.GateSignature" title="qat.core.gate_set.GateSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.gate_set.GateSignature</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.AbstractGate.set_dag">
<span class="sig-name descname"><span class="pre">set_dag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.AbstractGate.set_dag" title="Permalink to this definition"></a></dt>
<dd><p>Attaches a dagger recipe to the abstract gate.
The function passed as argument should:</p>
<ul class="simple">
<li><p>take as argument a sequence of parameters</p></li>
<li><p>return a new sequence of parameters corresponding
to the dagger of the gate.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_rz</span> <span class="o">=</span> <span class="n">AbstractGate</span><span class="p">(</span><span class="s2">&quot;MY_RZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">])</span>
<span class="n">my_rz</span><span class="o">.</span><span class="n">set_dag</span><span class="p">(</span><span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">theta</span><span class="p">])</span>
</pre></div>
</div>
<p>This function will be called when a .dag() method is called on
some <a class="reference internal" href="#qat.lang.AQASM.gates.ParamGate" title="qat.lang.AQASM.gates.ParamGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamGate</span></code></a>.</p>
<p>If the dag is not set, the abstract gate will make no
assumption on the structure of the dagger, and the standard
recursive structure from <a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a> will
be used.</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#qat.lang.AQASM.gates.ParamGate" title="qat.lang.AQASM.gates.ParamGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamGate</span></code></a> is generated through <a class="reference internal" href="#qat.lang.AQASM.gates.AbstractGate" title="qat.lang.AQASM.gates.AbstractGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractGate</span></code></a>. An abstract gate instantiated by a set of parameters (such as the my_rz(0.4) from above) returns a <a class="reference internal" href="#qat.lang.AQASM.gates.ParamGate" title="qat.lang.AQASM.gates.ParamGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamGate</span></code></a> carrying all the necessary information to build the correct abstract syntax tree of the gate.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.ParamGate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.gates.</span></span><span class="sig-name descname"><span class="pre">ParamGate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abstract_gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arity</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.ParamGate" title="Permalink to this definition"></a></dt>
<dd><p>Class for parametrized gates instantiated by some set of parameters.
Members of this class should be automatically
instantiated by the AbstractGate structure.
Only instantiate if you know what you are doing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>abstract_gate</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.AbstractGate" title="qat.lang.AQASM.gates.AbstractGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractGate</span></code></a>) – the mother
abstract gate</p></li>
<li><p><strong>arity</strong> (<em>int</em>) – the arity of the gate (can be set to None)</p></li>
<li><p><strong>*parameters</strong> (<em>list&lt;any&gt;</em>) – the list of parameters of the gate</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.ParamGate.dag">
<span class="sig-name descname"><span class="pre">dag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.ParamGate.dag" title="Permalink to this definition"></a></dt>
<dd><p>Builds a new gate that is the dagger of the initial gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The dagger of the gate.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.gates.ParamGate.display">
<span class="sig-name descname"><span class="pre">display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.gates.ParamGate.display" title="Permalink to this definition"></a></dt>
<dd><p>Displays the param gate (if the gate has a circuit generator).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>kwargs</strong> – key word arguments passed to the <cite>display</cite> method of the circuit</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Finally, the notion of gate is also extended to subcircuits via the <a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a> class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.routines.QRoutine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.routines.</span></span><span class="sig-name descname"><span class="pre">QRoutine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">routop_l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_wire</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancillae</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.routines.QRoutine" title="Permalink to this definition"></a></dt>
<dd><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a> represent subcircuits that behave as a Gate object.</p>
<p>The constructor takes no required arguments.</p>
<p>Applying a Gate or a <a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>
inside another routine is done through the
<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine.apply" title="qat.lang.AQASM.routines.QRoutine.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> method. Since a
<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a> can exist independently from any Program
there are is no notion of qbit allocation in a
<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>. Gates are thus applied on indices referring to
the inbound wires of the routine.</p>
<p class="rubric">Example</p>
<p>The following example shows how to create a QRoutine containing two gates
and use it repeatedly within a quantum circuit</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">QRoutine</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">CNOT</span>

<span class="n">routine</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">routine</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">routine</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">CNOT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">routine</span><span class="p">,</span> <span class="n">qbits</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">bl</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">bl</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total number of gates: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">ops</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">gates</span><span class="p">:</span>  <span class="mi">12</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.routines.QRoutine.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.routines.QRoutine.apply" title="Permalink to this definition"></a></dt>
<dd><p>Apply a quantum gate on a set of wires.
Wires are refered using integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gate</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – the quantum gate to apply</p></li>
<li><p><strong>*args</strong> (<em>any iterator over int</em>) – the wires to apply the gate on</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.routines.QRoutine.compute">
<span class="sig-name descname"><span class="pre">compute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.routines.QRoutine.compute" title="Permalink to this definition"></a></dt>
<dd><p>Opens a computation scope and returns a reference to this fresh scope.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>All scopes are lost when controlling/daggering a QRoutine.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is designed to be called inside a with statement in order
for the scope to be cleanly closed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">rout</span><span class="o">.</span><span class="n">compute</span><span class="p">():</span>
    <span class="n">rout</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">CNOT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># here the scope is closed</span>
<span class="n">rout</span><span class="o">.</span><span class="n">uncompute</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Directly calling the method will result in the scope never being closed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.routines.QRoutine.free_ancillae">
<span class="sig-name descname"><span class="pre">free_ancillae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.routines.QRoutine.free_ancillae" title="Permalink to this definition"></a></dt>
<dd><p>Return the ancillae qubits to an unused pool so that they can be reused again
in the routine. It is important that the ancilla qubits are in product
<span class="math notranslate nohighlight">\(|0\rangle\)</span> state when they are freed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> (<em>int/list&lt;int&gt;/quantum register</em>) – the set of ancillae to release</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.routines.QRoutine.get_free_ancillae">
<span class="sig-name descname"><span class="pre">get_free_ancillae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.routines.QRoutine.get_free_ancillae" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of ancillae qubits of length <cite>length</cite>.
If there are currently unused ancillae qubits in the list <cite>freed_ancillae</cite>,
they will be returned first. Then, allocate new wires if needed and set them as
ancillae.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>optional</em><em>, </em><em>int</em>) – the number of ancillae to allocate (default to 1)</p></li>
<li><p><strong>class_name</strong> (<em>optional</em><em>, </em><em>type</em>) – optionally, a quantum type to wrap the allocated ancillae
(e.g QInt, QBool, etc)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.routines.QRoutine.new_wires">
<span class="sig-name descname"><span class="pre">new_wires</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.routines.QRoutine.new_wires" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of fresh wires of length <cite>length</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>int</em>) – the number of fresh wires to return</p></li>
<li><p><strong>class_name</strong> (<em>type</em>) – a quantum type (optional)</p></li>
<li><p><strong>kwargs</strong> – additinal arguments are passed to the quantum type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a quantum register</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.bits.QRegister" title="qat.lang.AQASM.bits.QRegister"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRegister</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.routines.QRoutine.set_ancillae">
<span class="sig-name descname"><span class="pre">set_ancillae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.routines.QRoutine.set_ancillae" title="Permalink to this definition"></a></dt>
<dd><p>Tags some wires as ancillae.
This has two effects:</p>
<blockquote>
<div><ul class="simple">
<li><p>the public arity of the routine will be reduced to only consider                 the non-tagged wires as input/output wires</p></li>
<li><p>ancillae will be allocated at circuit generation (in consequence,                 the final number of qubits of the circuit                 might be larger than the number of qubits allocated inside the program)</p></li>
</ul>
</div></blockquote>
<p>For example, in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">()</span>
<span class="n">rout</span><span class="o">.</span><span class="n">set_ancillae</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>rout</cite> is a routine of arity 1 (since w1 has been tagged as ancilla).
In particular the following code will be a valid program:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">prog</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">rout</span><span class="p">,</span> <span class="n">qbits</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>
</pre></div>
</div>
<p>Moreover, the resulting <cite>circuit</cite> will be a circuit over 2 qubits (the ancilla
will be allocated during the contruction of the circuit).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.routines.QRoutine.uncompute">
<span class="sig-name descname"><span class="pre">uncompute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.routines.QRoutine.uncompute" title="Permalink to this definition"></a></dt>
<dd><p>Uncomputes the first computation scope on the scope stack and
pops it from the scope stack.</p>
</dd></dl>

</dd></dl>

</section>
<section id="quantum-types">
<span id="id1"></span><h2>Quantum Types<a class="headerlink" href="#quantum-types" title="Permalink to this heading"></a></h2>
<section id="quantum-boolean-and-expressions">
<h3>Quantum boolean and expressions<a class="headerlink" href="#quantum-boolean-and-expressions" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.qbool.</span></span><span class="sig-name descname"><span class="pre">QBool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBool" title="Permalink to this definition"></a></dt>
<dd><p>Class for quantum boolean type.</p>
<p>This class is not designed to be instantiated by hand, but rather
via the <cite>.qalloc</cite> method of the <a class="reference internal" href="#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program"><code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></a> class
or the <cite>.new_wires</cite> method of the <a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>
class.</p>
<p>Moreover, since allocation happens at the register level,
the <a class="reference internal" href="#qat.lang.AQASM.qbool.QBoolArray" title="qat.lang.AQASM.qbool.QBoolArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBoolArray</span></code></a> class should be used.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM.qbool</span> <span class="kn">import</span> <span class="n">QBoolArray</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">qbool_array</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">QBoolArray</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">qbool_array</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">qbool_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;qat.lang.AQASM.qbool.QBoolArray&#39;&gt;
&lt;class &#39;qat.lang.AQASM.qbool.QBool&#39;&gt;
</pre></div>
</div>
<p>See documentation of the <a class="reference internal" href="#qat.lang.AQASM.qbool.QClause" title="qat.lang.AQASM.qbool.QClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">QClause</span></code></a> class for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – the qubit index</p></li>
<li><p><strong>scope</strong> (<a class="reference internal" href="#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program"><code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></a>/<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>) – the
scope in which the allocation happened</p></li>
</ul>
</dd>
</dl>
<p>Instance attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong> (int): the index of the underlying qbit</p></li>
<li><p><strong>scope</strong> (<a class="reference internal" href="#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program"><code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></a>/<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>): the
scope in which the underlying qbit was declared</p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBool.cast">
<span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBool.cast" title="Permalink to this definition"></a></dt>
<dd><p>Cast an integer value as a boolean.</p>
<p>This method is used when casting execution samples to proper python values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>val</strong> (<em>int</em>) – some integer</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a boolean value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBool.cast_to">
<span class="sig-name descname"><span class="pre">cast_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBool.cast_to" title="Permalink to this definition"></a></dt>
<dd><p>Cast the register to another type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cls</strong> (<em>type</em>) – another quantum type class</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>some object constructed via <cite>cls</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
<p>For instance, the following piece of code casts a quantum boolean to a
quantum integer:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM.qbool</span> <span class="kn">import</span> <span class="n">QBoolArray</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM.qint</span> <span class="kn">import</span> <span class="n">QInt</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">QBoolArray</span><span class="p">)</span>
<span class="n">qbool</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">qint</span> <span class="o">=</span> <span class="n">qbool</span><span class="o">.</span><span class="n">cast_to</span><span class="p">(</span><span class="n">QInt</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBool.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBool.evaluate" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the QBool as an expression. Since QBools are trivial expression,
this simply returns <cite>self</cite> and the <cite>output</cite> argument is ignored (it is here simply
for compatibility with more complicated expressions).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>output</strong> (<a class="reference internal" href="#qat.lang.AQASM.bits.Qbit" title="qat.lang.AQASM.bits.Qbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qbit</span></code></a>) – an optional output qubit (ignored)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a QBool object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.qbool.QBool" title="qat.lang.AQASM.qbool.QBool"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBool.phase">
<span class="sig-name descname"><span class="pre">phase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBool.phase" title="Permalink to this definition"></a></dt>
<dd><p>Flips the phase of the state if and only if
the QBool is set to True.
Effectively applies a <span class="math notranslate nohighlight">\(Z\)</span> gate on <cite>self</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBool.qbits_list">
<span class="sig-name descname"><span class="pre">qbits_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBool.qbits_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns the list of underlying qubits (i.e <cite>[self]</cite>)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBoolArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.qbool.</span></span><span class="sig-name descname"><span class="pre">QBoolArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qbits_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBoolArray" title="Permalink to this definition"></a></dt>
<dd><p>Class describing an array of <a class="reference internal" href="#qat.lang.AQASM.qbool.QBool" title="qat.lang.AQASM.qbool.QBool"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBool</span></code></a>.</p>
<p>This class is not designed to be instantiated by hand, but rather
via the <cite>.qalloc</cite> method of the <a class="reference internal" href="#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program"><code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></a> class
or the <cite>.new_wires</cite> method of the <a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>
class.</p>
<p>See documentation of the <a class="reference internal" href="#qat.lang.AQASM.qbool.QClause" title="qat.lang.AQASM.qbool.QClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">QClause</span></code></a> class for more information.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM.qbool</span> <span class="kn">import</span> <span class="n">QBoolArray</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">qbool_array</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">QBoolArray</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">qbool_array</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;qat.lang.AQASM.qbool.QBoolArray&#39;&gt;
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<em>int</em>) – the starting index of the underlying register</p></li>
<li><p><strong>length</strong> (<em>int</em>) – the length of the underlying register</p></li>
<li><p><strong>scope</strong> (<a class="reference internal" href="#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program"><code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></a>/<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>) – the
scope in which the allocation happened</p></li>
<li><p><strong>qbit_list</strong> (<em>list</em><em> of </em><em>int</em>) – optionally a list of indexes of underlying qbits</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Instance attributes:</dt><dd><ul class="simple">
<li><p><strong>index</strong> (int): the index of the underlying qbit</p></li>
<li><p><strong>qbits</strong> (list of <a class="reference internal" href="#qat.lang.AQASM.qbool.QBool" title="qat.lang.AQASM.qbool.QBool"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBool</span></code></a>): a list of quantum booleans</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBoolArray.cast">
<span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBoolArray.cast" title="Permalink to this definition"></a></dt>
<dd><p>Cast some integer value as a list of bools.</p>
<p>This method is used when casting execution samples to proper python values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>val</strong> (<em>int</em>) – some integer</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of boolean values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of bools</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBoolArray.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBoolArray.evaluate" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the register as a boolean expression (i.e does nothing and returns
a list of the underlying qubits).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of quantum booleans</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of <a class="reference internal" href="#qat.lang.AQASM.qbool.QBool" title="qat.lang.AQASM.qbool.QBool"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QBoolArray.qbits_list">
<span class="sig-name descname"><span class="pre">qbits_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QBoolArray.qbits_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns the list of underlying qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of quantum booleans</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of <a class="reference internal" href="#qat.lang.AQASM.qbool.QBool" title="qat.lang.AQASM.qbool.QBool"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBool</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QClause">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.qbool.</span></span><span class="sig-name descname"><span class="pre">QClause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scope</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operand</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QClause" title="Permalink to this definition"></a></dt>
<dd><p>Class describing boolean formulae to manipulate qubits.</p>
<p>This class is not designed to be instantiated by hand.</p>
<p>Clauses are created by using the boolean
operators (and, or, xor, neg) applied on (an)other formula(e)
or qubits. Qubits are implicitly cast
toward boolean formulae.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM.qbool</span> <span class="kn">import</span> <span class="n">QBoolArray</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">wires</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">QBoolArray</span><span class="p">)</span>

<span class="n">and_formula</span> <span class="o">=</span> <span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">wires</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">and_formula</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;qat.lang.AQASM.qbool.QClause&#39;&gt;
</pre></div>
</div>
<p>A formula should be manipulated via:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>.evaluate</cite> method, in order to compute its value in superposition</p></li>
<li><p>the <cite>.phase</cite> method in order to perform a phase flip of all the basis states that
evaluate the formula to true</p></li>
<li><p>a <strong>with</strong> statement (see the example below)</p></li>
</ul>
</div></blockquote>
<p>Example of <cite>evaluate</cite>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM.qbool</span> <span class="kn">import</span> <span class="n">QBoolArray</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">wires</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">QBoolArray</span><span class="p">)</span>

<span class="n">and_formula</span> <span class="o">=</span> <span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">wires</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># By directly allocating an ancilla</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">and_formula</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>

<span class="c1"># Or by prior allocation of a result qubit</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">and_formula</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>

<span class="c1"># At this stage, `result` carries the logical AND between our two inputs</span>
</pre></div>
</div>
<p>Example of <cite>phase</cite>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM.qbool</span> <span class="kn">import</span> <span class="n">QBoolArray</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">wires</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">QBoolArray</span><span class="p">)</span>

<span class="n">and_formula</span> <span class="o">=</span> <span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">wires</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">and_formula</span><span class="o">.</span><span class="n">phase</span><span class="p">()</span>
<span class="c1"># At this stage, all classical states such that the first two qubits</span>
<span class="c1"># are set to 1 have their phase flipped</span>
</pre></div>
</div>
<p>Example of <strong>with</strong> statement conditional:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span><span class="p">,</span> <span class="n">CNOT</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM.qbool</span> <span class="kn">import</span> <span class="n">QBoolArray</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">wires</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">QBoolArray</span><span class="p">)</span>

<span class="n">and_formula</span> <span class="o">=</span> <span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">wires</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">with</span> <span class="n">and_formula</span> <span class="k">as</span> <span class="n">condition</span><span class="p">:</span>
    <span class="n">CNOT</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

<span class="c1"># We evaluated the expression, got a qbit `condition` carrying the result</span>
<span class="c1"># and store the result in `output`</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QClause.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QClause.evaluate" title="Permalink to this definition"></a></dt>
<dd><p>Builds a circuit evaluating the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>output</strong> (optional, <a class="reference internal" href="#qat.lang.AQASM.bits.Qbit" title="qat.lang.AQASM.bits.Qbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qbit</span></code></a>) – an output qbit</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>a quantum boolean carrying the</dt><dd><p>result of the evaluation</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.bits.Qbit" title="qat.lang.AQASM.bits.Qbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qbit</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QClause.phase">
<span class="sig-name descname"><span class="pre">phase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QClause.phase" title="Permalink to this definition"></a></dt>
<dd><p>Flips the phase if and only if the expression/qbits evaluates to True.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qbool.QClause.qbits_list">
<span class="sig-name descname"><span class="pre">qbits_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qbool.QClause.qbits_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of underlying qbits.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of qbits</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of Qbits</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="quantum-integers">
<h3>Quantum integers<a class="headerlink" href="#quantum-integers" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QInt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.qint.</span></span><span class="sig-name descname"><span class="pre">QInt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_bit_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qbits_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QInt" title="Permalink to this definition"></a></dt>
<dd><p>Class for quantum integer type. The qubit list in a QInt is by default encoded such that the
most significant bit is on the left. The order can be reversed using the <cite>reverse_bit_order</cite> argument.</p>
<p>As other quantum types, this class is not designed to be constructed by hand, but rather
via the <cite>.qalloc</cite> method of the <a class="reference internal" href="#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program"><code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></a> class
or the <cite>.new_wires</cite> method of the <a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>
class.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM.qint</span> <span class="kn">import</span> <span class="n">QInt</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">qint</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qint</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">qint</span><span class="p">))</span>

<span class="c1"># or, with reversed bit order:</span>
<span class="n">qint</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">,</span> <span class="n">reverse_bit_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>QInt(q[0]..q[9]) &lt;class &#39;qat.lang.AQASM.qint.QInt&#39;&gt;
</pre></div>
</div>
<p>Quantum integers have two sets of overloaded operators:</p>
<blockquote>
<div><ul class="simple">
<li><p>arithmetic operators (<cite>+</cite> and <cite>*</cite>): combine <a class="reference internal" href="#qat.lang.AQASM.qint.QInt" title="qat.lang.AQASM.qint.QInt"><code class="xref py py-class docutils literal notranslate"><span class="pre">QInt</span></code></a> and/or <a class="reference internal" href="#qat.lang.AQASM.qint.QArithExp" title="qat.lang.AQASM.qint.QArithExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">QArithExp</span></code></a>
to produce a <a class="reference internal" href="#qat.lang.AQASM.qint.QArithExp" title="qat.lang.AQASM.qint.QArithExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">QArithExp</span></code></a>. See documentation of <a class="reference internal" href="#qat.lang.AQASM.qint.QArithExp" title="qat.lang.AQASM.qint.QArithExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">QArithExp</span></code></a> for more details.</p></li>
<li><p>comparison operators (&lt;,&gt;,&lt;=,&gt;=,==,!=): combine a <a class="reference internal" href="#qat.lang.AQASM.qint.QInt" title="qat.lang.AQASM.qint.QInt"><code class="xref py py-class docutils literal notranslate"><span class="pre">QInt</span></code></a>/<a class="reference internal" href="#qat.lang.AQASM.qint.QArithExp" title="qat.lang.AQASM.qint.QArithExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">QArithExp</span></code></a> and or a
classical <code class="code docutils literal notranslate"><span class="pre">int</span></code> in order to produce a comparison expression, <a class="reference internal" href="#qat.lang.AQASM.qint.QCompExp" title="qat.lang.AQASM.qint.QCompExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">QCompExp</span></code></a>,
that behave similarly to a <a class="reference internal" href="#qat.lang.AQASM.qbool.QClause" title="qat.lang.AQASM.qbool.QClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">QClause</span></code></a> and can be thus used to
construct oracles or conditionals.</p></li>
</ul>
</div></blockquote>
<p>Moreover, the <cite>+=</cite> and <cite>-=</cite> operators are also overloaded and triggers a circuit evaluating
the right-hand term and
adding it to the quantum integer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM.qint</span> <span class="kn">import</span> <span class="n">QInt</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">qint1</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="n">qint2</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="n">qint3</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>

<span class="c1"># This does nothing</span>
<span class="n">qint1</span> <span class="o">+</span> <span class="n">qint2</span>

<span class="c1"># This generates a circuit that adds qint1 in qint3 and qint2 in qint3</span>
<span class="n">qint3</span> <span class="o">+=</span> <span class="n">qint1</span> <span class="o">+</span> <span class="n">qint2</span>

<span class="c1"># This generates a circuit that adds -qint1 in qint3 and -qint2 in qint3</span>
<span class="n">qint3</span> <span class="o">-=</span> <span class="n">qint1</span> <span class="o">+</span> <span class="n">qint2</span>
</pre></div>
</div>
<p>Comparisons results can be used exactly as <a class="reference internal" href="#qat.lang.AQASM.qbool.QClause" title="qat.lang.AQASM.qbool.QClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">QClause</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM.qint</span> <span class="kn">import</span> <span class="n">QInt</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">qint1</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="n">qint2</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>

<span class="c1"># Flips the phase of states such that qint1 is smaller than 3</span>
<span class="p">(</span><span class="n">qint1</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">phase</span><span class="p">()</span>

<span class="c1"># Flips the phase of states such that qint1 + qint2 is smaller than 14</span>
<span class="p">(</span><span class="n">qint1</span> <span class="o">+</span> <span class="n">qint2</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">)</span><span class="o">.</span><span class="n">phase</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<em>int</em>) – the start index of the underlying register</p></li>
<li><p><strong>length</strong> (<em>int</em>) – the length of the integer</p></li>
<li><p><strong>scope</strong> (<a class="reference internal" href="#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program"><code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></a>/<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>) – the
scope in which the allocation happened</p></li>
<li><p><strong>reverse_bit_order</strong> (<em>bool</em>) – if set to True, reverse the bit order of the integer.</p></li>
</ul>
</dd>
</dl>
<p>Instance attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>scope</strong> (<a class="reference internal" href="#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program"><code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></a>/<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>): the
scope in which the underlying qbit was declared</p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QInt.cast">
<span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QInt.cast" title="Permalink to this definition"></a></dt>
<dd><p>Casts some integer value into some other integer value with the correct bit-order.
This is used when casting execution samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>val</strong> (<em>int</em>) – some integer</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QInt.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbqbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QInt.evaluate" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the QInt as a formula. Effectively does nothing and returns a copy of <cite>self</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QInt.qbits_list">
<span class="sig-name descname"><span class="pre">qbits_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QInt.qbits_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns the underlying list of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of quantum booleans</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of <a class="reference internal" href="#qat.lang.AQASM.bits.Qbit" title="qat.lang.AQASM.bits.Qbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qbit</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QInt.set_value">
<span class="sig-name descname"><span class="pre">set_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QInt.set_value" title="Permalink to this definition"></a></dt>
<dd><p>Sets the QInt to some classical value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method assumes that the QInt is unitialized (i.e is still in state <span class="math notranslate nohighlight">\(|0\rangle\)</span>).
Effectively, the register is xored with the classical value.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>val</strong> (<em>int</em>) – some integer value</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QArithExp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.qint.</span></span><span class="sig-name descname"><span class="pre">QArithExp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scope</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_bit_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QArithExp" title="Permalink to this definition"></a></dt>
<dd><p>Class describing arithmetic expressions whose operands contain quantum integers.</p>
<p>This class is not designed to be instantiated by hand, but rather built via
the addition, substraction, and multiplication of quantum integers with
other quantum integers or python integers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span><span class="p">,</span> <span class="n">QInt</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">qint</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">qint</span> <span class="o">+</span> <span class="mi">33</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;qat.lang.AQASM.qint.QArithExp&#39;&gt;
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QArithExp.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbqbit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QArithExp.evaluate" title="Permalink to this definition"></a></dt>
<dd><p>Builds a piece of circuit evaluating the arithmetic expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nbqbits</strong> (<em>optional</em><em>, </em><em>int</em>) – the number of qbits of the output
register.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QCompExp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.qint.</span></span><span class="sig-name descname"><span class="pre">QCompExp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scope</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QCompExp" title="Permalink to this definition"></a></dt>
<dd><p>Class describing quantum comparison expressions to manipulate quantum integers.</p>
<p>This class is not designed to be instantiated by hand, but rather built via
comparison of quantum integers (with other quantum integers or classical
values) using the standard comparison operators.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">QRoutine</span><span class="p">,</span> <span class="n">QInt</span>

<span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">qint</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">qint</span> <span class="o">&lt;</span> <span class="mi">33</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;qat.lang.AQASM.qint.QCompExp&#39;&gt;
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QCompExp.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QCompExp.evaluate" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the comparison operator and stores the result in a temporary Qbit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>output</strong> (<em>optional</em><em>, </em><a class="reference internal" href="#qat.lang.AQASM.bits.Qbit" title="qat.lang.AQASM.bits.Qbit"><em>Qbit</em></a>) – an optional output qubit. If no output is specified,
a temporary Qbit will be used and returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the output qbit</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.bits.Qbit" title="qat.lang.AQASM.bits.Qbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qbit</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QCompExp.phase">
<span class="sig-name descname"><span class="pre">phase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QCompExp.phase" title="Permalink to this definition"></a></dt>
<dd><p>Flips the phase if and only if the expression evaluates to True.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.qint.QCompExp.qbits_list">
<span class="sig-name descname"><span class="pre">qbits_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.qint.QCompExp.qbits_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns the underlying list of qubits</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="other-structures">
<h2>Other structures<a class="headerlink" href="#other-structures" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.bits.Qbit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.bits.</span></span><span class="sig-name descname"><span class="pre">Qbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.bits.Qbit" title="Permalink to this definition"></a></dt>
<dd><p>Class for qbits.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.bits.QRegister">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.bits.</span></span><span class="sig-name descname"><span class="pre">QRegister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qbits_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.bits.QRegister" title="Permalink to this definition"></a></dt>
<dd><p>Class for registers of qbits. They should only be
declared through the qalloc method of the Program class.
Qbits inside a register can be accessed
similarly to elements of an array (i.e using brackets and slices).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.bits.CRegister">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.bits.</span></span><span class="sig-name descname"><span class="pre">CRegister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.bits.CRegister" title="Permalink to this definition"></a></dt>
<dd><p>Class for registers of classical bits. They should only be declared
through the calloc method of the AQASM class
Cbits inside a register can be accessed similarly
to elements of an array (i.e using brackets and slices).</p>
</dd></dl>

<section id="classical-bits-and-boolean-formulae">
<h3>Classical bits and Boolean formulae<a class="headerlink" href="#classical-bits-and-boolean-formulae" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.bits.Cbit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.bits.</span></span><span class="sig-name descname"><span class="pre">Cbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.bits.Cbit" title="Permalink to this definition"></a></dt>
<dd><p>Class for cbits.</p>
<p>Cbits can be composed via logical operator to form Boolean formulae.</p>
<p>See <a class="reference internal" href="#qat.lang.AQASM.bits.BoolFormula" title="qat.lang.AQASM.bits.BoolFormula"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolFormula</span></code></a> for examples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – the index of the classical bit</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.bits.BoolFormula">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.bits.</span></span><span class="sig-name descname"><span class="pre">BoolFormula</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.bits.BoolFormula" title="Permalink to this definition"></a></dt>
<dd><p>Class describing boolean formulae to manipulate classical bits.</p>
<p>This class is not designed to be instantiated by hand, but rather via
composition of <a class="reference internal" href="#qat.lang.AQASM.bits.Cbit" title="qat.lang.AQASM.bits.Cbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cbit</span></code></a> via logical operators.</p>
<p>Formulae are created by using the classical boolean
operators (and, or, xor, neg) applied on (an)other formula(e)
or classical bits.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span>

<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">cbits</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">calloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">and_expr</span> <span class="o">=</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">and_expr</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">and_expr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;qat.lang.AQASM.bits.BoolFormula&#39;&gt;
(c[0] &amp; c[1])
</pre></div>
</div>
<p>These objects are used in various pyAQASM instructions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.bits.BoolFormula.cbits_list">
<span class="sig-name descname"><span class="pre">cbits_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.bits.BoolFormula.cbits_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns the list of cbits appearing in the formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of <a class="reference internal" href="#qat.lang.AQASM.bits.Cbit" title="qat.lang.AQASM.bits.Cbit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cbit</span></code></a></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.AQASM.bits.BoolFormula.to_thrift">
<span class="sig-name descname"><span class="pre">to_thrift</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.bits.BoolFormula.to_thrift" title="Permalink to this definition"></a></dt>
<dd><p>Returns a thrift compatible string representation of the formula.</p>
<p>This method is called in order to produce a seralizable representation
of the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a string representation of the formula</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="exceptions">
<h3>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this heading"></a></h3>
<p>This exception is defined in <cite>qat.core</cite> but related to <cite>qat.lang</cite>:</p>
<dl class="py class">
<dt class="sig sig-object py" id="qat.core.circuit_builder.builder.VariableNameNotAvailable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.core.circuit_builder.builder.</span></span><span class="sig-name descname"><span class="pre">VariableNameNotAvailable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.core.circuit_builder.builder.VariableNameNotAvailable" title="Permalink to this definition"></a></dt>
<dd><p>Exception raised when a variable is redefined using the same name.</p>
</dd></dl>

</section>
</section>
<section id="module-qat.lang.AQASM.util">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-qat.lang.AQASM.util" title="Permalink to this heading"></a></h2>
<p>This module contains a few utilitaries</p>
<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.AQASM.util.suppr_ctrl">
<span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.util.</span></span><span class="sig-name descname"><span class="pre">suppr_ctrl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rout</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.util.suppr_ctrl" title="Permalink to this definition"></a></dt>
<dd><p>Builds a functionally equivalent quantum routine such
that no gate in this routine has more that “depth” control qbits.
It uses an ancillary register to Toffoli-fold the control qbits.
The number of ancillas to add is (in the worst case)
equal to (maximum number of ctrl to remove) -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rout</strong> (<a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a>) – a quantum routine</p></li>
<li><p><strong>depth</strong> (<em>int</em><em>, </em><em>optional</em>) – the maximal number of control to tolerate (default = 1)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a quantum routine</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.AQASM.util.toffoli_fold">
<span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.util.</span></span><span class="sig-name descname"><span class="pre">toffoli_fold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nb_qbits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.util.toffoli_fold" title="Permalink to this definition"></a></dt>
<dd><p>Returns a quantum routine that, given a data register of length <span class="math notranslate nohighlight">\(n\)</span>
and an ancilla register,
applies Toffoli gates on the data register in order to compute
a logical AND of all its qbits
inside a single ancillary qbit. May use up to <span class="math notranslate nohighlight">\(n-1\)</span> ancillary qbits (worst case scenario).
The resulting qbits is always the last qbit (hence of index arity - 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nb_qbits</strong> (<em>int</em>) – the size of the register to fold</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a quantum routine performing the fold</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qat.lang.AQASM.misc">
<span id="gate-set-management-and-generation"></span><h2>Gate set management and generation<a class="headerlink" href="#module-qat.lang.AQASM.misc" title="Permalink to this heading"></a></h2>
<p>This module contains various tools and decorator to turn functions into gates</p>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.AQASM.misc.build_gate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.misc.</span></span><span class="sig-name descname"><span class="pre">build_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.misc.build_gate" title="Permalink to this definition"></a></dt>
<dd><p>A wrapper class lifting functions into AbstractGates with a circuit
implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func</strong> (<em>function</em>) – an annotated function returning a QRoutine</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling the decorated function will return an AbstractGate.</p>
<p>The underlying QRoutine can be referred to by using a tilde before
the function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@build_gate</span>
<span class="k">def</span> <span class="nf">my_gate</span><span class="p">(</span><span class="n">a</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FOO&#39;</span><span class="p">:</span>
    <span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">rout</span>

<span class="n">my_gate</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># will return an AbstractGate object, instantiated</span>
            <span class="c1"># with parameter 10</span>
<span class="p">(</span><span class="o">~</span><span class="n">my_gate</span><span class="p">)(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># will return a QRoutine object</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.AQASM.misc.generate_gate_set">
<span class="sig-prename descclassname"><span class="pre">qat.lang.AQASM.misc.</span></span><span class="sig-name descname"><span class="pre">generate_gate_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.AQASM.misc.generate_gate_set" title="Permalink to this definition"></a></dt>
<dd><p>Generates a gate set from a list of various arguments.
Arguments can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>GateSignature/AbstractGates</p></li>
<li><p>build_gates wrappers</p></li>
<li><p>python modules</p></li>
</ul>
</div></blockquote>
<p>In this case it iterates through its scope and gathers all the build_gate objects
(i.e all the decorated functions).</p>
</dd></dl>

</section>
<section id="quantum-libraries">
<h2>Quantum libraries<a class="headerlink" href="#quantum-libraries" title="Permalink to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="qat-lang-arith.html">Arithmetic routines</a><ul>
<li class="toctree-l2"><a class="reference internal" href="qat-lang-arith.html#module-qat.lang.AQASM.qftarith">QFT-based arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.qftarith.QFT"><code class="docutils literal notranslate"><span class="pre">QFT()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.qftarith.add"><code class="docutils literal notranslate"><span class="pre">add()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.qftarith.add_const"><code class="docutils literal notranslate"><span class="pre">add_const()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.qftarith.mult"><code class="docutils literal notranslate"><span class="pre">mult()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.qftarith.mult_const"><code class="docutils literal notranslate"><span class="pre">mult_const()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="qat-lang-arith.html#module-qat.lang.AQASM.classarith">Carry-based arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.classarith.cuccaro_add"><code class="docutils literal notranslate"><span class="pre">cuccaro_add()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.classarith.add"><code class="docutils literal notranslate"><span class="pre">add()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.classarith.add_const"><code class="docutils literal notranslate"><span class="pre">add_const()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="qat-lang-arith.html#module-qat.lang.AQASM.arithmetic">Agnostic/High-level arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.arithmetic.modular_exp"><code class="docutils literal notranslate"><span class="pre">modular_exp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.arithmetic.mult_const_mod"><code class="docutils literal notranslate"><span class="pre">mult_const_mod()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.arithmetic.add_const_mod"><code class="docutils literal notranslate"><span class="pre">add_const_mod()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.arithmetic.mult_const"><code class="docutils literal notranslate"><span class="pre">mult_const()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-arith.html#qat.lang.AQASM.arithmetic.add_mod"><code class="docutils literal notranslate"><span class="pre">add_mod()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="qat-lang-other.html">State preparation and QRAM circuits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="qat-lang-other.html#qat.lang.models.KPTree"><code class="docutils literal notranslate"><span class="pre">KPTree</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="qat-lang-other.html#qat.lang.models.KPTree.get_routine"><code class="docutils literal notranslate"><span class="pre">KPTree.get_routine()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="qat-lang-other.html#references">References</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="linker-and-low-level-circuit-manipulation">
<h2>Linker and low level circuit manipulation<a class="headerlink" href="#linker-and-low-level-circuit-manipulation" title="Permalink to this heading"></a></h2>
<p>In pyAQASM, gates can be specified using various representations.
They can be purely abstract (a name and a set of parameter values, such as <cite>RZ</cite>, <cite>[PI/2]</cite>). To this abstract syntax, one can attach a matrix, or even a subcircuit that implements this gate (this is the case of adders of the arithmetic library for instance).</p>
<p>Circuits are generated in two steps:
- first a skeleton of the circuit is generated (for instance adders will be gates called <cite>ADD</cite> in this skeleton)
- then a subcircuit is generated and attached to this abtract gate.</p>
<p>This second step is handled by a class called <cite>Linker</cite>. It can be useful in some settings to manipulate this <cite>Linker</cite> object in order to replace gates by subcircuits, or to generate matrices in order to simulate the circuit.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qat.lang.linking.linker.Linker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.lang.linking.linker.</span></span><span class="sig-name descname"><span class="pre">Linker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">link</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">submatrices_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_locks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.linking.linker.Linker" title="Permalink to this definition"></a></dt>
<dd><p>The purpose of a linker is to crawl a circuit and attach implementations to gates.
These implementations are specified via a <a class="reference internal" href="qat-core.html#qat.core.gate_set.GateSet" title="qat.core.gate_set.GateSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">GateSet</span></code></a> object
(more or less a collection of <a class="reference internal" href="#qat.lang.AQASM.gates.AbstractGate" title="qat.lang.AQASM.gates.AbstractGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractGate</span></code></a>).</p>
<p>The main method of this class is the <cite>.link</cite> method.</p>
<p>The following example uses a linker to replace CNOT gates by H and CZ gates:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qat.core.gate_set</span> <span class="kn">import</span> <span class="n">GateSet</span>
<span class="kn">from</span> <span class="nn">qat.lang.linking.linker</span> <span class="kn">import</span> <span class="n">Linker</span>

<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">qbits</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="nd">@build_gate</span><span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="n">arity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_cnot_implementation</span><span class="p">():</span>
    <span class="n">rout</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
    <span class="n">wires</span> <span class="o">=</span> <span class="n">rout</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">rout</span><span class="o">.</span><span class="n">compute</span><span class="p">():</span>
        <span class="n">H</span><span class="p">(</span><span class="n">wires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">CSIGN</span><span class="p">(</span><span class="n">wires</span><span class="p">)</span>
    <span class="n">rout</span><span class="o">.</span><span class="n">uncompute</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">rout</span>

<span class="c1"># We initialize a Linker with an empty gate set since we want</span>
<span class="c1"># to override the default CNOT implementation</span>
<span class="n">linker</span> <span class="o">=</span> <span class="n">Linker</span><span class="p">(</span><span class="n">gate_set</span><span class="o">=</span><span class="n">GateSet</span><span class="p">())</span>
<span class="n">linker</span><span class="o">.</span><span class="n">add_signature</span><span class="p">(</span><span class="n">my_cnot_implementation</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Before linking:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">iterate_simple</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

<span class="n">linker</span><span class="o">.</span><span class="n">link</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After linking:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">iterate_simple</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Before</span> <span class="n">linking</span><span class="p">:</span>
<span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">After</span> <span class="n">linking</span><span class="p">:</span>
<span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="p">(</span><span class="s1">&#39;CSIGN&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gate_set</strong> (<a class="reference internal" href="qat-core.html#qat.core.gate_set.GateSet" title="qat.core.gate_set.GateSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">GateSet</span></code></a>) – A gate set to start the linking
with. Optional. Defaults to the default pyAQASM gate set.</p></li>
<li><p><strong>include_matrices</strong> (<em>bool</em><em>, </em><em>optional</em>) – if set to True,
matrices will be generated and included in the circuit. Defaults to True.</p></li>
<li><p><strong>keep</strong> (<em>list&lt;str&gt;</em>) – if set to a list of gate names,
these gates will be skipped by the linker. Default to None.</p></li>
<li><p><strong>link</strong> (<em>list</em>) – a list of <a class="reference internal" href="#qat.lang.AQASM.gates.AbstractGate" title="qat.lang.AQASM.gates.AbstractGate"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractGate</span></code></a>, <a class="reference internal" href="qat-core.html#qat.core.gate_set.GateSet" title="qat.core.gate_set.GateSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">GateSet</span></code></a>, or
python modules to pass to the linker.</p></li>
<li><p><strong>submatrices_only</strong> (<em>bool</em>) – if set to True,
only submatrices will be generated and included in the circuit. For instance a CTRL(Y) will only
generate the matrix for Y, thus saving memory. Default to True.</p></li>
<li><p><strong>inline</strong> (<em>bool</em><em>, </em><em>optional</em>) – if set to True, subcircuit implementations will be inlined in the main body of the circuit.
This might increase the memory footprint of the circuit and linking cost. Default to False.</p></li>
<li><p><strong>include_locks</strong> (<em>bool</em><em>, </em><em>optional</em>) – if set to False, removes all lock/release operators after the linking process.
If set to True, these operators will remain. These operators are here for debug purpose only. Defaults to False.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.linking.linker.Linker.add_signature">
<span class="sig-name descname"><span class="pre">add_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate_signature</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.linking.linker.Linker.add_signature" title="Permalink to this definition"></a></dt>
<dd><p>Adds a gate signature to the current gate set of the Linker.
This gate should not be present in the current gate set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gate_signature</strong> (<a class="reference internal" href="qat-core.html#qat.core.gate_set.GateSignature" title="qat.core.gate_set.GateSignature"><code class="xref py py-class docutils literal notranslate"><span class="pre">GateSignature</span></code></a>) – a gate signature</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.linking.linker.Linker.clear_gate_set">
<span class="sig-name descname"><span class="pre">clear_gate_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default_gates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.linking.linker.Linker.clear_gate_set" title="Permalink to this definition"></a></dt>
<dd><p>Resets the content of the internal gate set of the Linker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>default_gates</strong> (<em>bool</em>) – If set to True, the default gate set of pyAQASM
will be included in the fresh gate set. Optional. Defaults to True.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.linking.linker.Linker.compile">
<span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_specs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.linking.linker.Linker.compile" title="Permalink to this definition"></a></dt>
<dd><p>Compiles a Batch into another Batch according to
some hardware specs</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.linking.linker.Linker.link">
<span class="sig-name descname"><span class="pre">link</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.linking.linker.Linker.link" title="Permalink to this definition"></a></dt>
<dd><p>Uses the internal gate set of the Linker to link gate implementations.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The linking happens in place (thus modifies the input circuit).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circuit</strong> (<a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Circuit</span></code></a>) – a quantum circuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.linking.linker.Linker.link_gates">
<span class="sig-name descname"><span class="pre">link_gates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.linking.linker.Linker.link_gates" title="Permalink to this definition"></a></dt>
<dd><p>Uses the internal gate set of the Linker to instantiate the gates of a circuit.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The linking happens in place (thus modifies the input circuit).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circuit</strong> (<a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Circuit</span></code></a>) – a quantum circuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.linking.linker.Linker.link_matrices">
<span class="sig-name descname"><span class="pre">link_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.linking.linker.Linker.link_matrices" title="Permalink to this definition"></a></dt>
<dd><p>Link the matrix implementations to the gate definitions of a circuit.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The linking happens in place (thus modifies the input circuit).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circuit</strong> (<a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.core.Circuit</span></code></a>) – a quantum circuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.lang.linking.linker.Linker.set_gate_set">
<span class="sig-name descname"><span class="pre">set_gate_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.linking.linker.Linker.set_gate_set" title="Permalink to this definition"></a></dt>
<dd><p>Overrides the internal gate set with a new gate set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gate_set</strong> (<a class="reference internal" href="qat-core.html#qat.core.gate_set.GateSet" title="qat.core.gate_set.GateSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">GateSet</span></code></a>) – a gate set</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="basic-algorithms">
<h2>Basic algorithms<a class="headerlink" href="#basic-algorithms" title="Permalink to this heading"></a></h2>
<p>There are a few basic algorithms present in the <cite>qat.lang.algorithms</cite> module:</p>
<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.algorithms.amplification_step">
<span class="sig-prename descclassname"><span class="pre">qat.lang.algorithms.</span></span><span class="sig-name descname"><span class="pre">amplification_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oracle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.algorithms.amplification_step" title="Permalink to this definition"></a></dt>
<dd><p>Builds a routine that performs a single amplification step.
By default the diffusion operator is Grover’s diffusion.</p>
<p>If the <cite>state_prep</cite> argument is specified, it will be used to perform the following Householder transform instead:</p>
<div class="math notranslate nohighlight">
\[2\left(U|0\rangle\langle 0|U^\dagger\right) - I\]</div>
<p>where <span class="math notranslate nohighlight">\(U\)</span> is the unitary operator implemented by <cite>state_prep</cite>.</p>
<p>This method can be used to easily build a Grover search program:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">QInt</span><span class="p">,</span> <span class="n">QRoutine</span><span class="p">,</span> <span class="n">H</span>
<span class="kn">from</span> <span class="nn">qat.lang.algorithms</span> <span class="kn">import</span> <span class="n">amplification_step</span>


<span class="n">nbits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">oracle</span> <span class="o">=</span> <span class="n">QRoutine</span><span class="p">()</span>
<span class="n">reg1</span> <span class="o">=</span> <span class="n">oracle</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="n">nbits</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="n">reg2</span> <span class="o">=</span> <span class="n">oracle</span><span class="o">.</span><span class="n">new_wires</span><span class="p">(</span><span class="n">nbits</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="p">(</span><span class="n">reg1</span> <span class="o">==</span> <span class="n">reg2</span><span class="p">)</span><span class="o">.</span><span class="n">phase</span><span class="p">()</span>

<span class="n">step</span> <span class="o">=</span> <span class="n">amplification_step</span><span class="p">(</span><span class="n">oracle</span><span class="p">)</span>

<span class="n">grover</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">reg1</span> <span class="o">=</span> <span class="n">grover</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="n">nbits</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="n">reg2</span> <span class="o">=</span> <span class="n">grover</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="n">nbits</span><span class="p">,</span> <span class="n">QInt</span><span class="p">)</span>
<span class="k">for</span> <span class="n">qbit</span> <span class="ow">in</span> <span class="n">reg1</span><span class="p">:</span>
    <span class="n">H</span><span class="p">(</span><span class="n">qbit</span><span class="p">)</span>
<span class="k">for</span> <span class="n">qbit</span> <span class="ow">in</span> <span class="n">reg2</span><span class="p">:</span>
    <span class="n">H</span><span class="p">(</span><span class="n">qbit</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">step</span><span class="p">(</span><span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">grover</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">qubits</span><span class="o">=</span><span class="p">[</span><span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">])</span>

<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">qpu</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
<span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">probability</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="mf">0.24999999999999956</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="mf">0.24999999999999956</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="mf">0.24999999999999956</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="mf">0.24999999999999956</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>oracle</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – a quantum gate or routine implementing the oracle</p></li>
<li><p><strong>state_prep</strong> (optional, <a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – a quantum gate or routine</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a routine</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.algorithms.phase_estimation">
<span class="sig-prename descclassname"><span class="pre">qat.lang.algorithms.</span></span><span class="sig-name descname"><span class="pre">phase_estimation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.algorithms.phase_estimation" title="Permalink to this definition"></a></dt>
<dd><p>Generates a routine that performs phase estimation of some unitary operator.</p>
<p>The number of qubits of the resulting routine is <span class="math notranslate nohighlight">\(n+k\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the
arity of <cite>operator</cite> and <span class="math notranslate nohighlight">\(k\)</span> is <cite>nbits</cite>.
The routine assumes that the first <span class="math notranslate nohighlight">\(n\)</span> qubits are already prepared and contain the
states on which the phase estimation should be performed.
The result will be stored in the last <span class="math notranslate nohighlight">\(k\)</span> qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – a quantum gate or routine</p></li>
<li><p><strong>nbits</strong> (<em>int</em>) – the number of bits to store the result in</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a routine</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.algorithms.quantum_counting">
<span class="sig-prename descclassname"><span class="pre">qat.lang.algorithms.</span></span><span class="sig-name descname"><span class="pre">quantum_counting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oracle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prepare</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.algorithms.quantum_counting" title="Permalink to this definition"></a></dt>
<dd><p>Performs a quantum counting on some oracle.</p>
<p>The number of qubits of the resulting routine is <span class="math notranslate nohighlight">\(n+k\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the
arity of <cite>oracle</cite> and <span class="math notranslate nohighlight">\(k\)</span> is <cite>nbits</cite>.
The routine assumes that the first <span class="math notranslate nohighlight">\(n\)</span> qubits are already prepared and contain the
states on which the counting should be performed.
The result will be stored in the last <span class="math notranslate nohighlight">\(k\)</span> qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>oracle</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – a quantum gate or routine implementing the oracle</p></li>
<li><p><strong>nbits</strong> (<em>int</em>) – the number of bits to store the result in</p></li>
<li><p><strong>prepare</strong> (<em>optional</em><em>, </em><em>bool</em>) – if set to False, omits the preparation of the data register. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a routine</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a></p>
</dd>
</dl>
</dd></dl>

<p>Additionally, the submodule <cite>qat.lang.algorithms.amplification</cite> contains some functions that might be useful:</p>
<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.algorithms.amplification.uniform_distribution">
<span class="sig-prename descclassname"><span class="pre">qat.lang.algorithms.amplification.</span></span><span class="sig-name descname"><span class="pre">uniform_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.algorithms.amplification.uniform_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Prepares a uniform distribution from state <span class="math notranslate nohighlight">\(|0\rangle\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nbits</strong> (<em>int</em>) – the number of qbits</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a routine</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.algorithms.amplification.householder">
<span class="sig-prename descclassname"><span class="pre">qat.lang.algorithms.amplification.</span></span><span class="sig-name descname"><span class="pre">householder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_prep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.algorithms.amplification.householder" title="Permalink to this definition"></a></dt>
<dd><p>Given some state preparation circuit implementing a unitary operator <span class="math notranslate nohighlight">\(U\)</span>, builds a Householder transform
of the form:</p>
<div class="math notranslate nohighlight">
\[2\left(U|0\rangle\langle 0|U^\dagger\right) - I\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>state_prep</strong> (<a class="reference internal" href="#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>) – a quantum gate or routine</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a routine</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.lang.algorithms.amplification.grover_diffusion">
<span class="sig-prename descclassname"><span class="pre">qat.lang.algorithms.amplification.</span></span><span class="sig-name descname"><span class="pre">grover_diffusion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.lang.algorithms.amplification.grover_diffusion" title="Permalink to this definition"></a></dt>
<dd><p>An implementation of Grover’s diffusion.</p>
<p>The returned routine implements the following Householder transform:</p>
<div class="math notranslate nohighlight">
\[2|s\rangle\langle s| - I\]</div>
<p>where <span class="math notranslate nohighlight">\(|s\rangle\)</span> is the uniform distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nbits</strong> (<em>int</em>) – the arity of the diffusion</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a routine</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="qat-core.html" class="btn btn-neutral float-left" title="qat-core: Core data structures and Abstract classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="qat-lang-arith.html" class="btn btn-neutral float-right" title="Arithmetic routines" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Eviden 2016-2023.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>