<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Digital quantum simulation for spin and fermionic systems &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="static/contentui.css" type="text/css" />
      <link rel="stylesheet" href="static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
    <link rel="shortcut icon" href="static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="static/doctools.js"></script>
        <script src="static/sphinx_highlight.js"></script>
        <script src="static/contentui.js"></script>
        <script src="static/design-tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="qat-opt: representation and encoding of combinatorial problems, QAOA" href="qat-opt.html" />
    <link rel="prev" title="qat.simulated_annealing: Simulated Annealing" href="myqlm_specific/qat-simulated_annealing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> myQLM documentation
            <img src="static/myqlm.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                myQLM-1.7.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorial_optimization_intro.html">Combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">List of notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Main objects: Jobs, Observables, Circuits…</a></li>
<li class="toctree-l1"><a class="reference internal" href="manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch_generators.html">Building advanced computation stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="qat-fermion.html">Digital quantum simulation for spin and fermionic systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Command-line tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source code documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="source_doc.html">Source code documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#quantum-application-toolchain-qat-python-libraries">Quantum Application ToolChain (QAT) Python libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#the-core-library">The core library</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#the-programming-library">The programming library</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#the-device-library">The device library</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#generators">Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#plugins">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#qpus">QPUs</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#interoperability-with-other-frameworks">Interoperability with other frameworks</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="source_doc.html#digital-quantum-simulation-tools">Digital quantum simulation tools</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Digital quantum simulation for spin and fermionic systems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-hamiltonians-classes">The Hamiltonians classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-and-molecular-studies-study">Atomic and molecular studies study</a></li>
<li class="toctree-l4"><a class="reference internal" href="#common-many-body-hamiltonians">Common many-body Hamiltonians</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-spin-fermion-transforms">The spin-fermion transforms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fermionic-ansatz-circuits">Fermionic ansatz circuits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quantum-phase-estimation">Quantum phase estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quantum-subspace-expansion">Quantum subspace expansion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unitary-coupled-cluster-ucc">Unitary Coupled-Cluster (UCC)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#utility-functions">Utility functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plugins">Plugins</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="source_doc.html#combinatorial-optimization-and-qaoa">Combinatorial optimization and QAOA</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/contrib.html">Contributing to myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/release-note.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="source_doc.html">Source code documentation</a> &raquo;</li>
      <li>Digital quantum simulation for spin and fermionic systems</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="digital-quantum-simulation-for-spin-and-fermionic-systems">
<span id="qat-fermion-source"></span><h1>Digital quantum simulation for spin and fermionic systems<a class="headerlink" href="#digital-quantum-simulation-for-spin-and-fermionic-systems" title="Permalink to this heading"></a></h1>
<p>The <a class="reference internal" href="qat-fermion.html#module-qat.fermion" title="qat.fermion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion</span></code></a> module contains tools for the study of spin and fermionic systems. Please see the <a class="reference internal" href="qat-fermion.html#qat-fermion"><span class="std std-ref">main page</span></a>
for more information on how to use the module.</p>
<div class="contents local topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#the-hamiltonians-classes" id="id4">The Hamiltonians classes</a></p>
<ul>
<li><p><a class="reference internal" href="#spinhamiltonian" id="id5">SpinHamiltonian</a></p></li>
<li><p><a class="reference internal" href="#fermionhamiltonian" id="id6">FermionHamiltonian</a></p></li>
<li><p><a class="reference internal" href="#electronicstructurehamiltonian" id="id7">ElectronicStructureHamiltonian</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#atomic-and-molecular-studies-study" id="id8">Atomic and molecular studies study</a></p>
<ul>
<li><p><a class="reference internal" href="#molecularhamiltonian" id="id9">MolecularHamiltonian</a></p></li>
<li><p><a class="reference internal" href="#moleculeinfo" id="id10">MoleculeInfo</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#common-many-body-hamiltonians" id="id11">Common many-body Hamiltonians</a></p>
<ul>
<li><p><a class="reference internal" href="#the-hubbard-model" id="id12">The Hubbard model</a></p></li>
<li><p><a class="reference internal" href="#the-single-impurity-anderson-model" id="id13">The single-impurity Anderson Model</a></p></li>
<li><p><a class="reference internal" href="#the-generalized-impurity-hamiltonian" id="id14">The generalized impurity Hamiltonian</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-spin-fermion-transforms" id="id15">The spin-fermion transforms</a></p>
<ul>
<li><p><a class="reference internal" href="#jordan-wigner-transform" id="id16">Jordan-Wigner transform</a></p></li>
<li><p><a class="reference internal" href="#bravyi-kitaev-transform" id="id17">Bravyi-Kitaev transform</a></p></li>
<li><p><a class="reference internal" href="#parity-basis-transform" id="id18">Parity basis transform</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fermionic-ansatz-circuits" id="id19">Fermionic ansatz circuits</a></p>
<ul>
<li><p><a class="reference internal" href="#low-depth-circuit-ansatz-ldca" id="id20">Low-Depth Circuit Ansatz (LDCA)</a></p></li>
<li><p><a class="reference internal" href="#multi-reference-mr-ansatz" id="id21">Multi-Reference (MR) ansatz</a></p></li>
<li><p><a class="reference internal" href="#multi-reference-excitation-preserving-mrep-ansatz" id="id22">Multi-Reference, Excitation-Preserving (MREP) ansatz</a></p></li>
<li><p><a class="reference internal" href="#general-hardware-efficient-ansatz" id="id23">General hardware-efficient ansatz</a></p></li>
<li><p><a class="reference internal" href="#the-8-parameter-circuit-ansatz" id="id24">The 8-parameter circuit ansatz</a></p></li>
<li><p><a class="reference internal" href="#compressed-ldca-ansatz-only-for-qlm-users" id="id25">Compressed LDCA ansatz (only for QLM users)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#quantum-phase-estimation" id="id26">Quantum phase estimation</a></p></li>
<li><p><a class="reference internal" href="#quantum-subspace-expansion" id="id27">Quantum subspace expansion</a></p></li>
<li><p><a class="reference internal" href="#unitary-coupled-cluster-ucc" id="id28">Unitary Coupled-Cluster (UCC)</a></p></li>
<li><p><a class="reference internal" href="#utility-functions" id="id29">Utility functions</a></p></li>
<li><p><a class="reference internal" href="#plugins" id="id30">Plugins</a></p></li>
</ul>
</div>
<section id="the-hamiltonians-classes">
<h2>The Hamiltonians classes<a class="headerlink" href="#the-hamiltonians-classes" title="Permalink to this heading"></a></h2>
<p><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHamiltonian</span></code></a>, <a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionHamiltonian</span></code></a> and
<a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a> are essentially <a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a> classes with
additional functionalities. Let us detail the additional features they contain.</p>
<section id="spinhamiltonian">
<span id="qat-fermion-source-spin-hamiltonian"></span><h3>SpinHamiltonian<a class="headerlink" href="#spinhamiltonian" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.SpinHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.fermion.hamiltonians.</span></span><span class="sig-name descname"><span class="pre">SpinHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nqbits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">terms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="qat-core.html#qat.core.Term" title="qat.core.wrappers.observable.Term"><span class="pre">Term</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_coeff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_clean_up</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of a spin Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nqbits</strong> (<em>int</em>) – the total number of qubits</p></li>
<li><p><strong>terms</strong> (<em>List</em><em>[</em><a class="reference internal" href="qat-core.html#qat.core.Term" title="qat.core.Term"><em>Term</em></a><em>]</em>) – the list of terms</p></li>
<li><p><strong>constant_coeff</strong> (<em>float</em>) – constant term</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.SpinHamiltonian.nbqbits">
<span class="sig-name descname"><span class="pre">nbqbits</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.SpinHamiltonian.nbqbits" title="Permalink to this definition"></a></dt>
<dd><p>the total number of qubits</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.SpinHamiltonian.terms">
<span class="sig-name descname"><span class="pre">terms</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.SpinHamiltonian.terms" title="Permalink to this definition"></a></dt>
<dd><p>the list of terms</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="qat-core.html#qat.core.Term" title="qat.core.Term">Term</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.SpinHamiltonian.constant_coeff">
<span class="sig-name descname"><span class="pre">constant_coeff</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.SpinHamiltonian.constant_coeff" title="Permalink to this definition"></a></dt>
<dd><p>constant term</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.SpinHamiltonian.matrix">
<span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.SpinHamiltonian.matrix" title="Permalink to this definition"></a></dt>
<dd><p>the corresponding matrix (None by default, can be set by calling get_matrix method)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.fermion</span> <span class="kn">import</span> <span class="n">SpinHamiltonian</span>

<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">SpinHamiltonian</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">Term</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="s2">&quot;ZY&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H = </span><span class="si">{</span><span class="n">hamiltonian</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H matrix: </span><span class="si">{</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">ZY</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">H</span> <span class="n">matrix</span><span class="p">:</span> <span class="p">[[</span><span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.4</span><span class="n">j</span> <span class="mf">0.3</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span> <span class="o">-</span><span class="mf">0.4</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.3</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">]</span>
 <span class="p">[</span><span class="mf">0.3</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span> <span class="o">-</span><span class="mf">0.4</span><span class="n">j</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.3</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.4</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.SpinHamiltonian.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.SpinHamiltonian.copy" title="Permalink to this definition"></a></dt>
<dd><p>Deepcopy the current class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Copy of the SpinHamiltonian.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHamiltonian</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.SpinHamiltonian.dag">
<span class="sig-name descname"><span class="pre">dag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><span class="pre">SpinHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.SpinHamiltonian.dag" title="Permalink to this definition"></a></dt>
<dd><p>Compute the conjugate transpose of the Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Conjugate transpose of the SpinHamiltonian operator</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian">SpinHamiltonian</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.SpinHamiltonian.get_matrix">
<span class="sig-name descname"><span class="pre">get_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.SpinHamiltonian.get_matrix" title="Permalink to this definition"></a></dt>
<dd><p>This function returns the matrix corresponding to <span class="math notranslate nohighlight">\(H\)</span> in the computational basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – Whether to return in sparse representation.</p></li>
<li><p><strong>False.</strong> (<em>Defaults to</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The matrix of the SpinHamiltonian.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method should not be used if the SpinHamiltonian is too large.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="fermionhamiltonian">
<span id="qat-fermion-source-fermion-hamiltonian"></span><h3>FermionHamiltonian<a class="headerlink" href="#fermionhamiltonian" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.fermion.hamiltonians.</span></span><span class="sig-name descname"><span class="pre">FermionHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nqbits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">terms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="qat-core.html#qat.core.Term" title="qat.core.wrappers.observable.Term"><span class="pre">Term</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_coeff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_clean_up</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of a fermionic Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nqbits</strong> (<em>int</em>) – The total number of qubits</p></li>
<li><p><strong>terms</strong> (<em>List</em><em>[</em><a class="reference internal" href="qat-core.html#qat.core.Term" title="qat.core.Term"><em>Term</em></a><em>]</em>) – The list of terms</p></li>
<li><p><strong>constant_coeff</strong> (<em>float</em>) – Constant term</p></li>
<li><p><strong>do_clean_up</strong> (<em>bool</em><em>, </em><em>optional</em>) – If the terms should be simplified. Default to True.</p></li>
<li><p><strong>normal_order</strong> (<em>bool</em><em>, </em><em>optional</em>) – If the fermionic terms should be normal (or Wick) ordered. Default to True. True is
recommended always.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.nbqbits">
<span class="sig-name descname"><span class="pre">nbqbits</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.nbqbits" title="Permalink to this definition"></a></dt>
<dd><p>The total number of qubits</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.terms">
<span class="sig-name descname"><span class="pre">terms</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.terms" title="Permalink to this definition"></a></dt>
<dd><p>The list of terms</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="qat-core.html#qat.core.Term" title="qat.core.Term">Term</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.constant_coeff">
<span class="sig-name descname"><span class="pre">constant_coeff</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.constant_coeff" title="Permalink to this definition"></a></dt>
<dd><p>Constant term.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.matrix">
<span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.matrix" title="Permalink to this definition"></a></dt>
<dd><p>The corresponding matrix (None by default, can be set by calling get_matrix method).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.normal_order">
<span class="sig-name descname"><span class="pre">normal_order</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.normal_order" title="Permalink to this definition"></a></dt>
<dd><p>If the fermionic terms should be normal (or Wick) ordered.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fermionic Hamiltonians are by default automatically normally ordered.</p>
</div>
<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.fermion</span> <span class="kn">import</span> <span class="n">FermionHamiltonian</span>

<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">FermionHamiltonian</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s2">&quot;Cc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">Term</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span> <span class="s2">&quot;CcCc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H = </span><span class="si">{</span><span class="n">hamiltonian</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H matrix: </span><span class="si">{</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">CCcc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">H</span> <span class="n">matrix</span><span class="p">:</span> <span class="p">[[</span><span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.3</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">1.4</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="mf">0.</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.copy" title="Permalink to this definition"></a></dt>
<dd><p>Deepcopy the current class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Copy of the FermionHamiltonian.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionHamiltonian</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.dag">
<span class="sig-name descname"><span class="pre">dag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><span class="pre">FermionHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.dag" title="Permalink to this definition"></a></dt>
<dd><p>Compute the conjugate transpose of the Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Conjugate transpose of the Hamiltonian.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian">FermionHamiltonian</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.get_matrix">
<span class="sig-name descname"><span class="pre">get_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.get_matrix" title="Permalink to this definition"></a></dt>
<dd><p>This function returns the matrix corresponding to <span class="math notranslate nohighlight">\(H\)</span> in the computational basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – Whether to return in sparse representation.</p></li>
<li><p><strong>False.</strong> (<em>Defaults to</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The matrix of the FermionHamiltonian.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method should not be used if the Hamiltonian is too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.to_electronic">
<span class="sig-name descname"><span class="pre">to_electronic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.to_electronic" title="Permalink to this definition"></a></dt>
<dd><p>Converts a fermionic Hamiltonian to a electronic-structure Hamiltonian. This can be done only if the Hamiltonian
contains only single and double interaction operators (i.e. only “Cc” and “CCcc” fermionic operators).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Electronic-structure Hamiltonian.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.FermionHamiltonian.to_spin">
<span class="sig-name descname"><span class="pre">to_spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'jordan-wigner'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.FermionHamiltonian.to_spin" title="Permalink to this definition"></a></dt>
<dd><p>Maps the fermionic Hamiltonian to a spin Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Method to use for the transformation to a spin representation. Available methods are :</p>
<ul class="simple">
<li><p>”jordan-wigner” : Jordan-Wigner transform (default),</p></li>
<li><p>”bravyi-kitaev” : Bravyi-Kitaev transform,</p></li>
<li><p>”parity” : Parity transform.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Hamiltonian in spin representation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHamiltonian</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="electronicstructurehamiltonian">
<span id="qat-fermion-source-electronicstructurehamiltonian"></span><h3>ElectronicStructureHamiltonian<a class="headerlink" href="#electronicstructurehamiltonian" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.fermion.hamiltonians.</span></span><span class="sig-name descname"><span class="pre">ElectronicStructureHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hpq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hpqrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_coeff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_clean_up</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>A container for the electronic-structure Hamiltonian, defined as</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq} h_{pq}a_p^\dagger a_q
    + \frac{1}{2} \sum_{pqrs} h_{pqrs}a_p^\dagger a_q^\dagger a_r a_s
    + c \mathbb{I}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hpq</strong> (<em>np.ndarray</em>) – Array <span class="math notranslate nohighlight">\(h_{pq}\)</span>. Must be 2D.</p></li>
<li><p><strong>hpqrs</strong> (<em>np.ndarray</em>) – Array <span class="math notranslate nohighlight">\(h_{pqrs}\)</span>. Must be 4D.</p></li>
<li><p><strong>constant_coeff</strong> (<em>float</em>) – Constant coefficient <span class="math notranslate nohighlight">\(c.\)</span></p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian.hpq">
<span class="sig-name descname"><span class="pre">hpq</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian.hpq" title="Permalink to this definition"></a></dt>
<dd><p>Array <span class="math notranslate nohighlight">\(h_{pq}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian.hpqrs">
<span class="sig-name descname"><span class="pre">hpqrs</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian.hpqrs" title="Permalink to this definition"></a></dt>
<dd><p>Array <span class="math notranslate nohighlight">\(h_{pqrs}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian.constant_coeff">
<span class="sig-name descname"><span class="pre">constant_coeff</span></span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian.constant_coeff" title="Permalink to this definition"></a></dt>
<dd><p>Constant coefficient <span class="math notranslate nohighlight">\(c\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.fermion</span> <span class="kn">import</span> <span class="n">ElectronicStructureHamiltonian</span>

<span class="n">h_pq</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">h_pqrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">h_pqrs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="n">h_pqrs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">ElectronicStructureHamiltonian</span><span class="p">(</span><span class="n">h_pq</span><span class="p">,</span> <span class="n">h_pqrs</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H = </span><span class="si">{</span><span class="n">hamiltonian</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">eigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;eigenvalues = </span><span class="si">{</span><span class="n">eigvals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6</span> <span class="o">*</span> <span class="n">I</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span>
<span class="mf">0.2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">0.2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.7</span> <span class="o">*</span> <span class="p">(</span><span class="n">CCcc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">6.2</span> <span class="o">-</span><span class="mf">6.</span>  <span class="o">-</span><span class="mf">5.8</span> <span class="o">-</span><span class="mf">5.3</span><span class="p">]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian.copy" title="Permalink to this definition"></a></dt>
<dd><p>Deepcopy the current class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Copy of the ElectronicStructureHamiltonian.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian.dag">
<span class="sig-name descname"><span class="pre">dag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian.dag" title="Permalink to this definition"></a></dt>
<dd><p>Compute the conjugate transpose of the Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Conjugate transpose of the Hamiltonian.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian">ElectronicStructureHamiltonian</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian.get_matrix">
<span class="sig-name descname"><span class="pre">get_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian.get_matrix" title="Permalink to this definition"></a></dt>
<dd><p>This function returns the matrix corresponding to <span class="math notranslate nohighlight">\(H\)</span> in the computational basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sparse</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – Whether to return in sparse representation.</p></li>
<li><p><strong>False.</strong> (<em>Defaults to</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The matrix of the FermionHamiltonian.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method should not be used if the Hamiltonian is too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian.to_fermion">
<span class="sig-name descname"><span class="pre">to_fermion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><span class="pre">FermionHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian.to_fermion" title="Permalink to this definition"></a></dt>
<dd><p>Convert current ElectronicStructureHamiltonian to a FermionHamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Fermionic Hamiltonian.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian">FermionHamiltonian</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.ElectronicStructureHamiltonian.to_spin">
<span class="sig-name descname"><span class="pre">to_spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'jordan-wigner'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian.to_spin" title="Permalink to this definition"></a></dt>
<dd><p>Maps the fermionic Hamiltonian to a spin Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Method to use for the transformation to a spin representation. Available methods are :</p>
<ul class="simple">
<li><p>”jordan-wigner” : Jordan-Wigner transform (default),</p></li>
<li><p>”bravyi-kitaev” : Bravyi-Kitaev transform,</p></li>
<li><p>”parity” : Parity transform.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Hamiltonian in spin representation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHamiltonian</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="atomic-and-molecular-studies-study">
<span id="qat-fermion-source-chemistry-wrappers"></span><h2>Atomic and molecular studies study<a class="headerlink" href="#atomic-and-molecular-studies-study" title="Permalink to this heading"></a></h2>
<section id="molecularhamiltonian">
<h3>MolecularHamiltonian<a class="headerlink" href="#molecularhamiltonian" title="Permalink to this heading"></a></h3>
<span class="target" id="qat-fermion-source-molecular-hamiltonian"></span><dl class="py class">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MolecularHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.wrapper.</span></span><span class="sig-name descname"><span class="pre">MolecularHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_coeff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>MolecularHamiltonian helper class. It represents the electronic-structure Hamiltonian defined
using one- and two-body integrals.</p>
<p>This electronic-structure Hamiltonian is defined by:</p>
<div class="math notranslate nohighlight">
\[H=\sum_{uv\sigma}I_{uv}c^{\dagger}_{u\sigma}c_{v\sigma}+\frac{1}{2}\sum_{uvwx}\sum_{\sigma \sigma'} I_{uvwx}c^{\dagger}_{u\sigma}c^{\dagger}_{v\sigma'}c_{w\sigma'}c_{x\sigma}+r\mathbb{I}\]</div>
<p>with <span class="math notranslate nohighlight">\(r\)</span> the core repulsion constant, and with <span class="math notranslate nohighlight">\(I_{uv}\)</span> and <span class="math notranslate nohighlight">\(I_{uvwx}\)</span> the one- and two-body integrals defined
by:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}I_{uv} = \int dr \phi^{*}_{u}(r)h_{1}[\phi_{v}(r)]\\I_{uvwx} = \int dr dr' \phi^{*}_{u}(r)\phi^{*}_{v}(r')v[\phi_{w}(r)\phi_{x}(r')]\end{aligned}\end{align} \]</div>
<p>Here, <span class="math notranslate nohighlight">\(\{\phi_{i}(r)\}_{i=0...N-1}\)</span> is the single-particle basis, with <span class="math notranslate nohighlight">\(N\)</span> the size, which depends on the basis
chosen. <span class="math notranslate nohighlight">\(h_{1} = h_{kin} + h_{pot}\)</span> is the one-body Hamiltonian, and <span class="math notranslate nohighlight">\(v\)</span> the Coulomb operator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This electronic-structure Hamiltonian definition is different than the one used in
<a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_body_integrals</strong> (<em>np.ndarray</em>) – One-body integral <span class="math notranslate nohighlight">\(I_{uv}\)</span>.</p></li>
<li><p><strong>two_body_integrals</strong> (<em>np.ndarray</em>) – Two-body integral <span class="math notranslate nohighlight">\(I_{uvwx}\)</span>.</p></li>
<li><p><strong>constant_coeff</strong> (<em>np.ndarray</em>) – Constant coefficient <span class="math notranslate nohighlight">\(r\)</span> (core repulsion).</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MolecularHamiltonian.nqbits">
<span class="sig-name descname"><span class="pre">nqbits</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.nqbits" title="Permalink to this definition"></a></dt>
<dd><p>The total number of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MolecularHamiltonian.one_body_integrals">
<span class="sig-name descname"><span class="pre">one_body_integrals</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.one_body_integrals" title="Permalink to this definition"></a></dt>
<dd><p>One-body integral <span class="math notranslate nohighlight">\(I_{uv}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MolecularHamiltonian.two_body_integrals">
<span class="sig-name descname"><span class="pre">two_body_integrals</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.two_body_integrals" title="Permalink to this definition"></a></dt>
<dd><p>Two-body integral <span class="math notranslate nohighlight">\(I_{uvwx}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MolecularHamiltonian.constant_coeff">
<span class="sig-name descname"><span class="pre">constant_coeff</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.constant_coeff" title="Permalink to this definition"></a></dt>
<dd><p>Constant coefficient <span class="math notranslate nohighlight">\(r\)</span> (core repulsion).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.fermion.chemistry</span> <span class="kn">import</span> <span class="n">MolecularHamiltonian</span>

<span class="c1"># Initialize random one- and two-body integrals, and a constant</span>
<span class="n">one_body_integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">two_body_integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">constant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>

<span class="c1"># Define the MolecularHamiltonian</span>
<span class="n">mol_h</span> <span class="o">=</span> <span class="n">MolecularHamiltonian</span><span class="p">(</span><span class="n">one_body_integral</span><span class="p">,</span> <span class="n">two_body_integral</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">mol_h</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">MolecularHamiltonian</span><span class="p">(</span>
 <span class="o">-</span> <span class="n">constant_coeff</span> <span class="p">:</span> <span class="mf">0.6150079976794369</span>
 <span class="o">-</span> <span class="n">integrals</span> <span class="n">shape</span>
    <span class="o">*</span> <span class="n">one_body_integrals</span> <span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">*</span> <span class="n">two_body_integrals</span> <span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MolecularHamiltonian.get_electronic_hamiltonian">
<span class="sig-name descname"><span class="pre">get_electronic_hamiltonian</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.get_electronic_hamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the MolecularHamiltonian to an ElectronicStructureHamiltonian. To do so, it converts from <span class="math notranslate nohighlight">\(I_{uv},I_{uvwx}\)</span>
to <span class="math notranslate nohighlight">\(h_{pq},h_{pqrs}\)</span>, with</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}h_{u\sigma, v\sigma'} = I_{u, v} \delta_{\sigma, \sigma'}\\h_{u\sigma_1, v\sigma_2, w\sigma_2', x\sigma_1'} =  I_{uvwx} \left((1-\delta_{\sigma,\sigma'}) + \delta_{\sigma,\sigma'} (1-\delta_{u,v})(1-\delta_{w,x})   \right)\end{aligned}\end{align} \]</div>
<p>and where the one- and two-body integrals are defined as:</p>
<div class="math notranslate nohighlight">
\[I_{uv}\equiv(u|h|v)=\int\mathrm{d}r\phi_{u}^{*}(r)T\phi_{v}(r)\]</div>
<div class="math notranslate nohighlight">
\[I_{uvwx}\equiv(ux|vw)=\iint\mathrm{d}r_{1}\mathrm{d}r_{2}\phi_{u}^{*}(r_{1})\phi_{x}(r_{1})v(r_{12})\phi_{v}^{*}(r_{2})\phi_{w}(r_{2})\]</div>
<p>with <span class="math notranslate nohighlight">\(T\)</span> (resp. <span class="math notranslate nohighlight">\(v\)</span>) the one- (resp. two-) body potentials,
and <span class="math notranslate nohighlight">\(\phi_u(r)\)</span> is the molecular orbital wavefunction.</p>
<p>The <span class="math notranslate nohighlight">\(h\)</span> integrals are used to construct hamiltonians of the ElectronicStructureHamiltonian type.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a> Electronic structure hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MolecularHamiltonian.select_active_space">
<span class="sig-name descname"><span class="pre">select_active_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><span class="pre">MolecularHamiltonian</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.select_active_space" title="Permalink to this definition"></a></dt>
<dd><p>Selects the right active space and freezes core electrons
according to their NOONs <span class="math notranslate nohighlight">\(n_i\)</span>.</p>
<p>This function is an implementation of the <em>Complete Active Space</em>
(CAS) approach. It divides orbital space into sets of <em>active</em> and
<em>inactive</em> orbitals, the occupation number of the latter remaining
unchanged during the computation.</p>
<p>The active space indices are defined as:</p>
<div class="math notranslate nohighlight">
\[\mathcal{A} = \{i, n_i \in [\varepsilon_2, 2 - \varepsilon_1[\} \cup \{i, n_i \geq 2-\varepsilon_1, 2(i+1)\geq N_e \}\]</div>
<p>The inactive occupied orbitals are defined as:</p>
<div class="math notranslate nohighlight">
\[\mathcal{O} = \{i, n_i \geq 2 -\varepsilon_1, 2(i+1) &lt; N_e \}\]</div>
<p>The restriction of the one- and two-body integrals (and update of the core energy)
is then carried out according to:</p>
<div class="math notranslate nohighlight">
\[\forall u,v \in \mathcal{A},\; I^{(a)}_{uv} = I_{uv} + \sum_{i\in \mathcal{O}} 2 I_{i,u,v,i} - I_{i,u,i,v}\]</div>
<div class="math notranslate nohighlight">
\[\forall u,v,w,x \in \mathcal{A}, I^{(a)}_{uvwx} = I_{uvwx}\]</div>
<div class="math notranslate nohighlight">
\[E_\mathrm{core}^{(a)} = E_\mathrm{core} + \sum_{i\in\mathcal{O}} I_{ii} + \sum_{ij\in\mathcal{O}} 2 I_{ijji} - I_{ijij}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noons</strong> (<em>List</em><em>[</em><em>float</em><em>]</em>) – the natural-orbital occupation numbers <span class="math notranslate nohighlight">\(n_i\)</span>, sorted
in descending order (from high occupations to low occupations)</p></li>
<li><p><strong>n_electrons</strong> (<em>int</em>) – The number of electrons <span class="math notranslate nohighlight">\(N_e\)</span>.</p></li>
<li><p><strong>threshold_1</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – The upper threshold <span class="math notranslate nohighlight">\(\varepsilon_1\)</span> on
the NOON of an active orbital.</p></li>
<li><p><strong>threshold_2</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – The lower threshold <span class="math notranslate nohighlight">\(\varepsilon_2\)</span> on
the NOON of an active orbital.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>the molecular Hamiltonian in active space <span class="math notranslate nohighlight">\(H^{(a)}\)</span></p></li>
<li><p>the list of indices corresponding to the active orbitals, <span class="math notranslate nohighlight">\(\mathcal{A}\)</span></p></li>
<li><p>the list of indices corresponding to the occupied orbitals, <span class="math notranslate nohighlight">\(\mathcal{O}\)</span></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian">MolecularHamiltonian</a>, List[int], List[int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MolecularHamiltonian.transform_basis">
<span class="sig-name descname"><span class="pre">transform_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transformation_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><span class="pre">MolecularHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.transform_basis" title="Permalink to this definition"></a></dt>
<dd><p>Change one and two body integrals (indices p, q…) to new basis (indices i, j…)
using transformation U such that</p>
<div class="math notranslate nohighlight">
\[\hat{c}_{i}=\sum_{q}U_{qi}c_{q}\]</div>
<p>i.e</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\hat{I}_{ij} =\sum_{pq}U_{pi}I_{pq}U_{jq}^{\dagger}\\\hat{I}_{ijkl}=\sum_{pqrs}U_{pi}U_{qj}I_{pqrs}U_{kr}^{\dagger}U_{ls}^{\dagger}\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transformation_matrix</strong> (<em>np.array</em>) – transformation matrix <span class="math notranslate nohighlight">\(U\)</span></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>MolecularHamiltonian updated to the new basis.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>molecular_hamiltonian (<a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian">MolecularHamiltonian</a>)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="moleculeinfo">
<h3>MoleculeInfo<a class="headerlink" href="#moleculeinfo" title="Permalink to this heading"></a></h3>
<span class="target" id="qat-fermion-source-molecule-info"></span><dl class="py class">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.wrapper.</span></span><span class="sig-name descname"><span class="pre">MoleculeInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><span class="pre">MolecularHamiltonian</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_energies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo" title="Permalink to this definition"></a></dt>
<dd><p>MoleculeInfo helper class. This class is a even higher level version of the
<a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><em>MolecularHamiltonian</em></a>) – The MolecularHamiltonian of the studied molecule.</p></li>
<li><p><strong>n_electrons</strong> (<em>int</em>) – Number of electrons.</p></li>
<li><p><strong>noons</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>List</em><em>[</em><em>float</em><em>]</em><em>]</em>) – Natural orbital occupation number.</p></li>
<li><p><strong>orbital_energies</strong> (<em>np.ndarray</em>) – Orbital energies.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.nqbits">
<span class="sig-name descname"><span class="pre">nqbits</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.nqbits" title="Permalink to this definition"></a></dt>
<dd><p>The total number of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.one_body_integrals">
<span class="sig-name descname"><span class="pre">one_body_integrals</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.one_body_integrals" title="Permalink to this definition"></a></dt>
<dd><p>One-body integrals <span class="math notranslate nohighlight">\(I_{uv}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.two_body_integrals">
<span class="sig-name descname"><span class="pre">two_body_integrals</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.two_body_integrals" title="Permalink to this definition"></a></dt>
<dd><p>Two-body integrals <span class="math notranslate nohighlight">\(I_{uvwx}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.constant_coeff">
<span class="sig-name descname"><span class="pre">constant_coeff</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.constant_coeff" title="Permalink to this definition"></a></dt>
<dd><p>Constant coefficient <span class="math notranslate nohighlight">\(r\)</span> (core repulsion).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.hamiltonian">
<span class="sig-name descname"><span class="pre">hamiltonian</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.hamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a> of the studied molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian">MolecularHamiltonian</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.n_electrons">
<span class="sig-name descname"><span class="pre">n_electrons</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.n_electrons" title="Permalink to this definition"></a></dt>
<dd><p>Number of electrons.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.noons">
<span class="sig-name descname"><span class="pre">noons</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.noons" title="Permalink to this definition"></a></dt>
<dd><p>Natural orbital occupation number.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Union[np.ndarray, List[float]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.orbital_energies">
<span class="sig-name descname"><span class="pre">orbital_energies</span></span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.orbital_energies" title="Permalink to this definition"></a></dt>
<dd><p>Orbital energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.fermion.chemistry</span> <span class="kn">import</span> <span class="n">MolecularHamiltonian</span><span class="p">,</span> <span class="n">MoleculeInfo</span>

<span class="c1"># For illustration purpose, initialize random one- and two-body integrals, and a constant</span>
<span class="n">one_body_integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">two_body_integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">constant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
<span class="n">noons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">orbital_energies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="c1"># Define the MolecularHamiltonian</span>
<span class="n">mol_h</span> <span class="o">=</span> <span class="n">MolecularHamiltonian</span><span class="p">(</span><span class="n">one_body_integral</span><span class="p">,</span> <span class="n">two_body_integral</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>

<span class="c1"># Define MoleculeInfo</span>
<span class="n">molecule</span> <span class="o">=</span> <span class="n">MoleculeInfo</span><span class="p">(</span>
    <span class="n">mol_h</span><span class="p">,</span>
    <span class="n">n_electrons</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">noons</span><span class="o">=</span><span class="n">noons</span><span class="p">,</span>
    <span class="n">orbital_energies</span><span class="o">=</span><span class="n">orbital_energies</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MoleculeInfo</span><span class="p">(</span>
 <span class="o">-</span> <span class="n">MolecularHamiltonian</span><span class="p">(</span>
    <span class="o">*</span> <span class="n">constant_coeff</span> <span class="p">:</span> <span class="mf">0.5937162557057649</span>
    <span class="o">*</span> <span class="n">integrals</span> <span class="n">shape</span>
       <span class="o">**</span> <span class="n">one_body_integrals</span> <span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
       <span class="o">**</span> <span class="n">two_body_integrals</span> <span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
   <span class="p">)</span>
 <span class="o">-</span> <span class="n">n_electrons</span> <span class="o">=</span> <span class="mi">4</span>
 <span class="o">-</span> <span class="n">noons</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.268462685291517</span><span class="p">,</span> <span class="mf">0.7092647706455341</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7165252570150489</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8642838915207163</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.019857432486985474</span><span class="p">,</span> <span class="mf">1.5224947501688937</span><span class="p">,</span> <span class="mf">2.1368699674314207</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4337004636488765</span><span class="p">,</span> <span class="mf">0.9958607428500119</span><span class="p">,</span> <span class="mf">2.3661680799646434</span><span class="p">]</span>
 <span class="o">-</span> <span class="n">orbital</span> <span class="n">energies</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.8359446055283108</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.44040699510272374</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6583956007973328</span><span class="p">,</span> <span class="mf">0.927864557168637</span><span class="p">,</span> <span class="mf">2.114332632652059</span><span class="p">,</span> <span class="mf">0.1790511833223426</span><span class="p">,</span> <span class="mf">0.6967404707747703</span><span class="p">,</span> <span class="mf">0.5895771852377665</span><span class="p">,</span> <span class="mf">1.1929478513866918</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.43230249980960245</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qat.fermion.chemistry.wrapper.MoleculeInfo.restrict_active_space">
<span class="sig-name descname"><span class="pre">restrict_active_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold_1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.chemistry.wrapper.MoleculeInfo.restrict_active_space" title="Permalink to this definition"></a></dt>
<dd><p>Same method as the <a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a> method
<a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.select_active_space" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.select_active_space"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_active_space()</span></code></a>, except it also modifies
all the molecule parameters accordingly (NOONs, orbital energies, and number of electrons).</p>
<p>For more information, see <a class="reference internal" href="#qat.fermion.chemistry.wrapper.MolecularHamiltonian.select_active_space" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.select_active_space"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_active_space()</span></code></a>
documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold_1</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – The upper threshold <span class="math notranslate nohighlight">\(\varepsilon_1\)</span> on
the NOON of an active orbital.</p></li>
<li><p><strong>threshold_2</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – The lower threshold <span class="math notranslate nohighlight">\(\varepsilon_2\)</span> on
the NOON of an active orbital.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="common-many-body-hamiltonians">
<span id="qat-fermion-source-hamiltonian-constructors"></span><h2>Common many-body Hamiltonians<a class="headerlink" href="#common-many-body-hamiltonians" title="Permalink to this heading"></a></h2>
<p>We present here Hamiltonian constructors for common many-body Hamiltonians.</p>
<section id="the-hubbard-model">
<span id="qat-fermion-source-hamiltonians-constructors-hubbard"></span><h3>The Hubbard model<a class="headerlink" href="#the-hubbard-model" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.make_hubbard_model">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.hamiltonians.</span></span><span class="sig-name descname"><span class="pre">make_hubbard_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_mat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.make_hubbard_model" title="Permalink to this definition"></a></dt>
<dd><p>Constructs Hubbard model</p>
<div class="math notranslate nohighlight">
\[H = \sum_{ij,\sigma} t_{ij} c^\dagger_i c_j + U \sum_i n_{i\uparrow} n_{i \downarrow} - \mu \sum_i n_i\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_mat</strong> (<em>np.ndarray</em>) – Hopping matrix (n_sites x n_sites).</p></li>
<li><p><strong>U</strong> (<em>float</em>) – Hubbard U.</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – Chemical potential.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Hubbard Hamiltonian.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian">ElectronicStructureHamiltonian</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Spin-orbital labeling convention: <span class="math notranslate nohighlight">\(i \equiv (k, \sigma) = 2 k + \sigma\)</span>
with <span class="math notranslate nohighlight">\(i\)</span>: site index and <span class="math notranslate nohighlight">\(\sigma\)</span>: spin index.</p>
</dd></dl>

</section>
<section id="the-single-impurity-anderson-model">
<span id="qat-fermion-source-hamiltonians-constructors-anderson"></span><h3>The single-impurity Anderson Model<a class="headerlink" href="#the-single-impurity-anderson-model" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.make_anderson_model">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.hamiltonians.</span></span><span class="sig-name descname"><span class="pre">make_anderson_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.make_anderson_model" title="Permalink to this definition"></a></dt>
<dd><p>Returns the canonical second quantized form</p>
<div class="math notranslate nohighlight">
\[H_{\mathrm{CSQ}} = \sum_{p,q} h_{pq} f_p^\dagger f_q + \frac{1}{2}\sum_{p,q,r,s} h_{pqrs} f_p^\dagger f_q^\dagger f_r f_s\]</div>
<p>of a single impurity coupled with <span class="math notranslate nohighlight">\(n_b\)</span> bath modes Anderson model Hamiltonian</p>
<div class="math notranslate nohighlight">
\[\begin{split}H_{\mathrm{SIAM}} = U c_{\uparrow}^\dagger c_{\uparrow} c_{\downarrow}^\dagger c_{\downarrow} - \mu(c_{\uparrow}^\dagger c_{\uparrow}+c_{\downarrow}^\dagger c_{\downarrow})
+ \sum_{i=1..n_b} \sum_{\sigma=\uparrow,\downarrow} V_i (c_{\sigma}^\dagger a_{i,\sigma} + \mathrm{h.c.}) \\
+ \sum_{i=1..n_b} \sum_{\sigma=\uparrow,\downarrow} \epsilon_i a_{i,\sigma}^\dagger a_{i,\sigma}.\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>float</em>) – Coulomb repulsion intensity.</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – Chemical potential.</p></li>
<li><p><strong>V</strong> (<em>np.ndarray</em>) – Tunneling energies. This vector has the same size as the number of bath mode.</p></li>
<li><p><strong>epsilon</strong> (<em>np.ndarray</em>) – Bath modes energies. This vector has the same size as the number of bath mode.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a> object constructed from <span class="math notranslate nohighlight">\(h_{pq}\)</span> (matrix of size
<span class="math notranslate nohighlight">\((2n_b+2) \times (2n_b+2)\)</span>) and <span class="math notranslate nohighlight">\(h_{pqrs}\)</span> (4D tensor with size <span class="math notranslate nohighlight">\(2n_b+2\)</span> in each dimension)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Convention:
<span class="math notranslate nohighlight">\(f_0\)</span> corresponds to <span class="math notranslate nohighlight">\(c_{\uparrow}\)</span> (annihilation in the ‘up’ mode of the impurity),
<span class="math notranslate nohighlight">\(f_1\)</span> corresponds to <span class="math notranslate nohighlight">\(c_{\downarrow}\)</span> (annihilation in the ‘down’ mode of the impurity),
<span class="math notranslate nohighlight">\(f_2\)</span> corresponds to <span class="math notranslate nohighlight">\(a_{1,\uparrow}\)</span> (annihilation in the ‘up’ mode of the 1st bath mode),
<span class="math notranslate nohighlight">\(f_3\)</span> corresponds to <span class="math notranslate nohighlight">\(a_{1,\downarrow}\)</span> (annihilation in the ‘down’ mode of the 1st bath mode),
and so on.</p>
</div>
</dd></dl>

</section>
<section id="the-generalized-impurity-hamiltonian">
<span id="qat-fermion-source-hamiltonians-constructors-embedded"></span><h3>The generalized impurity Hamiltonian<a class="headerlink" href="#the-generalized-impurity-hamiltonian" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.hamiltonians.make_embedded_model">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.hamiltonians.</span></span><span class="sig-name descname"><span class="pre">make_embedded_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_c</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_loc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">int_kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grouping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'spins'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.hamiltonians.make_embedded_model" title="Permalink to this definition"></a></dt>
<dd><p>Returns the canonical second quantized form</p>
<div class="math notranslate nohighlight">
\[H_{\mathrm{CSQ}} = \sum_{p,q} h_{pq} f_p^\dagger f_q + \frac{1}{2}\sum_{p,q,r,s} h_{pqrs} f_p^\dagger f_q^\dagger f_r f_s + c\mathbb{I}\]</div>
<p>of an embedded hamiltonian</p>
<div class="math notranslate nohighlight">
\[\begin{split}H_{\mathrm{emb}} = U \sum \limits_{i,j,k,l=1}^{2M} I_{ijkl} f^{\dagger}_i f_j f^{\dagger}_k f_l
               - \mu \sum \limits_{i=1}^{M} f^{\dagger}_{i} f_{j}
               + \sum \limits_{i, j=1}^{M} t^{\mathrm{loc}}_{ij} f^{\dagger}_i f_j \\
               + \sum \limits_{i,j=1}^{M} (D_{ij} f^{\dagger}_{i} f_{M+j} + \mathrm{h.c.}) \\
               + \sum \limits_{i,j=1}^{M} \lambda^c_{ij} f_{M+i} f^{\dagger}_{M+j}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is the number of orbitals (imp+bath). Indices here correspond to the spin-orbitals ordering referred to as
‘cluster’ (see below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>float</em>) – Onsite repulsion on impurity sites.</p></li>
<li><p><strong>mu</strong> (<em>float</em>) – Chemical potential.</p></li>
<li><p><strong>D</strong> (<em>np.ndarray</em>) – Hopping matrix (i.e. hybridization) between the correlated orbitals and the uncorrelated bath.</p></li>
<li><p><strong>lambda_c</strong> (<em>np.ndarray</em>) – Hopping matrix of the uncorrelated sites.</p></li>
<li><p><strong>t_loc</strong> (<em>Optional</em><em>[</em><em>np.ndarray</em><em>]</em>) – Hopping matrix of the correlated sites.</p></li>
<li><p><strong>int_kernel</strong> (<em>Optional</em><em>[</em><em>np.ndarray</em><em>]</em>) – Array <span class="math notranslate nohighlight">\(I\)</span> with 1 at position <span class="math notranslate nohighlight">\(i, j, k, l\)</span> where <span class="math notranslate nohighlight">\(U\)</span> must be put
(conv. for associated term: <span class="math notranslate nohighlight">\(c^{\dagger}c^{\dagger}cc\)</span>). Defaults to None,
in which case <span class="math notranslate nohighlight">\(U\)</span> is put before terms <span class="math notranslate nohighlight">\(c^{\dagger}_{2i}c^{\dagger}_{2i+1}c_{2i}c_{2i+1}, i=1..M/2\)</span> if grouping is ‘clusters’, <span class="math notranslate nohighlight">\(c^{\dagger}_{i}c^{\dagger}_{i+M}c_{i}c_{i+M}, i=1..M/2\)</span> if grouping is ‘spins’.
This array must be a 4D array.</p></li>
<li><p><strong>grouping</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Defines how spin-orbitals indices are ordered (see below), defaults to ‘spins’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a></p>
</dd>
</dl>
<p>The two grouping strategies are the following:</p>
<ul class="simple">
<li><p><strong>“clusters”</strong>: the first <span class="math notranslate nohighlight">\(M\)</span> orbitals SO are <span class="math notranslate nohighlight">\((\uparrow, \mathrm{imp}_0), (\downarrow, \mathrm{imp}_0),..., (\uparrow, \mathrm{imp}_{M-1}), (\downarrow, \mathrm{imp}_{M-1})\)</span> and the last <span class="math notranslate nohighlight">\(M\)</span> orbitals are bath orbitals with similar ordering.</p></li>
<li><p><strong>“spins”</strong>: the first <span class="math notranslate nohighlight">\(M\)</span> orbitals are <span class="math notranslate nohighlight">\((\uparrow, \mathrm{imp}_0), (\uparrow, \mathrm{imp}_1), ..., (\uparrow, \mathrm{bath}_{M-2}), (\uparrow, \mathrm{bath}_{M-1})\)</span> and the last <span class="math notranslate nohighlight">\(M\)</span> orbitals are down orbitals with similar ordering.</p></li>
</ul>
</dd></dl>

</section>
</section>
<section id="the-spin-fermion-transforms">
<span id="qat-fermion-source-transforms"></span><h2>The spin-fermion transforms<a class="headerlink" href="#the-spin-fermion-transforms" title="Permalink to this heading"></a></h2>
<section id="jordan-wigner-transform">
<span id="qat-fermion-source-transforms-jw"></span><h3>Jordan-Wigner transform<a class="headerlink" href="#jordan-wigner-transform" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.transforms.transform_to_jw_basis">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.transforms.</span></span><span class="sig-name descname"><span class="pre">transform_to_jw_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fermion_hamiltonian</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><span class="pre">FermionHamiltonian</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><span class="pre">SpinHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.transforms.transform_to_jw_basis" title="Permalink to this definition"></a></dt>
<dd><p>Transform to Jordan-Wigner (JW) basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fermion_hamiltonian</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><em>FermionHamiltonian</em></a><em>, </em><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><em>ElectronicStructureHamiltonian</em></a><em>]</em>) – The fermionic hamiltonian.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Hamiltonian in spin representation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian">SpinHamiltonian</a></p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.fermion</span> <span class="kn">import</span> <span class="n">FermionHamiltonian</span>
<span class="kn">from</span> <span class="nn">qat.fermion.transforms</span> <span class="kn">import</span> <span class="n">transform_to_jw_basis</span>

<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">FermionHamiltonian</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s2">&quot;Cc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">Term</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span> <span class="s2">&quot;CcCc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])])</span>

<span class="n">spin_hamiltonian</span> <span class="o">=</span> <span class="n">transform_to_jw_basis</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H = </span><span class="si">{</span><span class="n">hamiltonian</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H(spin) = </span><span class="si">{</span><span class="n">spin_hamiltonian</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">CCcc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> 

<span class="n">H</span><span class="p">(</span><span class="n">spin</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">I</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.075</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">YX</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="mf">0.075</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">YY</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="mf">0.075</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">XX</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">0.075</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">XY</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ZZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span><span class="o">|</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="bravyi-kitaev-transform">
<span id="qat-fermion-source-transforms-bk"></span><h3>Bravyi-Kitaev transform<a class="headerlink" href="#bravyi-kitaev-transform" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.transforms.transform_to_bk_basis">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.transforms.</span></span><span class="sig-name descname"><span class="pre">transform_to_bk_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fermion_hamiltonian</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><span class="pre">FermionHamiltonian</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><span class="pre">SpinHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.transforms.transform_to_bk_basis" title="Permalink to this definition"></a></dt>
<dd><p>Transform to Bravyi-Kitaev (BK) basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fermion_hamiltonian</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><em>FermionHamiltonian</em></a><em>, </em><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><em>ElectronicStructureHamiltonian</em></a><em>]</em>) – The fermionic hamiltonian.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Hamiltonian in BK spin representation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian">SpinHamiltonian</a></p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.fermion</span> <span class="kn">import</span> <span class="n">FermionHamiltonian</span>
<span class="kn">from</span> <span class="nn">qat.fermion.transforms</span> <span class="kn">import</span> <span class="n">transform_to_bk_basis</span>

<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">FermionHamiltonian</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s2">&quot;Cc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">Term</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span> <span class="s2">&quot;CcCc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])])</span>

<span class="n">spin_hamiltonian</span> <span class="o">=</span> <span class="n">transform_to_bk_basis</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H = </span><span class="si">{</span><span class="n">hamiltonian</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H(spin) = </span><span class="si">{</span><span class="n">spin_hamiltonian</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">CCcc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> 

<span class="n">H</span><span class="p">(</span><span class="n">spin</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">I</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.075</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.075</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">XZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="mf">0.075</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">0.075</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">YZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span><span class="o">|</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ZZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="parity-basis-transform">
<span id="qat-fermion-source-transforms-parity"></span><h3>Parity basis transform<a class="headerlink" href="#parity-basis-transform" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.transforms.transform_to_parity_basis">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.transforms.</span></span><span class="sig-name descname"><span class="pre">transform_to_parity_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fermion_hamiltonian</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><span class="pre">FermionHamiltonian</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><span class="pre">SpinHamiltonian</span></a></span></span><a class="headerlink" href="#qat.fermion.transforms.transform_to_parity_basis" title="Permalink to this definition"></a></dt>
<dd><p>Transform to parity basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fermion_hamiltonian</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><em>FermionHamiltonian</em></a><em>, </em><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><em>ElectronicStructureHamiltonian</em></a><em>]</em>) – The fermionic hamiltonian.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Hamiltonian in parity spin representation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian">SpinHamiltonian</a></p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.fermion</span> <span class="kn">import</span> <span class="n">FermionHamiltonian</span>
<span class="kn">from</span> <span class="nn">qat.fermion.transforms</span> <span class="kn">import</span> <span class="n">transform_to_parity_basis</span>

<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">FermionHamiltonian</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s2">&quot;Cc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">Term</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span> <span class="s2">&quot;CcCc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])])</span>

<span class="n">spin_hamiltonian</span> <span class="o">=</span> <span class="n">transform_to_parity_basis</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H = </span><span class="si">{</span><span class="n">hamiltonian</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H(spin) = </span><span class="si">{</span><span class="n">spin_hamiltonian</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">CCcc</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> 

<span class="n">H</span><span class="p">(</span><span class="n">spin</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">I</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.075</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.075</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">XZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="mf">0.075</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">0.075</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">YZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span><span class="o">|</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Z</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
<span class="p">(</span><span class="mf">0.35</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ZZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="fermionic-ansatz-circuits">
<span id="qat-fermion-source-ansatz"></span><h2>Fermionic ansatz circuits<a class="headerlink" href="#fermionic-ansatz-circuits" title="Permalink to this heading"></a></h2>
<section id="low-depth-circuit-ansatz-ldca">
<span id="qat-fermion-source-ansatz-ldca"></span><h3>Low-Depth Circuit Ansatz (LDCA)<a class="headerlink" href="#low-depth-circuit-ansatz-ldca" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.circuits.make_ldca_circ">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.circuits.</span></span><span class="sig-name descname"><span class="pre">make_ldca_circ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nb_fermionic_modes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigstate_ind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slater</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.wrappers.circuit.Circuit"><span class="pre">Circuit</span></a></span></span><a class="headerlink" href="#qat.fermion.circuits.make_ldca_circ" title="Permalink to this definition"></a></dt>
<dd><p>Construct a LDCA circuit (see <a class="reference external" href="https://doi.org/10.48550/arXiv.1801.01053">article by P. Dallaire-Demers et al. (2019)</a>),
applying ncycles layers of matchgates routines on nb_fermionic_modes qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nb_fermionic_modes</strong> (<em>int</em>) – Number of qubits.</p></li>
<li><p><strong>ncycles</strong> (<em>int</em>) – Number of LDCA cycles.</p></li>
<li><p><strong>eigstate_ind</strong> (<em>int</em><em>, </em><em>optional</em>) – Eigenstate index. Defaults to 0.</p></li>
<li><p><strong>slater</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – Whether to only include excitation-preserving rotations. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="multi-reference-mr-ansatz">
<span id="qat-fermion-source-ansatz-mr"></span><h3>Multi-Reference (MR) ansatz<a class="headerlink" href="#multi-reference-mr-ansatz" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.circuits.make_mr_circ">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.circuits.</span></span><span class="sig-name descname"><span class="pre">make_mr_circ</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.wrappers.circuit.Circuit"><span class="pre">Circuit</span></a></span></span><a class="headerlink" href="#qat.fermion.circuits.make_mr_circ" title="Permalink to this definition"></a></dt>
<dd><p>Builds a small, one-parameter Multi-Reference (MR) circuit on 4 qubits inspired from <a class="reference external" href="https://doi.org/10.1021/acscentsci.8b00788">Sugisaki et al. article (2019)</a> to prepare states in natural orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="multi-reference-excitation-preserving-mrep-ansatz">
<span id="qat-fermion-source-ansatz-mrep"></span><h3>Multi-Reference, Excitation-Preserving (MREP) ansatz<a class="headerlink" href="#multi-reference-excitation-preserving-mrep-ansatz" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.circuits.make_mrep_circ">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.circuits.</span></span><span class="sig-name descname"><span class="pre">make_mrep_circ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_fsim_cycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_phi_to_0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.wrappers.circuit.Circuit"><span class="pre">Circuit</span></a></span></span><a class="headerlink" href="#qat.fermion.circuits.make_mrep_circ" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the 8-qubit Multi-Reference Excitation Preserving (MREP) ansatz that combines
the multi-reference routine of <a class="reference external" href="https://doi.org/10.1021/acscentsci.8b00788">Sugisaki et al. article (2019)</a> with some fSim
nearest-neighbour cycles.
The second angles of the fSim gates (phi) may be taken to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_fsim_cycles</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of fSim cycles, defaults to 4.</p></li>
<li><p><strong>set_phi_to_0</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to set all second angles in the fSim gates to 0 (True)
or not (False). Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="general-hardware-efficient-ansatz">
<span id="qat-fermion-source-ansatz-hwe"></span><h3>General hardware-efficient ansatz<a class="headerlink" href="#general-hardware-efficient-ansatz" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.circuits.make_general_hwe_circ">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.circuits.</span></span><span class="sig-name descname"><span class="pre">make_general_hwe_circ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nqbits:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_cycles:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_gates:</span> <span class="pre">~typing.Optional[~typing.List[~qat.lang.AQASM.gates.Gate]]</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entangling_gate:</span> <span class="pre">~qat.lang.AQASM.gates.Gate</span> <span class="pre">=</span> <span class="pre">&lt;qat.lang.AQASM.gates.PredefGate</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.wrappers.circuit.Circuit"><span class="pre">Circuit</span></a></span></span><a class="headerlink" href="#qat.fermion.circuits.make_general_hwe_circ" title="Permalink to this definition"></a></dt>
<dd><p>Constructs an ansatz made of <span class="math notranslate nohighlight">\(n_{\mathrm{cycles}}\)</span> layers of so-called thinly-dressed routines,
that is to say entanglers surrounded by four one-qubit rotations are applied on nearest-neighbour
qubits in an odd/even alternating pattern.</p>
<p>This circuit is typically of the hardware-efficient class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nqbits</strong> (<em>int</em>) – Number of qubits of the circuit.</p></li>
<li><p><strong>n_cycles</strong> (<em>int</em>) – Number of layers.</p></li>
<li><p><strong>rotation_gates</strong> (<em>List</em><em>[</em><a class="reference internal" href="qat-lang.html#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><em>Gate</em></a><em>]</em>) – Parametrized rotation gates to include around the entangling gate. Defaults to <span class="math notranslate nohighlight">\(RY\)</span>. Must
be of arity 1.</p></li>
<li><p><strong>entangling_gate</strong> (<a class="reference internal" href="qat-lang.html#qat.lang.AQASM.gates.Gate" title="qat.lang.AQASM.gates.Gate"><em>Gate</em></a>) – The 2-qubit entangler. Must be of arity 2. Defaults to <span class="math notranslate nohighlight">\(CNOT\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="the-8-parameter-circuit-ansatz">
<span id="qat-fermion-source-ansatz-8params"></span><h3>The 8-parameter circuit ansatz<a class="headerlink" href="#the-8-parameter-circuit-ansatz" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.circuits.make_shallow_circ">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.circuits.</span></span><span class="sig-name descname"><span class="pre">make_shallow_circ</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.wrappers.circuit.Circuit"><span class="pre">Circuit</span></a></span></span><a class="headerlink" href="#qat.fermion.circuits.make_shallow_circ" title="Permalink to this definition"></a></dt>
<dd><p>Builds the 8-parameter circuit proposed in <a class="reference external" href="https://doi.org/10.48550/arXiv.1910.09512">Keen et al. article (2019)</a>.
This is a 4-qubit circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="compressed-ldca-ansatz-only-for-qlm-users">
<span id="qat-fermion-source-ansatz-compressed-ldca"></span><h3>Compressed LDCA ansatz (only for QLM users)<a class="headerlink" href="#compressed-ldca-ansatz-only-for-qlm-users" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.circuits.make_compressed_ldca_circ">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.circuits.</span></span><span class="sig-name descname"><span class="pre">make_compressed_ldca_circ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nb_fermionic_modes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigstate_ind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slater</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.wrappers.circuit.Circuit"><span class="pre">Circuit</span></a></span></span><a class="headerlink" href="#qat.fermion.circuits.make_compressed_ldca_circ" title="Permalink to this definition"></a></dt>
<dd><p>Builds a compressed version of the LDCA ansatz circuit.</p>
<p>The new pattern was obtained using qat.synthopline.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nb_fermionic_modes</strong> (<em>int</em>) – Number of qubits.</p></li>
<li><p><strong>ncycles</strong> (<em>int</em>) – Number of LDCA cycles.</p></li>
<li><p><strong>eigstate_ind</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – Eigenstate index. Defaults to 0.</p></li>
<li><p><strong>slater</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – Whether to only include excitation-preserving rotations.
Defaults to False.</p></li>
</ul>
</dd>
</dl>
<p>Return:
<a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code></a></p>
</dd></dl>

</section>
</section>
<section id="quantum-phase-estimation">
<span id="qat-fermion-source-qpe"></span><h2>Quantum phase estimation<a class="headerlink" href="#quantum-phase-estimation" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.phase_estimation.perform_phase_estimation">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.phase_estimation.</span></span><span class="sig-name descname"><span class="pre">perform_phase_estimation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_el</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_phase_bits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_trotter_steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_vec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_adiab_steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E_target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_interval</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_transform</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'jordan-wigner'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_shots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.phase_estimation.perform_phase_estimation" title="Permalink to this definition"></a></dt>
<dd><p>Perform quantum phase estimation (QPE) on an <a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a>. This Hamiltonian is
transformed to the computational basis via a Jordan-Wigner transformation and approximated via first order trotterization.
Other transformations like parity and Bravyi-Kitaev are also possible.</p>
<p>When providing an initial state one can specify it either as a string composed of zeros and ones, or as a
<a class="reference internal" href="qat-lang.html#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRoutine</span></code></a> which will produce it. The QPE is meant to start from an eigenstate of the
Hamiltonian, however, knowing apriori even one eigenstate of the system may be challenging. Therefore, this function comes with
adiabatic state preparation - an optional preliminary step to create an eigenstate of the Hamiltonian <span class="math notranslate nohighlight">\(H\)</span>.
This step consists in performing QPE <code class="code docutils literal notranslate"><span class="pre">n_adiab_steps</span></code> number of times, but not to read the phase bits (it is set to
only one), but rather to collapse the system to an eigenstate (read from the data bits). The first of the series of QPE
executions starts from the lowest energy eigenstate of the Hamiltonian composed of <span class="math notranslate nohighlight">\(h_{pq}\)</span>. Then, <span class="math notranslate nohighlight">\(h_{pq}\)</span> is
linearly transformed to <span class="math notranslate nohighlight">\(H\)</span> and at each new step we start from the eigenstate of the Hamiltonian of the previous step.
This guarantees that when the main QPE routine starts, it will do so from an eigenstate of the full <span class="math notranslate nohighlight">\(H\)</span>.</p>
<p>Usually, energies lie outside the range <span class="math notranslate nohighlight">\((-\frac{2\pi}{t}, 0)\)</span>. However, this range can be adjusted by searching inside
the window <span class="math notranslate nohighlight">\((E_{target} - \frac{\Delta}{2}, E_{target} + \frac{\Delta}{2})\)</span> with <span class="math notranslate nohighlight">\(E_{target}\)</span> and <span class="math notranslate nohighlight">\(\Delta\)</span>
specified by <code class="code docutils literal notranslate"><span class="pre">E_target</span></code> and <code class="code docutils literal notranslate"><span class="pre">size_interval</span></code>, respectively. It is suggested to always start from a large size
interval and unbiased target energy like <span class="math notranslate nohighlight">\(0\)</span> thus enclosing many of the eigenenergies including the desired one. One can
then narrow the window around an already found eigenenergy for a better precision. Working with a window not enclosing an
eigenenergy would still evaluate to a result, but it may be misleading.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>Regarding the adiabatic state preparation, if the lowest energy eigenstate of the first-step Hamiltonian <span class="math notranslate nohighlight">\(h_{pq}\)</span> is also an eigenstate of the whole <span class="math notranslate nohighlight">\(H\)</span>, the system will remain in it until the end of the whole adiabatic stage. Hence, this eigenstate may not be the one of the lowest energy anymore.</p></li>
<li><p>As a rule of thumb, if small changes to the interval cause considerable deviations in the energy, that’s a sign that the window is too small or a different target energy may be better.</p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H_el</strong> (<a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><em>ElectronicStructureHamiltonian</em></a>) – An electronic-structure Hamiltonian.</p></li>
<li><p><strong>n_phase_bits</strong> (<em>int</em>) – Number of qubits for the phase evaluation. The larger it is, the
more accurate is the result.</p></li>
<li><p><strong>n_trotter_steps</strong> (<em>int</em>) – Number of first order trotterization steps. For good phase estimation it
should also increase if n_phase_bits is increased.</p></li>
<li><p><strong>init_vec</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Initial vector specified in the computational basis as a
string - ‘01101’ for example. Starting from <a href="#id2"><span class="problematic" id="id3">|</span></a>0..0&gt; an X will be applied to the respective
qubits so as to produce the provided vector. This vector will enter the adiabatic state
preparation routine if n_adiab_steps is not 0 or will be given straight to the main QPE routine.</p></li>
<li><p><strong>n_adiab_steps</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – Number of steps to pass from the part of the Hamiltonian containing
only c_p^dagger * c_p terms (which is diagonal and fast to deal with) to the Hamiltonian of interest.</p></li>
<li><p><strong>E_target</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – Expected energy. If unknown, set to 0.</p></li>
<li><p><strong>size_interval</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – Size <span class="math notranslate nohighlight">\(\Delta\)</span> of the interval one thinks the value
of the energy is in: <span class="math notranslate nohighlight">\(E \in [E_\mathrm{target}-\Delta/2, E_\mathrm{target}+\Delta/2]\)</span>
If no idea take <span class="math notranslate nohighlight">\(\Delta =2 E_\mathrm{max}\)</span>, with <span class="math notranslate nohighlight">\(E_\mathrm{max}\)</span> an upper
bound of the energy.</p></li>
<li><p><strong>basis_transform</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Transformation to go from <a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.fermion.hamiltonians.ElectronicStructureHamiltonian</span></code></a>
into a <a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.fermion.hamiltonians.SpinHamiltonian</span></code></a>: one can use the “jordan-wigner” (default),
“bravyi-kitaev” or “parity” transformations.</p></li>
<li><p><strong>qpu</strong> (<em>Optional</em><em>[</em><em>QPU</em><em>]</em>) – QPU to use for computation. Will use by default the default installed QPU.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>Energy found,</p></li>
<li><p>associated probability.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[float, float]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Usually, energies lie outside the range <span class="math notranslate nohighlight">\((-\frac{2\pi}{t}, 0)\)</span>. However, this range can be adjusted
by specifying the arguments <cite>E_target</cite> and <cite>size_interval</cite> thus searching inside the window
<span class="math notranslate nohighlight">\((E_{t} - \frac{\Delta}{2}, E_{target} + \frac{size\_interval}{2})\)</span>,
where <span class="math notranslate nohighlight">\(E_{t}\)</span> and <span class="math notranslate nohighlight">\(\Delta\)</span> stand for . We suggest to always start from a large size interval
and unbiased target energy like 0 thus enclosing many of the eigenenergies including the desired one.
One can then narrow the window around an already found eigenenergy for a better precision.
Experience shows that working with a window not enclosing an eigenenergy makes the QPE still output a result,
but it is misleading.</p>
</div>
</dd></dl>

</section>
<section id="quantum-subspace-expansion">
<span id="qat-fermion-source-qse"></span><h2>Quantum subspace expansion<a class="headerlink" href="#quantum-subspace-expansion" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.qse.apply_quantum_subspace_expansion">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.qse.</span></span><span class="sig-name descname"><span class="pre">apply_quantum_subspace_expansion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><span class="pre">SpinHamiltonian</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep_circ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.wrappers.circuit.Circuit"><span class="pre">Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">expansion_operators</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.wrappers.observable.Observable"><span class="pre">Observable</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qat-core.html#qat.core.qpu.QPUHandler" title="qat.core.qpu.qpu.QPUHandler"><span class="pre">QPUHandler</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbshots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.chemistry.qse.apply_quantum_subspace_expansion" title="Permalink to this definition"></a></dt>
<dd><p>Apply quantum subspace expansion (QSE) to the given Hamiltonian.</p>
<p>QSE is a method that improves the quality of noisy results at
the cost of additional measurements that help write the Hamiltonian
in the small subspace where it can be diagonalized classically.</p>
<p>If <span class="math notranslate nohighlight">\(\langle \Psi^\star | \hat{H} | \Psi^\star \rangle\)</span> is the
VQE result, the projected Hamiltonian matrix is built from</p>
<div class="math notranslate nohighlight">
\[H^{(s)}_{i,j} =   \langle \Psi^\star |
            \hat{O}_i^\dagger \hat{H} \hat{O}_j
            | \Psi^\star \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{O}_i\)</span> is an element of <cite>expansion_operators</cite>.</p>
<p>Then the generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[H^{(s)} \vec{x} = E S \vec{x}\]</div>
<p>is solved, with <span class="math notranslate nohighlight">\(S\)</span> the overlap matrix:</p>
<div class="math notranslate nohighlight">
\[S_{i,j} = \langle \Psi^\star | \hat{O}_i^\dagger \hat{O}_j | \Psi^\star \rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><em>SpinHamiltonian</em></a>) – The Hamiltonian in its spin representation.</p></li>
<li><p><strong>state_prep_circ</strong> (<a class="reference internal" href="qat-core.html#qat.core.Circuit" title="qat.core.Circuit"><em>Circuit</em></a>) – The state preparation circuit.</p></li>
<li><p><strong>expansion_operators</strong> (<em>list&lt;SpinHamiltonian&gt;</em>) – The set of operators <span class="math notranslate nohighlight">\({O_i}_i\)</span>
generating the subspace of interest.</p></li>
<li><p><strong>qpu</strong> (<a class="reference internal" href="qat-core.html#qat.core.qpu.QPUHandler" title="qat.core.qpu.QPUHandler"><em>QPUHandler</em></a>) – The QPU.</p></li>
<li><p><strong>nbshots</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of shots. Defaults to 0:
infinite number of shots.</p></li>
<li><p><strong>threshold</strong> (<em>float</em><em>, </em><em>optional</em>) – The numerical threshold.</p></li>
<li><p><strong>return_matrices</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <code class="code docutils literal notranslate"><span class="pre">True</span></code>, the
function returns the matrices <span class="math notranslate nohighlight">\(H^{(s)}\)</span> and <span class="math notranslate nohighlight">\(S\)</span>. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Improved energy provided by the QSE procedure.
matrix_h (Optional[np.ndarray]): The subspace Hamiltonian <span class="math notranslate nohighlight">\(H^{(s)}\)</span>. Only if <code class="code docutils literal notranslate"><span class="pre">return_matrices</span></code> is True.
matrix_s (Optional[np.ndarray]): The overlap matrix <span class="math notranslate nohighlight">\(S\)</span>.  Only if <code class="code docutils literal notranslate"><span class="pre">return_matrices</span></code> is True.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>e_qse (float)</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.fermion</span> <span class="kn">import</span> <span class="n">SpinHamiltonian</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">RY</span><span class="p">,</span> <span class="n">CNOT</span><span class="p">,</span> <span class="n">RZ</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>
<span class="kn">from</span> <span class="nn">qat.plugins</span> <span class="kn">import</span> <span class="n">SeqOptim</span>

<span class="c1"># We instantiate the Hamiltonian we want to approximate the ground state energy of</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">SpinHamiltonian</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">,</span> <span class="s2">&quot;ZZ&quot;</span><span class="p">]])</span>

<span class="c1"># We construct the variational circuit (ansatz)</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">reg</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">theta_</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">RY</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">RY</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">])(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">RZ</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">2</span><span class="p">])(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Construct a (variational) job with the variational circuit and the observable</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">observable</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">,</span>
                <span class="n">nbshots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># We now build a stack that can handle variational jobs</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">SeqOptim</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">optimizer</span> <span class="o">|</span> <span class="n">qpu</span>

<span class="c1"># We submit the job and print the optimized variational energy (the exact GS energy is -3)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
<span class="n">E_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;E(VQE) = </span><span class="si">%s</span><span class="s2"> (err = </span><span class="si">%s</span><span class="s2"> </span><span class="si">%%</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="nb">abs</span><span class="p">((</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="o">-</span><span class="n">E_min</span><span class="p">)</span><span class="o">/</span><span class="n">E_min</span><span class="p">)))</span>
<span class="n">e_vqe</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span>

<span class="c1"># We use the optimal parameters found by VQE</span>
<span class="n">opt_circ</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">bind_variables</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;parameter_map&quot;</span><span class="p">]))</span>

<span class="n">expansion_operators</span> <span class="o">=</span> <span class="p">[</span><span class="n">SpinHamiltonian</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">1.0</span><span class="p">),</span>
                    <span class="n">SpinHamiltonian</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;ZZ&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])])]</span>

<span class="kn">from</span> <span class="nn">qat.fermion.chemistry.qse</span> <span class="kn">import</span> <span class="n">apply_quantum_subspace_expansion</span>
<span class="n">e_qse</span> <span class="o">=</span> <span class="n">apply_quantum_subspace_expansion</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span>
                                        <span class="n">opt_circ</span><span class="p">,</span>
                                        <span class="n">expansion_operators</span><span class="p">,</span>
                                        <span class="n">qpu</span><span class="p">,</span>
                                        <span class="n">return_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;E(QSE) = </span><span class="si">%s</span><span class="s2"> (err = </span><span class="si">%s</span><span class="s2"> </span><span class="si">%%</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">e_qse</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="nb">abs</span><span class="p">((</span><span class="n">e_qse</span><span class="o">-</span><span class="n">E_min</span><span class="p">)</span><span class="o">/</span><span class="n">E_min</span><span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span><span class="p">(</span><span class="n">VQE</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.0</span> <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">%</span><span class="p">)</span>
<span class="n">E</span><span class="p">(</span><span class="n">QSE</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.0</span> <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">%</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="unitary-coupled-cluster-ucc">
<h2>Unitary Coupled-Cluster (UCC)<a class="headerlink" href="#unitary-coupled-cluster-ucc" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.ucc.transform_integrals_to_new_basis">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.ucc.</span></span><span class="sig-name descname"><span class="pre">transform_integrals_to_new_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_mat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.chemistry.ucc.transform_integrals_to_new_basis" title="Permalink to this definition"></a></dt>
<dd><p>Change one and two body integrals (indices p, q…) to
new basis (indices i, j…) using transformation U such that</p>
<div class="math notranslate nohighlight">
\[\hat{c}_{i}=\sum_{q}U_{qi}c_{q}\]</div>
<p>i.e</p>
<div class="math notranslate nohighlight">
\[\hat{I}_{ij} =\sum_{pq}U_{pi}I_{pq}U_{jq}^{\dagger}
\hat{I}_{ijkl}=\sum_{pqrs}U_{pi}U_{qj}I_{pqrs}U_{kr}^{\dagger}U_{ls}^{\dagger}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_body_integrals</strong> (<em>np.ndarray</em>) – One-body integrals <span class="math notranslate nohighlight">\(I_{pq}\)</span>.</p></li>
<li><p><strong>two_body_integrals</strong> (<em>np.ndarray</em>) – Two-body integrals <span class="math notranslate nohighlight">\(I_{pqrs}\)</span>.</p></li>
<li><p><strong>u_mat</strong> (<em>np.ndarray</em>) – Transformation matrix <span class="math notranslate nohighlight">\(U\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>h_hat_ij (np.ndarray): One-body integrals <span class="math notranslate nohighlight">\(\hat{I}_{ij}\)</span>.</p></li>
<li><p>h_hat_ijkl (np.ndarray): Two-body integrals <span class="math notranslate nohighlight">\(\hat{I}_{ijkl}\)</span>.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.ndarray, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.ucc.compute_active_space_integrals">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.ucc.</span></span><span class="sig-name descname"><span class="pre">compute_active_space_integrals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.chemistry.ucc.compute_active_space_integrals" title="Permalink to this definition"></a></dt>
<dd><p>Restrict one- and two-body integrals for given list of active indices.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\forall u,v\in \mathcal{A},\; I^{(a)}_{uv} = I_{uv} + \sum_{i\in \mathcal{O}} 2 I_{i,u,v,i} - I_{i,u,i,v}\\\forall u,v,w,x \in \mathcal{A}, I^{(a)}_{uvwx} = I_{uvwx}\\c^{(a)} = c + \sum_{i\in\mathcal{O}} I_{ii} + \sum_{ij\in\mathcal{O}} 2I_{ijji} - I_{ijij}\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_body_integrals</strong> (<em>np.ndarray</em>) – Array of one-body integrals <span class="math notranslate nohighlight">\(I_{uv}\)</span>. Must be 2D.</p></li>
<li><p><strong>two_body_integrals</strong> (<em>np.ndarray</em>) – Array of two-body integrals <span class="math notranslate nohighlight">\(I_{uvwx}\)</span>. Must be 4D.</p></li>
<li><p><strong>active_indices</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Active indices.</p></li>
<li><p><strong>occupied_indices</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Occupied indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>2D array of one-body integrals <span class="math notranslate nohighlight">\(I_{uv}^{(a)}\)</span>,</p></li>
<li><p>4D array of two-body integrals <span class="math notranslate nohighlight">\(I_{uvwx}^{(a)}\)</span>,</p></li>
<li><p>core constant <span class="math notranslate nohighlight">\(c^{(a)}\)</span>.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.ndarray, np.ndarray, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.ucc.convert_to_h_integrals">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.ucc.</span></span><span class="sig-name descname"><span class="pre">convert_to_h_integrals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.chemistry.ucc.convert_to_h_integrals" title="Permalink to this definition"></a></dt>
<dd><p>Convert from <span class="math notranslate nohighlight">\(I_{uv},I_{uvwx}\)</span> to <span class="math notranslate nohighlight">\(h_{pq},h_{pqrs}\)</span>, with</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}h_{u\sigma, v\sigma'} = I_{u, v} \delta_{\sigma, \sigma'}\\h_{u\sigma_1, v\sigma_2, w\sigma_2', x\sigma_1'} =  I_{uvwx} \left((1-\delta_{\sigma,\sigma'}) + \delta_{\sigma,\sigma'} (1-\delta_{u,v})(1-\delta_{w,x})   \right)\end{aligned}\end{align} \]</div>
<p>and where the one- and two-body integrals are defined as:</p>
<div class="math notranslate nohighlight">
\[I_{uv}\equiv(u|h|v)=\int\mathrm{d}r\phi_{u}^{*}(r)T\phi_{v}(r)\]</div>
<div class="math notranslate nohighlight">
\[I_{uvwx}\equiv(ux|vw)=\iint\mathrm{d}r_{1}\mathrm{d}r_{2}\phi_{u}^{*}(r_{1})\phi_{x}(r_{1})v(r_{12})\phi_{v}^{*}(r_{2})\phi_{w}(r_{2})\]</div>
<p>with <span class="math notranslate nohighlight">\(T\)</span> (resp. <span class="math notranslate nohighlight">\(v\)</span>) the one- (resp. two-) body potentials,
and <span class="math notranslate nohighlight">\(\phi_u(r)\)</span> is the molecular orbital wavefunction.</p>
<p>The <span class="math notranslate nohighlight">\(h\)</span> integrals are used to construct hamiltonians of the
ElectronicStructureHamiltonian type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_body_integrals</strong> (<em>np.ndarray</em>) – Array of one-body integrals <span class="math notranslate nohighlight">\(I_{uv}\)</span>. Must be 2D.</p></li>
<li><p><strong>two_body_integrals</strong> (<em>np.ndarray</em>) – Array of two-body integrals <span class="math notranslate nohighlight">\(I_{uvwx}\)</span>. Must be 4D.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>the <span class="math notranslate nohighlight">\(h_{pq}\)</span> integrals,</p></li>
<li><p>the <span class="math notranslate nohighlight">\(h_{pqrs}\)</span> integrals.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.ndarray, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.ucc.construct_ucc_ansatz">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.ucc.</span></span><span class="sig-name descname"><span class="pre">construct_ucc_ansatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cluster_ops</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><span class="pre">SpinHamiltonian</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ket_hf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qat-lang.html#qat.lang.AQASM.Program" title="qat.lang.AQASM.program.Program"><span class="pre">Program</span></a></span></span><a class="headerlink" href="#qat.fermion.chemistry.ucc.construct_ucc_ansatz" title="Permalink to this definition"></a></dt>
<dd><p>Builds the parametric state preparation circuit implementing the
provided cluster operator.</p>
<p>The returned function maps <span class="math notranslate nohighlight">\(\vec{\theta}\)</span> to a QRoutine
describing <span class="math notranslate nohighlight">\(Q\)</span> such as:</p>
<div class="math notranslate nohighlight">
\[Q \vert \vec{0} \rangle = \vert \mathrm{UCC} (\vec{\theta}) \rangle = e^{T(\vec{\theta})} \vert \mathrm{HF}\rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_ops</strong> (<em>List</em><em>[</em><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><em>SpinHamiltonian</em></a><em>]</em>) – The cluster operators iT (note the i factor).</p></li>
<li><p><strong>ket_hf</strong> (<em>int</em>) – The Hartree-Fock state in integer representation.</p></li>
<li><p><strong>n_steps</strong> (<em>int</em>) – Number of trotter steps.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The parametric program implementing the UCCSD method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="qat-lang.html#qat.lang.AQASM.Program" title="qat.lang.AQASM.Program">Program</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.ucc.select_active_orbitals">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.ucc.</span></span><span class="sig-name descname"><span class="pre">select_active_orbitals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.chemistry.ucc.select_active_orbitals" title="Permalink to this definition"></a></dt>
<dd><p>Selects the right active space and freezes core electrons
according to their NOONs.</p>
<p>This function is an implementation of the <em>Complete Active Space</em>
(CAS) approach. It divides orbital space into sets of <em>active</em> and
<em>inactive</em> orbitals, the occupation number of the latter remaining
unchanged during the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noons</strong> (<em>np.ndarray</em>) – The natural orbital occupation numbers
in descending order (from high occupations to low occupations)</p></li>
<li><p><strong>n_electrons</strong> (<em>int</em>) – The number of electrons.</p></li>
<li><p><strong>threshold_1</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – The upper threshold <span class="math notranslate nohighlight">\(\varepsilon_1\)</span> on
the NOON of an active orbital. Defaults to 0.02.</p></li>
<li><p><strong>threshold_2</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – The lower threshold <span class="math notranslate nohighlight">\(\varepsilon_2\)</span> on
the NOON of an active orbital. Defaults to 0.001.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>active_so (List[int]): The list of active spatial orbitals.</p></li>
<li><p>inactive_occupied_so (List[int]): The list of core spatial orbitals.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[List[int], List[int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.ucc.guess_init_params">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.ucc.</span></span><span class="sig-name descname"><span class="pre">guess_init_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_body_integrals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_energies</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.chemistry.ucc.guess_init_params" title="Permalink to this definition"></a></dt>
<dd><p>Find initial parameters using Møller-Plesset perturbation theory.</p>
<p>The trial parametrization is efficiently improved upon the
Hartree-Fock solution (which would set every initial parameter to
zero) thanks to the following formula identifying the UCC parameters
in the Møller-Plesset (MP2) solution :</p>
<div class="math notranslate nohighlight">
\[\theta_a^i = 0\]</div>
<div class="math notranslate nohighlight">
\[\theta_{a, b}^{i, j} = \frac{h_{a, b, i, j} -
h_{a, b, j, i}}{\epsilon_i + \epsilon_j -\epsilon_a -
\epsilon_b}\]</div>
<p>where <span class="math notranslate nohighlight">\(h_{p, q, r, s}\)</span> is the 2-electron molecular orbital integral,
and <span class="math notranslate nohighlight">\(\epsilon_i\)</span> is the orbital energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>two_body_integrals</strong> (<em>np.ndarray</em>) – 4D array of two-body integrals <span class="math notranslate nohighlight">\(I_{uvwx}\)</span>.</p></li>
<li><p><strong>n_electrons</strong> (<em>int</em>) – The number of active electrons of the system.</p></li>
<li><p><strong>noons</strong> (<em>List</em><em>[</em><em>float</em><em>]</em>) – the natural-orbital occupation numbers
<span class="math notranslate nohighlight">\(n_i\)</span>, sorted in descending order (from high occupations
to low occupations) (doubled due to spin degeneracy).</p></li>
<li><p><strong>orbital_energies</strong> (<em>List</em><em>[</em><em>float</em><em>]</em>) – The energies of the molecular orbitals
<span class="math notranslate nohighlight">\(\epsilon_i\)</span> (doubled due to spin degeneracy).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The list of initial coefficients <span class="math notranslate nohighlight">\(\{\theta_{a}^{i}, a \in \mathcal{I}',
i \in \mathcal{O}' \} \cup \{\theta_{ab}^{ij}, a&gt;b, i&gt;j, a,b \in \mathcal{I}',
i,j \in \mathcal{O}'\}\)</span>,</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>theta_list (List[float])</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.ucc.get_hf_ket">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.ucc.</span></span><span class="sig-name descname"><span class="pre">get_hf_ket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nqbits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#qat.fermion.chemistry.ucc.get_hf_ket" title="Permalink to this definition"></a></dt>
<dd><p>Get Hartree-Fock state stored as a vector with right-to-left orbitals indexing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_electrons</strong> (<em>int</em>) – The number of active electrons of the system.</p></li>
<li><p><strong>nqbits</strong> – The number of qubits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Hartree-Fock state.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.ucc.get_cluster_ops">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.ucc.</span></span><span class="sig-name descname"><span class="pre">get_cluster_ops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_electrons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nqbits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noons</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><span class="pre">FermionHamiltonian</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#qat.fermion.chemistry.ucc.get_cluster_ops" title="Permalink to this definition"></a></dt>
<dd><p>Compute the cluster operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_electrons</strong> (<em>int</em>) – The number of active electrons of the system.</p></li>
<li><p><strong>nqbits</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The number of qubits.</p></li>
<li><p><strong>noons</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>float</em><em>]</em><em>]</em>) – The natural-orbital occupation numbers
<span class="math notranslate nohighlight">\(n_i\)</span>, sorted in descending order (from high occupations
to low occupations) (doubled due to spin degeneracy).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The list of cluster operators <span class="math notranslate nohighlight">\(\{T_{a}^{i}, a \in \mathcal{I}', i \in \mathcal{O}' \} \cup \{T_{ab}^{ij}, a&gt;b, i&gt;j, a,b \in \mathcal{I}', i,j \in \mathcal{O}'\}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian">FermionHamiltonian</a>]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function accepts as input the number of qubits or the noons. One of them is needed for the computation of the
cluster operators. <code class="code docutils literal notranslate"><span class="pre">n_electrons</span></code> and <code class="code docutils literal notranslate"><span class="pre">n_qbits</span></code> must be pair.</p>
</div>
</dd></dl>

</section>
<section id="utility-functions">
<span id="qat-fermion-source-trotter"></span><h2>Utility functions<a class="headerlink" href="#utility-functions" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.trotterisation.make_trotterisation_routine">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.trotterisation.</span></span><span class="sig-name descname"><span class="pre">make_trotterisation_routine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><span class="pre">SpinHamiltonian</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><span class="pre">FermionHamiltonian</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><span class="pre">ElectronicStructureHamiltonian</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_trotter_steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'jordan-wigner'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qat-lang.html#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine"><span class="pre">QRoutine</span></a></span></span><a class="headerlink" href="#qat.fermion.trotterisation.make_trotterisation_routine" title="Permalink to this definition"></a></dt>
<dd><p>This function first trotterizes the evolution operator <span class="math notranslate nohighlight">\(e^{-i H t}\)</span> of a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> using a first
order approximation. If the Hamiltonian is fermionic, it is converted to its spin representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><em>SpinHamiltonian</em></a><em>, </em><a class="reference internal" href="#qat.fermion.hamiltonians.FermionHamiltonian" title="qat.fermion.hamiltonians.FermionHamiltonian"><em>FermionHamiltonian</em></a><em>, </em><a class="reference internal" href="#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><em>ElectronicStructureHamiltonian</em></a><em>]</em>) – Hamiltonian to trotterize.</p></li>
<li><p><strong>n_trotter_steps</strong> (<em>int</em>) – Number <span class="math notranslate nohighlight">\(n\)</span> of Trotter steps.</p></li>
<li><p><strong>final_time</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – Time <span class="math notranslate nohighlight">\(t\)</span> in the evolution operator.</p></li>
<li><p><strong>method</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Method to use for the transformation to a spin representation. Other available methods include
<code class="code docutils literal notranslate"><span class="pre">&quot;bravyi-kitaev&quot;</span></code> and <code class="code docutils literal notranslate"><span class="pre">&quot;parity&quot;</span></code>. Defaults to <code class="code docutils literal notranslate"><span class="pre">&quot;jordan-wigner&quot;</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Gates to apply to perform the time evolution of the chemical Hamiltonian with trotterisation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="qat-lang.html#qat.lang.AQASM.routines.QRoutine" title="qat.lang.AQASM.routines.QRoutine">QRoutine</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul>
<li><p>In the fermionic case :</p>
<div class="math notranslate nohighlight">
\[e^{-i H t} \approx \prod_{k=1}^{n} \left( \prod_{pq} e^{-i \frac{t}{n} h_{pq} c_p^\dagger c_q} \prod_{pqrs} e^{-\frac{i}{2}\frac{t}{n} h_{pqrs} e^{-i c_p^\dagger c_q^\dagger c_r c_s} } \right)\]</div>
<p>This operator is then mapped to a product of Pauli operators via a Jordan-Wigner transformation and the resulting QRoutine
is returned.</p>
</li>
<li><p>The QRoutine implements a first order Trotter approximation, but higher order approximations are possible.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qat.fermion.chemistry.pyscf_tools.perform_pyscf_computation">
<span class="sig-prename descclassname"><span class="pre">qat.fermion.chemistry.pyscf_tools.</span></span><span class="sig-name descname"><span class="pre">perform_pyscf_computation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_fci</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.fermion.chemistry.pyscf_tools.perform_pyscf_computation" title="Permalink to this definition"></a></dt>
<dd><p>Perform various calculations using PySCF. This function is a helper function meant to kickstart molecule studies. Its use is
completely optional, and using other methods or packages is entirely possible.</p>
<p>This function will compute:</p>
<blockquote>
<div><ul class="simple">
<li><p>The reduced density matrix,</p></li>
<li><p>The orbital energies,</p></li>
<li><p>The nuclear repulsion constant,</p></li>
<li><p>The number of electrons,</p></li>
<li><p>The one- and two-body integrals,</p></li>
<li><p>The groundstate energies obtained through Hartree-Fock and 2nd order Möller-Plesset perturbation approach,</p></li>
<li><p>(Optional) The groundstate energy using the full configuration interaction (full CI) approach.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The FCI computation is very expensive for big molecules. Enable it only for small molecules !</p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geometry</strong> (<em>list</em>) – <p>Defines the molecular structure. The internal format is PySCF format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">atom</span> <span class="o">=</span> <span class="p">[[</span><span class="n">atom1</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">atom2</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)],</span>
        <span class="o">...</span>
        <span class="p">[</span><span class="n">atomN</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)]]</span>
</pre></div>
</div>
</p></li>
<li><p><strong>basis</strong> (<em>str</em>) – Defines the basis set.</p></li>
<li><p><strong>spin</strong> (<em>int</em>) – 2S, number of alpha electrons - number beta electrons to control multiplicity. If spin is None, multiplicity</p></li>
<li><p><strong>molecule.</strong> (<em>will be guessed based on the neutral</em>) – </p></li>
<li><p><strong>charge</strong> (<em>int</em>) – Charge of molecule. Affects the electron numbers.</p></li>
<li><p><strong>run_fci</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the groundstates energies should also be computed using a full CI approach. Defaults to
False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>rdm1 (np.ndarray): Reduced density matrix.</p></li>
<li><p>orbital_energies (list): List of orbital energies.</p></li>
<li><p>nuclear_repulsion (float): Nuclear repulsion constant.</p></li>
<li><p>nels (int): Number of electrons.</p></li>
<li><p>one_body_integrals (np.ndarray): One-body integral.</p></li>
<li><p>two_body_integrals (np.ndarray): Two-body integral.</p></li>
<li><p>info (dict): Dictionary containing the Hartree-Fock and 2nd order Möller-Plesset computed ground state energies (and optionally the Full CI energy if run_fci is set to True).</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.ndarray, list, float, int, np.ndarray, np.ndarray, dict]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="plugins">
<h2>Plugins<a class="headerlink" href="#plugins" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="plugin_adaptvqe.html#qat-fermion-source-adaptvqe"><span class="std std-ref">AdaptVQEPlugin</span></a></p></li>
<li><p><a class="reference internal" href="plugin_gradient_descent.html#qat-fermion-source-natgrad"><span class="std std-ref">GradientDescentOptimizer</span></a></p></li>
<li><p><a class="reference internal" href="plugin_seqoptim.html#qat-fermion-source-seqoptim"><span class="std std-ref">SeqOptim</span></a></p></li>
<li><p><a class="reference internal" href="plugin_multiplelaunches.html#qat-fermion-source-multiplelaunches"><span class="std std-ref">MultipleLaunchesAnalyzer</span></a></p></li>
<li><p><a class="reference internal" href="plugin_zeronoise.html#qat-fermion-source-zeronoise"><span class="std std-ref">ZeroNoiseExtrapolator</span></a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="myqlm_specific/qat-simulated_annealing.html" class="btn btn-neutral float-left" title="qat.simulated_annealing: Simulated Annealing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="qat-opt.html" class="btn btn-neutral float-right" title="qat-opt: representation and encoding of combinatorial problems, QAOA" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Atos 2016-2022.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>